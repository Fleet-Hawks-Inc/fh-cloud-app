{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, PLATFORM_ID, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Input, Output, Directive, ContentChildren, NgModule, Injectable } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { BehaviorSubject, Observable, Subject, combineLatest } from 'rxjs';\nimport { switchMap, take, map, takeUntil } from 'rxjs/operators';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Manages event on a Google Maps object, ensuring that events are added only when necessary. */\n\nconst _c0 = [\"*\"];\n\nclass MapEventManager {\n  constructor(_ngZone) {\n    this._ngZone = _ngZone;\n    /** Pending listeners that were added before the target was set. */\n\n    this._pending = [];\n    this._listeners = [];\n    this._targetStream = new BehaviorSubject(undefined);\n  }\n  /** Clears all currently-registered event listeners. */\n\n\n  _clearListeners() {\n    for (const listener of this._listeners) {\n      listener.remove();\n    }\n\n    this._listeners = [];\n  }\n  /** Gets an observable that adds an event listener to the map when a consumer subscribes to it. */\n\n\n  getLazyEmitter(name) {\n    return this._targetStream.pipe(switchMap(target => {\n      const observable = new Observable(observer => {\n        // If the target hasn't been initialized yet, cache the observer so it can be added later.\n        if (!target) {\n          this._pending.push({\n            observable,\n            observer\n          });\n\n          return undefined;\n        }\n\n        const listener = target.addListener(name, event => {\n          this._ngZone.run(() => observer.next(event));\n        });\n\n        this._listeners.push(listener);\n\n        return () => listener.remove();\n      });\n      return observable;\n    }));\n  }\n  /** Sets the current target that the manager should bind events to. */\n\n\n  setTarget(target) {\n    const currentTarget = this._targetStream.value;\n\n    if (target === currentTarget) {\n      return;\n    } // Clear the listeners from the pre-existing target.\n\n\n    if (currentTarget) {\n      this._clearListeners();\n\n      this._pending = [];\n    }\n\n    this._targetStream.next(target); // Add the listeners that were bound before the map was initialized.\n\n\n    this._pending.forEach(subscriber => subscriber.observable.subscribe(subscriber.observer));\n\n    this._pending = [];\n  }\n  /** Destroys the manager and clears the event listeners. */\n\n\n  destroy() {\n    this._clearListeners();\n\n    this._pending = [];\n\n    this._targetStream.complete();\n  }\n\n} /// <reference types=\"google.maps\" />\n\n/** default options set to the Googleplex */\n\n\nconst DEFAULT_OPTIONS = {\n  center: {\n    lat: 37.421995,\n    lng: -122.084092\n  },\n  zoom: 17,\n  // Note: the type conversion here isn't necessary for our CI, but it resolves a g3 failure.\n  mapTypeId: 'roadmap'\n};\n/** Arbitrary default height for the map element */\n\nconst DEFAULT_HEIGHT = '500px';\n/** Arbitrary default width for the map element */\n\nconst DEFAULT_WIDTH = '500px';\n/**\n * Angular component that renders a Google Map via the Google Maps JavaScript\n * API.\n * @see https://developers.google.com/maps/documentation/javascript/reference/\n */\n\nclass GoogleMap {\n  constructor(_elementRef, _ngZone, platformId) {\n    this._elementRef = _elementRef;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    /** Height of the map. Set this to `null` if you'd like to control the height through CSS. */\n\n    this.height = DEFAULT_HEIGHT;\n    /** Width of the map. Set this to `null` if you'd like to control the width through CSS. */\n\n    this.width = DEFAULT_WIDTH;\n    this._options = DEFAULT_OPTIONS;\n    /** Event emitted when the map is initialized. */\n\n    this.mapInitialized = new EventEmitter();\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/events#auth-errors\n     */\n\n    this.authFailure = new EventEmitter();\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.bounds_changed\n     */\n\n    this.boundsChanged = this._eventManager.getLazyEmitter('bounds_changed');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.center_changed\n     */\n\n    this.centerChanged = this._eventManager.getLazyEmitter('center_changed');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.click\n     */\n\n    this.mapClick = this._eventManager.getLazyEmitter('click');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.dblclick\n     */\n\n    this.mapDblclick = this._eventManager.getLazyEmitter('dblclick');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.drag\n     */\n\n    this.mapDrag = this._eventManager.getLazyEmitter('drag');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.dragend\n     */\n\n    this.mapDragend = this._eventManager.getLazyEmitter('dragend');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.dragstart\n     */\n\n    this.mapDragstart = this._eventManager.getLazyEmitter('dragstart');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.heading_changed\n     */\n\n    this.headingChanged = this._eventManager.getLazyEmitter('heading_changed');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.idle\n     */\n\n    this.idle = this._eventManager.getLazyEmitter('idle');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.maptypeid_changed\n     */\n\n    this.maptypeidChanged = this._eventManager.getLazyEmitter('maptypeid_changed');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.mousemove\n     */\n\n    this.mapMousemove = this._eventManager.getLazyEmitter('mousemove');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.mouseout\n     */\n\n    this.mapMouseout = this._eventManager.getLazyEmitter('mouseout');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.mouseover\n     */\n\n    this.mapMouseover = this._eventManager.getLazyEmitter('mouseover');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/map#Map.projection_changed\n     */\n\n    this.projectionChanged = this._eventManager.getLazyEmitter('projection_changed');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.rightclick\n     */\n\n    this.mapRightclick = this._eventManager.getLazyEmitter('rightclick');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.tilesloaded\n     */\n\n    this.tilesloaded = this._eventManager.getLazyEmitter('tilesloaded');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.tilt_changed\n     */\n\n    this.tiltChanged = this._eventManager.getLazyEmitter('tilt_changed');\n    /**\n     * See\n     * https://developers.google.com/maps/documentation/javascript/reference/map#Map.zoom_changed\n     */\n\n    this.zoomChanged = this._eventManager.getLazyEmitter('zoom_changed');\n    this._isBrowser = isPlatformBrowser(platformId);\n\n    if (this._isBrowser) {\n      const googleMapsWindow = window;\n\n      if (!googleMapsWindow.google && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Namespace google not found, cannot construct embedded google ' + 'map. Please install the Google Maps JavaScript API: ' + 'https://developers.google.com/maps/documentation/javascript/' + 'tutorial#Loading_the_Maps_API');\n      }\n\n      this._existingAuthFailureCallback = googleMapsWindow.gm_authFailure;\n\n      googleMapsWindow.gm_authFailure = () => {\n        if (this._existingAuthFailureCallback) {\n          this._existingAuthFailureCallback();\n        }\n\n        this.authFailure.emit();\n      };\n    }\n  }\n\n  set center(center) {\n    this._center = center;\n  }\n\n  set zoom(zoom) {\n    this._zoom = zoom;\n  }\n\n  set options(options) {\n    this._options = options || DEFAULT_OPTIONS;\n  }\n\n  ngOnChanges(changes) {\n    if (changes['height'] || changes['width']) {\n      this._setSize();\n    }\n\n    const googleMap = this.googleMap;\n\n    if (googleMap) {\n      if (changes['options']) {\n        googleMap.setOptions(this._combineOptions());\n      }\n\n      if (changes['center'] && this._center) {\n        googleMap.setCenter(this._center);\n      } // Note that the zoom can be zero.\n\n\n      if (changes['zoom'] && this._zoom != null) {\n        googleMap.setZoom(this._zoom);\n      }\n\n      if (changes['mapTypeId'] && this.mapTypeId) {\n        googleMap.setMapTypeId(this.mapTypeId);\n      }\n    }\n  }\n\n  ngOnInit() {\n    // It should be a noop during server-side rendering.\n    if (this._isBrowser) {\n      this._mapEl = this._elementRef.nativeElement.querySelector('.map-container');\n\n      this._setSize(); // Create the object outside the zone so its events don't trigger change detection.\n      // We'll bring it back in inside the `MapEventManager` only for the events that the\n      // user has subscribed to.\n\n\n      this._ngZone.runOutsideAngular(() => {\n        this.googleMap = new google.maps.Map(this._mapEl, this._combineOptions());\n      });\n\n      this._eventManager.setTarget(this.googleMap);\n\n      this.mapInitialized.emit(this.googleMap);\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    if (this._isBrowser) {\n      const googleMapsWindow = window;\n      googleMapsWindow.gm_authFailure = this._existingAuthFailureCallback;\n    }\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.fitBounds\n   */\n\n\n  fitBounds(bounds, padding) {\n    this._assertInitialized();\n\n    this.googleMap.fitBounds(bounds, padding);\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.panBy\n   */\n\n\n  panBy(x, y) {\n    this._assertInitialized();\n\n    this.googleMap.panBy(x, y);\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.panTo\n   */\n\n\n  panTo(latLng) {\n    this._assertInitialized();\n\n    this.googleMap.panTo(latLng);\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.panToBounds\n   */\n\n\n  panToBounds(latLngBounds, padding) {\n    this._assertInitialized();\n\n    this.googleMap.panToBounds(latLngBounds, padding);\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getBounds\n   */\n\n\n  getBounds() {\n    this._assertInitialized();\n\n    return this.googleMap.getBounds() || null;\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getCenter\n   */\n\n\n  getCenter() {\n    this._assertInitialized();\n\n    return this.googleMap.getCenter();\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getClickableIcons\n   */\n\n\n  getClickableIcons() {\n    this._assertInitialized();\n\n    return this.googleMap.getClickableIcons();\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getHeading\n   */\n\n\n  getHeading() {\n    this._assertInitialized();\n\n    return this.googleMap.getHeading();\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getMapTypeId\n   */\n\n\n  getMapTypeId() {\n    this._assertInitialized();\n\n    return this.googleMap.getMapTypeId();\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getProjection\n   */\n\n\n  getProjection() {\n    this._assertInitialized();\n\n    return this.googleMap.getProjection() || null;\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getStreetView\n   */\n\n\n  getStreetView() {\n    this._assertInitialized();\n\n    return this.googleMap.getStreetView();\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getTilt\n   */\n\n\n  getTilt() {\n    this._assertInitialized();\n\n    return this.googleMap.getTilt();\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.getZoom\n   */\n\n\n  getZoom() {\n    this._assertInitialized();\n\n    return this.googleMap.getZoom();\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.controls\n   */\n\n\n  get controls() {\n    this._assertInitialized();\n\n    return this.googleMap.controls;\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.data\n   */\n\n\n  get data() {\n    this._assertInitialized();\n\n    return this.googleMap.data;\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.mapTypes\n   */\n\n\n  get mapTypes() {\n    this._assertInitialized();\n\n    return this.googleMap.mapTypes;\n  }\n  /**\n   * See\n   * https://developers.google.com/maps/documentation/javascript/reference/map#Map.overlayMapTypes\n   */\n\n\n  get overlayMapTypes() {\n    this._assertInitialized();\n\n    return this.googleMap.overlayMapTypes;\n  }\n\n  _setSize() {\n    if (this._mapEl) {\n      const styles = this._mapEl.style;\n      styles.height = this.height === null ? '' : coerceCssPixelValue(this.height) || DEFAULT_HEIGHT;\n      styles.width = this.width === null ? '' : coerceCssPixelValue(this.width) || DEFAULT_WIDTH;\n    }\n  }\n  /** Combines the center and zoom and the other map options into a single object */\n\n\n  _combineOptions() {\n    const options = this._options || {};\n    return { ...options,\n      // It's important that we set **some** kind of `center` and `zoom`, otherwise\n      // Google Maps will render a blank rectangle which looks broken.\n      center: this._center || options.center || DEFAULT_OPTIONS.center,\n      zoom: this._zoom ?? options.zoom ?? DEFAULT_OPTIONS.zoom,\n      // Passing in an undefined `mapTypeId` seems to break tile loading\n      // so make sure that we have some kind of default (see #22082).\n      mapTypeId: this.mapTypeId || options.mapTypeId || DEFAULT_OPTIONS.mapTypeId\n    };\n  }\n  /** Asserts that the map has been initialized. */\n\n\n  _assertInitialized() {\n    if (!this.googleMap && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n    }\n  }\n\n}\n\nGoogleMap.ɵfac = function GoogleMap_Factory(t) {\n  return new (t || GoogleMap)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(PLATFORM_ID));\n};\n\nGoogleMap.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: GoogleMap,\n  selectors: [[\"google-map\"]],\n  inputs: {\n    height: \"height\",\n    width: \"width\",\n    mapTypeId: \"mapTypeId\",\n    center: \"center\",\n    zoom: \"zoom\",\n    options: \"options\"\n  },\n  outputs: {\n    mapInitialized: \"mapInitialized\",\n    authFailure: \"authFailure\",\n    boundsChanged: \"boundsChanged\",\n    centerChanged: \"centerChanged\",\n    mapClick: \"mapClick\",\n    mapDblclick: \"mapDblclick\",\n    mapDrag: \"mapDrag\",\n    mapDragend: \"mapDragend\",\n    mapDragstart: \"mapDragstart\",\n    headingChanged: \"headingChanged\",\n    idle: \"idle\",\n    maptypeidChanged: \"maptypeidChanged\",\n    mapMousemove: \"mapMousemove\",\n    mapMouseout: \"mapMouseout\",\n    mapMouseover: \"mapMouseover\",\n    projectionChanged: \"projectionChanged\",\n    mapRightclick: \"mapRightclick\",\n    tilesloaded: \"tilesloaded\",\n    tiltChanged: \"tiltChanged\",\n    zoomChanged: \"zoomChanged\"\n  },\n  exportAs: [\"googleMap\"],\n  features: [i0.ɵɵNgOnChangesFeature],\n  ngContentSelectors: _c0,\n  decls: 2,\n  vars: 0,\n  consts: [[1, \"map-container\"]],\n  template: function GoogleMap_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelement(0, \"div\", 0);\n      i0.ɵɵprojection(1);\n    }\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(GoogleMap, [{\n    type: Component,\n    args: [{\n      selector: 'google-map',\n      exportAs: 'googleMap',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<div class=\"map-container\"></div><ng-content></ng-content>',\n      encapsulation: ViewEncapsulation.None\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }, {\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, {\n    height: [{\n      type: Input\n    }],\n    width: [{\n      type: Input\n    }],\n    mapTypeId: [{\n      type: Input\n    }],\n    center: [{\n      type: Input\n    }],\n    zoom: [{\n      type: Input\n    }],\n    options: [{\n      type: Input\n    }],\n    mapInitialized: [{\n      type: Output\n    }],\n    authFailure: [{\n      type: Output\n    }],\n    boundsChanged: [{\n      type: Output\n    }],\n    centerChanged: [{\n      type: Output\n    }],\n    mapClick: [{\n      type: Output\n    }],\n    mapDblclick: [{\n      type: Output\n    }],\n    mapDrag: [{\n      type: Output\n    }],\n    mapDragend: [{\n      type: Output\n    }],\n    mapDragstart: [{\n      type: Output\n    }],\n    headingChanged: [{\n      type: Output\n    }],\n    idle: [{\n      type: Output\n    }],\n    maptypeidChanged: [{\n      type: Output\n    }],\n    mapMousemove: [{\n      type: Output\n    }],\n    mapMouseout: [{\n      type: Output\n    }],\n    mapMouseover: [{\n      type: Output\n    }],\n    projectionChanged: [{\n      type: Output\n    }],\n    mapRightclick: [{\n      type: Output\n    }],\n    tilesloaded: [{\n      type: Output\n    }],\n    tiltChanged: [{\n      type: Output\n    }],\n    zoomChanged: [{\n      type: Output\n    }]\n  });\n})();\n\nconst cssUnitsPattern = /([A-Za-z%]+)$/;\n/** Coerces a value to a CSS pixel value. */\n\nfunction coerceCssPixelValue(value) {\n  if (value == null) {\n    return '';\n  }\n\n  return cssUnitsPattern.test(value) ? value : `${value}px`;\n} /// <reference types=\"google.maps\" />\n\n\nclass MapBaseLayer {\n  constructor(_map, _ngZone) {\n    this._map = _map;\n    this._ngZone = _ngZone;\n  }\n\n  ngOnInit() {\n    if (this._map._isBrowser) {\n      this._ngZone.runOutsideAngular(() => {\n        this._initializeObject();\n      });\n\n      this._assertInitialized();\n\n      this._setMap();\n    }\n  }\n\n  ngOnDestroy() {\n    this._unsetMap();\n  }\n\n  _assertInitialized() {\n    if (!this._map.googleMap) {\n      throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n    }\n  }\n\n  _initializeObject() {}\n\n  _setMap() {}\n\n  _unsetMap() {}\n\n}\n\nMapBaseLayer.ɵfac = function MapBaseLayer_Factory(t) {\n  return new (t || MapBaseLayer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapBaseLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapBaseLayer,\n  selectors: [[\"map-base-layer\"]],\n  exportAs: [\"mapBaseLayer\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapBaseLayer, [{\n    type: Directive,\n    args: [{\n      selector: 'map-base-layer',\n      exportAs: 'mapBaseLayer'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, null);\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Bicycling Layer via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/map#BicyclingLayer\n */\n\n\nclass MapBicyclingLayer extends MapBaseLayer {\n  _initializeObject() {\n    this.bicyclingLayer = new google.maps.BicyclingLayer();\n  }\n\n  _setMap() {\n    this._assertLayerInitialized();\n\n    this.bicyclingLayer.setMap(this._map.googleMap);\n  }\n\n  _unsetMap() {\n    if (this.bicyclingLayer) {\n      this.bicyclingLayer.setMap(null);\n    }\n  }\n\n  _assertLayerInitialized() {\n    if (!this.bicyclingLayer) {\n      throw Error('Cannot interact with a Google Map Bicycling Layer before it has been initialized. ' + 'Please wait for the Transit Layer to load before trying to interact with it.');\n    }\n  }\n\n}\n\nMapBicyclingLayer.ɵfac = /* @__PURE__ */function () {\n  let ɵMapBicyclingLayer_BaseFactory;\n  return function MapBicyclingLayer_Factory(t) {\n    return (ɵMapBicyclingLayer_BaseFactory || (ɵMapBicyclingLayer_BaseFactory = i0.ɵɵgetInheritedFactory(MapBicyclingLayer)))(t || MapBicyclingLayer);\n  };\n}();\n\nMapBicyclingLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapBicyclingLayer,\n  selectors: [[\"map-bicycling-layer\"]],\n  exportAs: [\"mapBicyclingLayer\"],\n  features: [i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapBicyclingLayer, [{\n    type: Directive,\n    args: [{\n      selector: 'map-bicycling-layer',\n      exportAs: 'mapBicyclingLayer'\n    }]\n  }], null, null);\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Circle via the Google Maps JavaScript API.\n * @see developers.google.com/maps/documentation/javascript/reference/polygon#Circle\n */\n\n\nclass MapCircle {\n  constructor(_map, _ngZone) {\n    this._map = _map;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    this._options = new BehaviorSubject({});\n    this._center = new BehaviorSubject(undefined);\n    this._radius = new BehaviorSubject(undefined);\n    this._destroyed = new Subject();\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.center_changed\n     */\n\n    this.centerChanged = this._eventManager.getLazyEmitter('center_changed');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.click\n     */\n\n    this.circleClick = this._eventManager.getLazyEmitter('click');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.dblclick\n     */\n\n    this.circleDblclick = this._eventManager.getLazyEmitter('dblclick');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.drag\n     */\n\n    this.circleDrag = this._eventManager.getLazyEmitter('drag');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.dragend\n     */\n\n    this.circleDragend = this._eventManager.getLazyEmitter('dragend');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.dragstart\n     */\n\n    this.circleDragstart = this._eventManager.getLazyEmitter('dragstart');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mousedown\n     */\n\n    this.circleMousedown = this._eventManager.getLazyEmitter('mousedown');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mousemove\n     */\n\n    this.circleMousemove = this._eventManager.getLazyEmitter('mousemove');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mouseout\n     */\n\n    this.circleMouseout = this._eventManager.getLazyEmitter('mouseout');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mouseover\n     */\n\n    this.circleMouseover = this._eventManager.getLazyEmitter('mouseover');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.mouseup\n     */\n\n    this.circleMouseup = this._eventManager.getLazyEmitter('mouseup');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.radius_changed\n     */\n\n    this.radiusChanged = this._eventManager.getLazyEmitter('radius_changed');\n    /**\n     * @see\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.rightclick\n     */\n\n    this.circleRightclick = this._eventManager.getLazyEmitter('rightclick');\n  }\n\n  set options(options) {\n    this._options.next(options || {});\n  }\n\n  set center(center) {\n    this._center.next(center);\n  }\n\n  set radius(radius) {\n    this._radius.next(radius);\n  }\n\n  ngOnInit() {\n    if (this._map._isBrowser) {\n      this._combineOptions().pipe(take(1)).subscribe(options => {\n        // Create the object outside the zone so its events don't trigger change detection.\n        // We'll bring it back in inside the `MapEventManager` only for the events that the\n        // user has subscribed to.\n        this._ngZone.runOutsideAngular(() => {\n          this.circle = new google.maps.Circle(options);\n        });\n\n        this._assertInitialized();\n\n        this.circle.setMap(this._map.googleMap);\n\n        this._eventManager.setTarget(this.circle);\n      });\n\n      this._watchForOptionsChanges();\n\n      this._watchForCenterChanges();\n\n      this._watchForRadiusChanges();\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    this._destroyed.next();\n\n    this._destroyed.complete();\n\n    if (this.circle) {\n      this.circle.setMap(null);\n    }\n  }\n  /**\n   * @see\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getBounds\n   */\n\n\n  getBounds() {\n    this._assertInitialized();\n\n    return this.circle.getBounds();\n  }\n  /**\n   * @see\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getCenter\n   */\n\n\n  getCenter() {\n    this._assertInitialized();\n\n    return this.circle.getCenter();\n  }\n  /**\n   * @see\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getDraggable\n   */\n\n\n  getDraggable() {\n    this._assertInitialized();\n\n    return this.circle.getDraggable();\n  }\n  /**\n   * @see\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getEditable\n   */\n\n\n  getEditable() {\n    this._assertInitialized();\n\n    return this.circle.getEditable();\n  }\n  /**\n   * @see\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getRadius\n   */\n\n\n  getRadius() {\n    this._assertInitialized();\n\n    return this.circle.getRadius();\n  }\n  /**\n   * @see\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Circle.getVisible\n   */\n\n\n  getVisible() {\n    this._assertInitialized();\n\n    return this.circle.getVisible();\n  }\n\n  _combineOptions() {\n    return combineLatest([this._options, this._center, this._radius]).pipe(map(([options, center, radius]) => {\n      const combinedOptions = { ...options,\n        center: center || options.center,\n        radius: radius !== undefined ? radius : options.radius\n      };\n      return combinedOptions;\n    }));\n  }\n\n  _watchForOptionsChanges() {\n    this._options.pipe(takeUntil(this._destroyed)).subscribe(options => {\n      this._assertInitialized();\n\n      this.circle.setOptions(options);\n    });\n  }\n\n  _watchForCenterChanges() {\n    this._center.pipe(takeUntil(this._destroyed)).subscribe(center => {\n      if (center) {\n        this._assertInitialized();\n\n        this.circle.setCenter(center);\n      }\n    });\n  }\n\n  _watchForRadiusChanges() {\n    this._radius.pipe(takeUntil(this._destroyed)).subscribe(radius => {\n      if (radius !== undefined) {\n        this._assertInitialized();\n\n        this.circle.setRadius(radius);\n      }\n    });\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._map.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.circle) {\n        throw Error('Cannot interact with a Google Map Circle before it has been ' + 'initialized. Please wait for the Circle to load before trying to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapCircle.ɵfac = function MapCircle_Factory(t) {\n  return new (t || MapCircle)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapCircle.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapCircle,\n  selectors: [[\"map-circle\"]],\n  inputs: {\n    options: \"options\",\n    center: \"center\",\n    radius: \"radius\"\n  },\n  outputs: {\n    centerChanged: \"centerChanged\",\n    circleClick: \"circleClick\",\n    circleDblclick: \"circleDblclick\",\n    circleDrag: \"circleDrag\",\n    circleDragend: \"circleDragend\",\n    circleDragstart: \"circleDragstart\",\n    circleMousedown: \"circleMousedown\",\n    circleMousemove: \"circleMousemove\",\n    circleMouseout: \"circleMouseout\",\n    circleMouseover: \"circleMouseover\",\n    circleMouseup: \"circleMouseup\",\n    radiusChanged: \"radiusChanged\",\n    circleRightclick: \"circleRightclick\"\n  },\n  exportAs: [\"mapCircle\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapCircle, [{\n    type: Directive,\n    args: [{\n      selector: 'map-circle',\n      exportAs: 'mapCircle'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    options: [{\n      type: Input\n    }],\n    center: [{\n      type: Input\n    }],\n    radius: [{\n      type: Input\n    }],\n    centerChanged: [{\n      type: Output\n    }],\n    circleClick: [{\n      type: Output\n    }],\n    circleDblclick: [{\n      type: Output\n    }],\n    circleDrag: [{\n      type: Output\n    }],\n    circleDragend: [{\n      type: Output\n    }],\n    circleDragstart: [{\n      type: Output\n    }],\n    circleMousedown: [{\n      type: Output\n    }],\n    circleMousemove: [{\n      type: Output\n    }],\n    circleMouseout: [{\n      type: Output\n    }],\n    circleMouseover: [{\n      type: Output\n    }],\n    circleMouseup: [{\n      type: Output\n    }],\n    radiusChanged: [{\n      type: Output\n    }],\n    circleRightclick: [{\n      type: Output\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Directions Renderer via the Google Maps\n * JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/directions#DirectionsRenderer\n */\n\n\nclass MapDirectionsRenderer {\n  constructor(_googleMap, _ngZone) {\n    this._googleMap = _googleMap;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/directions\n     * #DirectionsRenderer.directions_changed\n     */\n\n    this.directionsChanged = this._eventManager.getLazyEmitter('directions_changed');\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/directions\n   * #DirectionsRendererOptions.directions\n   */\n\n\n  set directions(directions) {\n    this._directions = directions;\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/directions\n   * #DirectionsRendererOptions\n   */\n\n\n  set options(options) {\n    this._options = options;\n  }\n\n  ngOnInit() {\n    if (this._googleMap._isBrowser) {\n      // Create the object outside the zone so its events don't trigger change detection.\n      // We'll bring it back in inside the `MapEventManager` only for the events that the\n      // user has subscribed to.\n      this._ngZone.runOutsideAngular(() => {\n        this.directionsRenderer = new google.maps.DirectionsRenderer(this._combineOptions());\n      });\n\n      this._assertInitialized();\n\n      this.directionsRenderer.setMap(this._googleMap.googleMap);\n\n      this._eventManager.setTarget(this.directionsRenderer);\n    }\n  }\n\n  ngOnChanges(changes) {\n    if (this.directionsRenderer) {\n      if (changes['options']) {\n        this.directionsRenderer.setOptions(this._combineOptions());\n      }\n\n      if (changes['directions'] && this._directions !== undefined) {\n        this.directionsRenderer.setDirections(this._directions);\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    if (this.directionsRenderer) {\n      this.directionsRenderer.setMap(null);\n    }\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/directions\n   * #DirectionsRenderer.getDirections\n   */\n\n\n  getDirections() {\n    this._assertInitialized();\n\n    return this.directionsRenderer.getDirections();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/directions\n   * #DirectionsRenderer.getPanel\n   */\n\n\n  getPanel() {\n    this._assertInitialized();\n\n    return this.directionsRenderer.getPanel();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/directions\n   * #DirectionsRenderer.getRouteIndex\n   */\n\n\n  getRouteIndex() {\n    this._assertInitialized();\n\n    return this.directionsRenderer.getRouteIndex();\n  }\n\n  _combineOptions() {\n    const options = this._options || {};\n    return { ...options,\n      directions: this._directions || options.directions,\n      map: this._googleMap.googleMap\n    };\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._googleMap.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.directionsRenderer) {\n        throw Error('Cannot interact with a Google Map Directions Renderer before it has been ' + 'initialized. Please wait for the Directions Renderer to load before trying ' + 'to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapDirectionsRenderer.ɵfac = function MapDirectionsRenderer_Factory(t) {\n  return new (t || MapDirectionsRenderer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapDirectionsRenderer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapDirectionsRenderer,\n  selectors: [[\"map-directions-renderer\"]],\n  inputs: {\n    directions: \"directions\",\n    options: \"options\"\n  },\n  outputs: {\n    directionsChanged: \"directionsChanged\"\n  },\n  exportAs: [\"mapDirectionsRenderer\"],\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapDirectionsRenderer, [{\n    type: Directive,\n    args: [{\n      selector: 'map-directions-renderer',\n      exportAs: 'mapDirectionsRenderer'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    directions: [{\n      type: Input\n    }],\n    options: [{\n      type: Input\n    }],\n    directionsChanged: [{\n      type: Output\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Ground Overlay via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/image-overlay#GroundOverlay\n */\n\n\nclass MapGroundOverlay {\n  constructor(_map, _ngZone) {\n    this._map = _map;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    this._opacity = new BehaviorSubject(1);\n    this._url = new BehaviorSubject('');\n    this._bounds = new BehaviorSubject(undefined);\n    this._destroyed = new Subject();\n    /** Whether the overlay is clickable */\n\n    this.clickable = false;\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/image-overlay#GroundOverlay.click\n     */\n\n    this.mapClick = this._eventManager.getLazyEmitter('click');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/image-overlay\n     * #GroundOverlay.dblclick\n     */\n\n    this.mapDblclick = this._eventManager.getLazyEmitter('dblclick');\n  }\n  /** URL of the image that will be shown in the overlay. */\n\n\n  set url(url) {\n    this._url.next(url);\n  }\n  /** Bounds for the overlay. */\n\n\n  get bounds() {\n    return this._bounds.value;\n  }\n\n  set bounds(bounds) {\n    this._bounds.next(bounds);\n  }\n  /** Opacity of the overlay. */\n\n\n  set opacity(opacity) {\n    this._opacity.next(opacity);\n  }\n\n  ngOnInit() {\n    if (this._map._isBrowser) {\n      // The ground overlay setup is slightly different from the other Google Maps objects in that\n      // we have to recreate the `GroundOverlay` object whenever the bounds change, because\n      // Google Maps doesn't provide an API to update the bounds of an existing overlay.\n      this._bounds.pipe(takeUntil(this._destroyed)).subscribe(bounds => {\n        if (this.groundOverlay) {\n          this.groundOverlay.setMap(null);\n          this.groundOverlay = undefined;\n        } // Create the object outside the zone so its events don't trigger change detection.\n        // We'll bring it back in inside the `MapEventManager` only for the events that the\n        // user has subscribed to.\n\n\n        if (bounds) {\n          this._ngZone.runOutsideAngular(() => {\n            this.groundOverlay = new google.maps.GroundOverlay(this._url.getValue(), bounds, {\n              clickable: this.clickable,\n              opacity: this._opacity.value\n            });\n          });\n\n          this._assertInitialized();\n\n          this.groundOverlay.setMap(this._map.googleMap);\n\n          this._eventManager.setTarget(this.groundOverlay);\n        }\n      });\n\n      this._watchForOpacityChanges();\n\n      this._watchForUrlChanges();\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    this._destroyed.next();\n\n    this._destroyed.complete();\n\n    if (this.groundOverlay) {\n      this.groundOverlay.setMap(null);\n    }\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/image-overlay\n   * #GroundOverlay.getBounds\n   */\n\n\n  getBounds() {\n    this._assertInitialized();\n\n    return this.groundOverlay.getBounds();\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/image-overlay\n   * #GroundOverlay.getOpacity\n   */\n\n\n  getOpacity() {\n    this._assertInitialized();\n\n    return this.groundOverlay.getOpacity();\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/image-overlay\n   * #GroundOverlay.getUrl\n   */\n\n\n  getUrl() {\n    this._assertInitialized();\n\n    return this.groundOverlay.getUrl();\n  }\n\n  _watchForOpacityChanges() {\n    this._opacity.pipe(takeUntil(this._destroyed)).subscribe(opacity => {\n      if (opacity != null) {\n        this._assertInitialized();\n\n        this.groundOverlay.setOpacity(opacity);\n      }\n    });\n  }\n\n  _watchForUrlChanges() {\n    this._url.pipe(takeUntil(this._destroyed)).subscribe(url => {\n      this._assertInitialized();\n\n      const overlay = this.groundOverlay;\n      overlay.set('url', url); // Google Maps only redraws the overlay if we re-set the map.\n\n      overlay.setMap(null);\n      overlay.setMap(this._map.googleMap);\n    });\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._map.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.groundOverlay) {\n        throw Error('Cannot interact with a Google Map GroundOverlay before it has been initialized. ' + 'Please wait for the GroundOverlay to load before trying to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapGroundOverlay.ɵfac = function MapGroundOverlay_Factory(t) {\n  return new (t || MapGroundOverlay)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapGroundOverlay.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapGroundOverlay,\n  selectors: [[\"map-ground-overlay\"]],\n  inputs: {\n    url: \"url\",\n    bounds: \"bounds\",\n    clickable: \"clickable\",\n    opacity: \"opacity\"\n  },\n  outputs: {\n    mapClick: \"mapClick\",\n    mapDblclick: \"mapDblclick\"\n  },\n  exportAs: [\"mapGroundOverlay\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapGroundOverlay, [{\n    type: Directive,\n    args: [{\n      selector: 'map-ground-overlay',\n      exportAs: 'mapGroundOverlay'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    url: [{\n      type: Input\n    }],\n    bounds: [{\n      type: Input\n    }],\n    clickable: [{\n      type: Input\n    }],\n    opacity: [{\n      type: Input\n    }],\n    mapClick: [{\n      type: Output\n    }],\n    mapDblclick: [{\n      type: Output\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps info window via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/info-window\n */\n\n\nclass MapInfoWindow {\n  constructor(_googleMap, _elementRef, _ngZone) {\n    this._googleMap = _googleMap;\n    this._elementRef = _elementRef;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    this._options = new BehaviorSubject({});\n    this._position = new BehaviorSubject(undefined);\n    this._destroy = new Subject();\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.closeclick\n     */\n\n    this.closeclick = this._eventManager.getLazyEmitter('closeclick');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/info-window\n     * #InfoWindow.content_changed\n     */\n\n    this.contentChanged = this._eventManager.getLazyEmitter('content_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.domready\n     */\n\n    this.domready = this._eventManager.getLazyEmitter('domready');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/info-window\n     * #InfoWindow.position_changed\n     */\n\n    this.positionChanged = this._eventManager.getLazyEmitter('position_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/info-window\n     * #InfoWindow.zindex_changed\n     */\n\n    this.zindexChanged = this._eventManager.getLazyEmitter('zindex_changed');\n  }\n\n  set options(options) {\n    this._options.next(options || {});\n  }\n\n  set position(position) {\n    this._position.next(position);\n  }\n\n  ngOnInit() {\n    if (this._googleMap._isBrowser) {\n      const combinedOptionsChanges = this._combineOptions();\n\n      combinedOptionsChanges.pipe(take(1)).subscribe(options => {\n        // Create the object outside the zone so its events don't trigger change detection.\n        // We'll bring it back in inside the `MapEventManager` only for the events that the\n        // user has subscribed to.\n        this._ngZone.runOutsideAngular(() => {\n          this.infoWindow = new google.maps.InfoWindow(options);\n        });\n\n        this._eventManager.setTarget(this.infoWindow);\n      });\n\n      this._watchForOptionsChanges();\n\n      this._watchForPositionChanges();\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    this._destroy.next();\n\n    this._destroy.complete(); // If no info window has been created on the server, we do not try closing it.\n    // On the server, an info window cannot be created and this would cause errors.\n\n\n    if (this.infoWindow) {\n      this.close();\n    }\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.close\n   */\n\n\n  close() {\n    this._assertInitialized();\n\n    this.infoWindow.close();\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.getContent\n   */\n\n\n  getContent() {\n    this._assertInitialized();\n\n    return this.infoWindow.getContent() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/info-window\n   * #InfoWindow.getPosition\n   */\n\n\n  getPosition() {\n    this._assertInitialized();\n\n    return this.infoWindow.getPosition() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/info-window#InfoWindow.getZIndex\n   */\n\n\n  getZIndex() {\n    this._assertInitialized();\n\n    return this.infoWindow.getZIndex();\n  }\n  /**\n   * Opens the MapInfoWindow using the provided anchor. If the anchor is not set,\n   * then the position property of the options input is used instead.\n   */\n\n\n  open(anchor, shouldFocus) {\n    this._assertInitialized();\n\n    const anchorObject = anchor ? anchor.getAnchor() : undefined; // Prevent the info window from initializing when trying to reopen on the same anchor.\n    // Note that when the window is opened for the first time, the anchor will always be\n    // undefined. If that's the case, we have to allow it to open in order to handle the\n    // case where the window doesn't have an anchor, but is placed at a particular position.\n\n    if (this.infoWindow.get('anchor') !== anchorObject || !anchorObject) {\n      this._elementRef.nativeElement.style.display = ''; // The config is cast to `any`, because the internal typings are out of date.\n\n      this.infoWindow.open({\n        map: this._googleMap.googleMap,\n        anchor: anchorObject,\n        shouldFocus\n      });\n    }\n  }\n\n  _combineOptions() {\n    return combineLatest([this._options, this._position]).pipe(map(([options, position]) => {\n      const combinedOptions = { ...options,\n        position: position || options.position,\n        content: this._elementRef.nativeElement\n      };\n      return combinedOptions;\n    }));\n  }\n\n  _watchForOptionsChanges() {\n    this._options.pipe(takeUntil(this._destroy)).subscribe(options => {\n      this._assertInitialized();\n\n      this.infoWindow.setOptions(options);\n    });\n  }\n\n  _watchForPositionChanges() {\n    this._position.pipe(takeUntil(this._destroy)).subscribe(position => {\n      if (position) {\n        this._assertInitialized();\n\n        this.infoWindow.setPosition(position);\n      }\n    });\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._googleMap.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.infoWindow) {\n        throw Error('Cannot interact with a Google Map Info Window before it has been ' + 'initialized. Please wait for the Info Window to load before trying to interact with ' + 'it.');\n      }\n    }\n  }\n\n}\n\nMapInfoWindow.ɵfac = function MapInfoWindow_Factory(t) {\n  return new (t || MapInfoWindow)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapInfoWindow.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapInfoWindow,\n  selectors: [[\"map-info-window\"]],\n  hostAttrs: [2, \"display\", \"none\"],\n  inputs: {\n    options: \"options\",\n    position: \"position\"\n  },\n  outputs: {\n    closeclick: \"closeclick\",\n    contentChanged: \"contentChanged\",\n    domready: \"domready\",\n    positionChanged: \"positionChanged\",\n    zindexChanged: \"zindexChanged\"\n  },\n  exportAs: [\"mapInfoWindow\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapInfoWindow, [{\n    type: Directive,\n    args: [{\n      selector: 'map-info-window',\n      exportAs: 'mapInfoWindow',\n      host: {\n        'style': 'display: none'\n      }\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    options: [{\n      type: Input\n    }],\n    position: [{\n      type: Input\n    }],\n    closeclick: [{\n      type: Output\n    }],\n    contentChanged: [{\n      type: Output\n    }],\n    domready: [{\n      type: Output\n    }],\n    positionChanged: [{\n      type: Output\n    }],\n    zindexChanged: [{\n      type: Output\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps KML Layer via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer\n */\n\n\nclass MapKmlLayer {\n  constructor(_map, _ngZone) {\n    this._map = _map;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    this._options = new BehaviorSubject({});\n    this._url = new BehaviorSubject('');\n    this._destroyed = new Subject();\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.click\n     */\n\n    this.kmlClick = this._eventManager.getLazyEmitter('click');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/kml\n     * #KmlLayer.defaultviewport_changed\n     */\n\n    this.defaultviewportChanged = this._eventManager.getLazyEmitter('defaultviewport_changed');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.status_changed\n     */\n\n    this.statusChanged = this._eventManager.getLazyEmitter('status_changed');\n  }\n\n  set options(options) {\n    this._options.next(options || {});\n  }\n\n  set url(url) {\n    this._url.next(url);\n  }\n\n  ngOnInit() {\n    if (this._map._isBrowser) {\n      this._combineOptions().pipe(take(1)).subscribe(options => {\n        // Create the object outside the zone so its events don't trigger change detection.\n        // We'll bring it back in inside the `MapEventManager` only for the events that the\n        // user has subscribed to.\n        this._ngZone.runOutsideAngular(() => this.kmlLayer = new google.maps.KmlLayer(options));\n\n        this._assertInitialized();\n\n        this.kmlLayer.setMap(this._map.googleMap);\n\n        this._eventManager.setTarget(this.kmlLayer);\n      });\n\n      this._watchForOptionsChanges();\n\n      this._watchForUrlChanges();\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    this._destroyed.next();\n\n    this._destroyed.complete();\n\n    if (this.kmlLayer) {\n      this.kmlLayer.setMap(null);\n    }\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getDefaultViewport\n   */\n\n\n  getDefaultViewport() {\n    this._assertInitialized();\n\n    return this.kmlLayer.getDefaultViewport();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getMetadata\n   */\n\n\n  getMetadata() {\n    this._assertInitialized();\n\n    return this.kmlLayer.getMetadata();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getStatus\n   */\n\n\n  getStatus() {\n    this._assertInitialized();\n\n    return this.kmlLayer.getStatus();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getUrl\n   */\n\n\n  getUrl() {\n    this._assertInitialized();\n\n    return this.kmlLayer.getUrl();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/kml#KmlLayer.getZIndex\n   */\n\n\n  getZIndex() {\n    this._assertInitialized();\n\n    return this.kmlLayer.getZIndex();\n  }\n\n  _combineOptions() {\n    return combineLatest([this._options, this._url]).pipe(map(([options, url]) => {\n      const combinedOptions = { ...options,\n        url: url || options.url\n      };\n      return combinedOptions;\n    }));\n  }\n\n  _watchForOptionsChanges() {\n    this._options.pipe(takeUntil(this._destroyed)).subscribe(options => {\n      if (this.kmlLayer) {\n        this._assertInitialized();\n\n        this.kmlLayer.setOptions(options);\n      }\n    });\n  }\n\n  _watchForUrlChanges() {\n    this._url.pipe(takeUntil(this._destroyed)).subscribe(url => {\n      if (url && this.kmlLayer) {\n        this._assertInitialized();\n\n        this.kmlLayer.setUrl(url);\n      }\n    });\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._map.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.kmlLayer) {\n        throw Error('Cannot interact with a Google Map KmlLayer before it has been ' + 'initialized. Please wait for the KmlLayer to load before trying to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapKmlLayer.ɵfac = function MapKmlLayer_Factory(t) {\n  return new (t || MapKmlLayer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapKmlLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapKmlLayer,\n  selectors: [[\"map-kml-layer\"]],\n  inputs: {\n    options: \"options\",\n    url: \"url\"\n  },\n  outputs: {\n    kmlClick: \"kmlClick\",\n    defaultviewportChanged: \"defaultviewportChanged\",\n    statusChanged: \"statusChanged\"\n  },\n  exportAs: [\"mapKmlLayer\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapKmlLayer, [{\n    type: Directive,\n    args: [{\n      selector: 'map-kml-layer',\n      exportAs: 'mapKmlLayer'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    options: [{\n      type: Input\n    }],\n    url: [{\n      type: Input\n    }],\n    kmlClick: [{\n      type: Output\n    }],\n    defaultviewportChanged: [{\n      type: Output\n    }],\n    statusChanged: [{\n      type: Output\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Default options for the Google Maps marker component. Displays a marker\n * at the Googleplex.\n */\n\n\nconst DEFAULT_MARKER_OPTIONS = {\n  position: {\n    lat: 37.421995,\n    lng: -122.084092\n  }\n};\n/**\n * Angular component that renders a Google Maps marker via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/marker\n */\n\nclass MapMarker {\n  constructor(_googleMap, _ngZone) {\n    this._googleMap = _googleMap;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.animation_changed\n     */\n\n    this.animationChanged = this._eventManager.getLazyEmitter('animation_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.click\n     */\n\n    this.mapClick = this._eventManager.getLazyEmitter('click');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.clickable_changed\n     */\n\n    this.clickableChanged = this._eventManager.getLazyEmitter('clickable_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.cursor_changed\n     */\n\n    this.cursorChanged = this._eventManager.getLazyEmitter('cursor_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.dblclick\n     */\n\n    this.mapDblclick = this._eventManager.getLazyEmitter('dblclick');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.drag\n     */\n\n    this.mapDrag = this._eventManager.getLazyEmitter('drag');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.dragend\n     */\n\n    this.mapDragend = this._eventManager.getLazyEmitter('dragend');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.draggable_changed\n     */\n\n    this.draggableChanged = this._eventManager.getLazyEmitter('draggable_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.dragstart\n     */\n\n    this.mapDragstart = this._eventManager.getLazyEmitter('dragstart');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.flat_changed\n     */\n\n    this.flatChanged = this._eventManager.getLazyEmitter('flat_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.icon_changed\n     */\n\n    this.iconChanged = this._eventManager.getLazyEmitter('icon_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.mousedown\n     */\n\n    this.mapMousedown = this._eventManager.getLazyEmitter('mousedown');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.mouseout\n     */\n\n    this.mapMouseout = this._eventManager.getLazyEmitter('mouseout');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.mouseover\n     */\n\n    this.mapMouseover = this._eventManager.getLazyEmitter('mouseover');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.mouseup\n     */\n\n    this.mapMouseup = this._eventManager.getLazyEmitter('mouseup');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.position_changed\n     */\n\n    this.positionChanged = this._eventManager.getLazyEmitter('position_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.rightclick\n     */\n\n    this.mapRightclick = this._eventManager.getLazyEmitter('rightclick');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.shape_changed\n     */\n\n    this.shapeChanged = this._eventManager.getLazyEmitter('shape_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.title_changed\n     */\n\n    this.titleChanged = this._eventManager.getLazyEmitter('title_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.visible_changed\n     */\n\n    this.visibleChanged = this._eventManager.getLazyEmitter('visible_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/marker#Marker.zindex_changed\n     */\n\n    this.zindexChanged = this._eventManager.getLazyEmitter('zindex_changed');\n  }\n  /**\n   * Title of the marker.\n   * See: developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.title\n   */\n\n\n  set title(title) {\n    this._title = title;\n  }\n  /**\n   * Position of the marker. See:\n   * developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.position\n   */\n\n\n  set position(position) {\n    this._position = position;\n  }\n  /**\n   * Label for the marker.\n   * See: developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.label\n   */\n\n\n  set label(label) {\n    this._label = label;\n  }\n  /**\n   * Whether the marker is clickable. See:\n   * developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.clickable\n   */\n\n\n  set clickable(clickable) {\n    this._clickable = clickable;\n  }\n  /**\n   * Options used to configure the marker.\n   * See: developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions\n   */\n\n\n  set options(options) {\n    this._options = options;\n  }\n  /**\n   * Icon to be used for the marker.\n   * See: https://developers.google.com/maps/documentation/javascript/reference/marker#Icon\n   */\n\n\n  set icon(icon) {\n    this._icon = icon;\n  }\n  /**\n   * Whether the marker is visible.\n   * See: developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions.visible\n   */\n\n\n  set visible(value) {\n    this._visible = value;\n  }\n\n  ngOnInit() {\n    if (this._googleMap._isBrowser) {\n      // Create the object outside the zone so its events don't trigger change detection.\n      // We'll bring it back in inside the `MapEventManager` only for the events that the\n      // user has subscribed to.\n      this._ngZone.runOutsideAngular(() => {\n        this.marker = new google.maps.Marker(this._combineOptions());\n      });\n\n      this._assertInitialized();\n\n      this.marker.setMap(this._googleMap.googleMap);\n\n      this._eventManager.setTarget(this.marker);\n    }\n  }\n\n  ngOnChanges(changes) {\n    const {\n      marker,\n      _title,\n      _position,\n      _label,\n      _clickable,\n      _icon,\n      _visible\n    } = this;\n\n    if (marker) {\n      if (changes['options']) {\n        marker.setOptions(this._combineOptions());\n      }\n\n      if (changes['title'] && _title !== undefined) {\n        marker.setTitle(_title);\n      }\n\n      if (changes['position'] && _position) {\n        marker.setPosition(_position);\n      }\n\n      if (changes['label'] && _label !== undefined) {\n        marker.setLabel(_label);\n      }\n\n      if (changes['clickable'] && _clickable !== undefined) {\n        marker.setClickable(_clickable);\n      }\n\n      if (changes['icon'] && _icon) {\n        marker.setIcon(_icon);\n      }\n\n      if (changes['visible'] && _visible !== undefined) {\n        marker.setVisible(_visible);\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    if (this.marker) {\n      this.marker.setMap(null);\n    }\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getAnimation\n   */\n\n\n  getAnimation() {\n    this._assertInitialized();\n\n    return this.marker.getAnimation() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getClickable\n   */\n\n\n  getClickable() {\n    this._assertInitialized();\n\n    return this.marker.getClickable();\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getCursor\n   */\n\n\n  getCursor() {\n    this._assertInitialized();\n\n    return this.marker.getCursor() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getDraggable\n   */\n\n\n  getDraggable() {\n    this._assertInitialized();\n\n    return !!this.marker.getDraggable();\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getIcon\n   */\n\n\n  getIcon() {\n    this._assertInitialized();\n\n    return this.marker.getIcon() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getLabel\n   */\n\n\n  getLabel() {\n    this._assertInitialized();\n\n    return this.marker.getLabel() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getOpacity\n   */\n\n\n  getOpacity() {\n    this._assertInitialized();\n\n    return this.marker.getOpacity() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getPosition\n   */\n\n\n  getPosition() {\n    this._assertInitialized();\n\n    return this.marker.getPosition() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getShape\n   */\n\n\n  getShape() {\n    this._assertInitialized();\n\n    return this.marker.getShape() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getTitle\n   */\n\n\n  getTitle() {\n    this._assertInitialized();\n\n    return this.marker.getTitle() || null;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getVisible\n   */\n\n\n  getVisible() {\n    this._assertInitialized();\n\n    return this.marker.getVisible();\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/marker#Marker.getZIndex\n   */\n\n\n  getZIndex() {\n    this._assertInitialized();\n\n    return this.marker.getZIndex() || null;\n  }\n  /** Gets the anchor point that can be used to attach other Google Maps objects. */\n\n\n  getAnchor() {\n    this._assertInitialized();\n\n    return this.marker;\n  }\n  /** Creates a combined options object using the passed-in options and the individual inputs. */\n\n\n  _combineOptions() {\n    const options = this._options || DEFAULT_MARKER_OPTIONS;\n    return { ...options,\n      title: this._title || options.title,\n      position: this._position || options.position,\n      label: this._label || options.label,\n      clickable: this._clickable ?? options.clickable,\n      map: this._googleMap.googleMap,\n      icon: this._icon || options.icon,\n      visible: this._visible ?? options.visible\n    };\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._googleMap.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.marker) {\n        throw Error('Cannot interact with a Google Map Marker before it has been ' + 'initialized. Please wait for the Marker to load before trying to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapMarker.ɵfac = function MapMarker_Factory(t) {\n  return new (t || MapMarker)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapMarker.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapMarker,\n  selectors: [[\"map-marker\"]],\n  inputs: {\n    title: \"title\",\n    position: \"position\",\n    label: \"label\",\n    clickable: \"clickable\",\n    options: \"options\",\n    icon: \"icon\",\n    visible: \"visible\"\n  },\n  outputs: {\n    animationChanged: \"animationChanged\",\n    mapClick: \"mapClick\",\n    clickableChanged: \"clickableChanged\",\n    cursorChanged: \"cursorChanged\",\n    mapDblclick: \"mapDblclick\",\n    mapDrag: \"mapDrag\",\n    mapDragend: \"mapDragend\",\n    draggableChanged: \"draggableChanged\",\n    mapDragstart: \"mapDragstart\",\n    flatChanged: \"flatChanged\",\n    iconChanged: \"iconChanged\",\n    mapMousedown: \"mapMousedown\",\n    mapMouseout: \"mapMouseout\",\n    mapMouseover: \"mapMouseover\",\n    mapMouseup: \"mapMouseup\",\n    positionChanged: \"positionChanged\",\n    mapRightclick: \"mapRightclick\",\n    shapeChanged: \"shapeChanged\",\n    titleChanged: \"titleChanged\",\n    visibleChanged: \"visibleChanged\",\n    zindexChanged: \"zindexChanged\"\n  },\n  exportAs: [\"mapMarker\"],\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapMarker, [{\n    type: Directive,\n    args: [{\n      selector: 'map-marker',\n      exportAs: 'mapMarker'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    title: [{\n      type: Input\n    }],\n    position: [{\n      type: Input\n    }],\n    label: [{\n      type: Input\n    }],\n    clickable: [{\n      type: Input\n    }],\n    options: [{\n      type: Input\n    }],\n    icon: [{\n      type: Input\n    }],\n    visible: [{\n      type: Input\n    }],\n    animationChanged: [{\n      type: Output\n    }],\n    mapClick: [{\n      type: Output\n    }],\n    clickableChanged: [{\n      type: Output\n    }],\n    cursorChanged: [{\n      type: Output\n    }],\n    mapDblclick: [{\n      type: Output\n    }],\n    mapDrag: [{\n      type: Output\n    }],\n    mapDragend: [{\n      type: Output\n    }],\n    draggableChanged: [{\n      type: Output\n    }],\n    mapDragstart: [{\n      type: Output\n    }],\n    flatChanged: [{\n      type: Output\n    }],\n    iconChanged: [{\n      type: Output\n    }],\n    mapMousedown: [{\n      type: Output\n    }],\n    mapMouseout: [{\n      type: Output\n    }],\n    mapMouseover: [{\n      type: Output\n    }],\n    mapMouseup: [{\n      type: Output\n    }],\n    positionChanged: [{\n      type: Output\n    }],\n    mapRightclick: [{\n      type: Output\n    }],\n    shapeChanged: [{\n      type: Output\n    }],\n    titleChanged: [{\n      type: Output\n    }],\n    visibleChanged: [{\n      type: Output\n    }],\n    zindexChanged: [{\n      type: Output\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/** Default options for a clusterer. */\n\n\nconst DEFAULT_CLUSTERER_OPTIONS = {};\n/**\n * Angular component for implementing a Google Maps Marker Clusterer.\n *\n * See https://developers.google.com/maps/documentation/javascript/marker-clustering\n */\n\nclass MapMarkerClusterer {\n  constructor(_googleMap, _ngZone) {\n    this._googleMap = _googleMap;\n    this._ngZone = _ngZone;\n    this._currentMarkers = new Set();\n    this._eventManager = new MapEventManager(this._ngZone);\n    this._destroy = new Subject();\n\n    this.ariaLabelFn = () => '';\n    /**\n     * See\n     * googlemaps.github.io/v3-utility-library/modules/\n     * _google_markerclustererplus.html#clusteringbegin\n     */\n\n\n    this.clusteringbegin = this._eventManager.getLazyEmitter('clusteringbegin');\n    /**\n     * See\n     * googlemaps.github.io/v3-utility-library/modules/_google_markerclustererplus.html#clusteringend\n     */\n\n    this.clusteringend = this._eventManager.getLazyEmitter('clusteringend');\n    /** Emits when a cluster has been clicked. */\n\n    this.clusterClick = this._eventManager.getLazyEmitter('click');\n    this._canInitialize = this._googleMap._isBrowser;\n  }\n\n  set averageCenter(averageCenter) {\n    this._averageCenter = averageCenter;\n  }\n\n  set batchSizeIE(batchSizeIE) {\n    this._batchSizeIE = batchSizeIE;\n  }\n\n  set calculator(calculator) {\n    this._calculator = calculator;\n  }\n\n  set clusterClass(clusterClass) {\n    this._clusterClass = clusterClass;\n  }\n\n  set enableRetinaIcons(enableRetinaIcons) {\n    this._enableRetinaIcons = enableRetinaIcons;\n  }\n\n  set gridSize(gridSize) {\n    this._gridSize = gridSize;\n  }\n\n  set ignoreHidden(ignoreHidden) {\n    this._ignoreHidden = ignoreHidden;\n  }\n\n  set imageExtension(imageExtension) {\n    this._imageExtension = imageExtension;\n  }\n\n  set imagePath(imagePath) {\n    this._imagePath = imagePath;\n  }\n\n  set imageSizes(imageSizes) {\n    this._imageSizes = imageSizes;\n  }\n\n  set maxZoom(maxZoom) {\n    this._maxZoom = maxZoom;\n  }\n\n  set minimumClusterSize(minimumClusterSize) {\n    this._minimumClusterSize = minimumClusterSize;\n  }\n\n  set styles(styles) {\n    this._styles = styles;\n  }\n\n  set title(title) {\n    this._title = title;\n  }\n\n  set zIndex(zIndex) {\n    this._zIndex = zIndex;\n  }\n\n  set zoomOnClick(zoomOnClick) {\n    this._zoomOnClick = zoomOnClick;\n  }\n\n  set options(options) {\n    this._options = options;\n  }\n\n  ngOnInit() {\n    if (this._canInitialize) {\n      const clustererWindow = window;\n\n      if (!clustererWindow.MarkerClusterer && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('MarkerClusterer class not found, cannot construct a marker cluster. ' + 'Please install the MarkerClustererPlus library: ' + 'https://github.com/googlemaps/js-markerclustererplus');\n      } // Create the object outside the zone so its events don't trigger change detection.\n      // We'll bring it back in inside the `MapEventManager` only for the events that the\n      // user has subscribed to.\n\n\n      this._ngZone.runOutsideAngular(() => {\n        this.markerClusterer = new MarkerClusterer(this._googleMap.googleMap, [], this._combineOptions());\n      });\n\n      this._assertInitialized();\n\n      this._eventManager.setTarget(this.markerClusterer);\n    }\n  }\n\n  ngAfterContentInit() {\n    if (this._canInitialize) {\n      this._watchForMarkerChanges();\n    }\n  }\n\n  ngOnChanges(changes) {\n    const {\n      markerClusterer: clusterer,\n      ariaLabelFn,\n      _averageCenter,\n      _batchSizeIE,\n      _calculator,\n      _styles,\n      _clusterClass,\n      _enableRetinaIcons,\n      _gridSize,\n      _ignoreHidden,\n      _imageExtension,\n      _imagePath,\n      _imageSizes,\n      _maxZoom,\n      _minimumClusterSize,\n      _title,\n      _zIndex,\n      _zoomOnClick\n    } = this;\n\n    if (clusterer) {\n      if (changes['options']) {\n        clusterer.setOptions(this._combineOptions());\n      }\n\n      if (changes['ariaLabelFn']) {\n        clusterer.ariaLabelFn = ariaLabelFn;\n      }\n\n      if (changes['averageCenter'] && _averageCenter !== undefined) {\n        clusterer.setAverageCenter(_averageCenter);\n      }\n\n      if (changes['batchSizeIE'] && _batchSizeIE !== undefined) {\n        clusterer.setBatchSizeIE(_batchSizeIE);\n      }\n\n      if (changes['calculator'] && !!_calculator) {\n        clusterer.setCalculator(_calculator);\n      }\n\n      if (changes['clusterClass'] && _clusterClass !== undefined) {\n        clusterer.setClusterClass(_clusterClass);\n      }\n\n      if (changes['enableRetinaIcons'] && _enableRetinaIcons !== undefined) {\n        clusterer.setEnableRetinaIcons(_enableRetinaIcons);\n      }\n\n      if (changes['gridSize'] && _gridSize !== undefined) {\n        clusterer.setGridSize(_gridSize);\n      }\n\n      if (changes['ignoreHidden'] && _ignoreHidden !== undefined) {\n        clusterer.setIgnoreHidden(_ignoreHidden);\n      }\n\n      if (changes['imageExtension'] && _imageExtension !== undefined) {\n        clusterer.setImageExtension(_imageExtension);\n      }\n\n      if (changes['imagePath'] && _imagePath !== undefined) {\n        clusterer.setImagePath(_imagePath);\n      }\n\n      if (changes['imageSizes'] && _imageSizes) {\n        clusterer.setImageSizes(_imageSizes);\n      }\n\n      if (changes['maxZoom'] && _maxZoom !== undefined) {\n        clusterer.setMaxZoom(_maxZoom);\n      }\n\n      if (changes['minimumClusterSize'] && _minimumClusterSize !== undefined) {\n        clusterer.setMinimumClusterSize(_minimumClusterSize);\n      }\n\n      if (changes['styles'] && _styles) {\n        clusterer.setStyles(_styles);\n      }\n\n      if (changes['title'] && _title !== undefined) {\n        clusterer.setTitle(_title);\n      }\n\n      if (changes['zIndex'] && _zIndex !== undefined) {\n        clusterer.setZIndex(_zIndex);\n      }\n\n      if (changes['zoomOnClick'] && _zoomOnClick !== undefined) {\n        clusterer.setZoomOnClick(_zoomOnClick);\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    this._destroy.next();\n\n    this._destroy.complete();\n\n    this._eventManager.destroy();\n\n    if (this.markerClusterer) {\n      this.markerClusterer.setMap(null);\n    }\n  }\n\n  fitMapToMarkers(padding) {\n    this._assertInitialized();\n\n    this.markerClusterer.fitMapToMarkers(padding);\n  }\n\n  getAverageCenter() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getAverageCenter();\n  }\n\n  getBatchSizeIE() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getBatchSizeIE();\n  }\n\n  getCalculator() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getCalculator();\n  }\n\n  getClusterClass() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getClusterClass();\n  }\n\n  getClusters() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getClusters();\n  }\n\n  getEnableRetinaIcons() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getEnableRetinaIcons();\n  }\n\n  getGridSize() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getGridSize();\n  }\n\n  getIgnoreHidden() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getIgnoreHidden();\n  }\n\n  getImageExtension() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getImageExtension();\n  }\n\n  getImagePath() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getImagePath();\n  }\n\n  getImageSizes() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getImageSizes();\n  }\n\n  getMaxZoom() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getMaxZoom();\n  }\n\n  getMinimumClusterSize() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getMinimumClusterSize();\n  }\n\n  getStyles() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getStyles();\n  }\n\n  getTitle() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getTitle();\n  }\n\n  getTotalClusters() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getTotalClusters();\n  }\n\n  getTotalMarkers() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getTotalMarkers();\n  }\n\n  getZIndex() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getZIndex();\n  }\n\n  getZoomOnClick() {\n    this._assertInitialized();\n\n    return this.markerClusterer.getZoomOnClick();\n  }\n\n  _combineOptions() {\n    const options = this._options || DEFAULT_CLUSTERER_OPTIONS;\n    return { ...options,\n      ariaLabelFn: this.ariaLabelFn ?? options.ariaLabelFn,\n      averageCenter: this._averageCenter ?? options.averageCenter,\n      batchSize: this.batchSize ?? options.batchSize,\n      batchSizeIE: this._batchSizeIE ?? options.batchSizeIE,\n      calculator: this._calculator ?? options.calculator,\n      clusterClass: this._clusterClass ?? options.clusterClass,\n      enableRetinaIcons: this._enableRetinaIcons ?? options.enableRetinaIcons,\n      gridSize: this._gridSize ?? options.gridSize,\n      ignoreHidden: this._ignoreHidden ?? options.ignoreHidden,\n      imageExtension: this._imageExtension ?? options.imageExtension,\n      imagePath: this._imagePath ?? options.imagePath,\n      imageSizes: this._imageSizes ?? options.imageSizes,\n      maxZoom: this._maxZoom ?? options.maxZoom,\n      minimumClusterSize: this._minimumClusterSize ?? options.minimumClusterSize,\n      styles: this._styles ?? options.styles,\n      title: this._title ?? options.title,\n      zIndex: this._zIndex ?? options.zIndex,\n      zoomOnClick: this._zoomOnClick ?? options.zoomOnClick\n    };\n  }\n\n  _watchForMarkerChanges() {\n    this._assertInitialized();\n\n    const initialMarkers = [];\n\n    for (const marker of this._getInternalMarkers(this._markers.toArray())) {\n      this._currentMarkers.add(marker);\n\n      initialMarkers.push(marker);\n    }\n\n    this.markerClusterer.addMarkers(initialMarkers);\n\n    this._markers.changes.pipe(takeUntil(this._destroy)).subscribe(markerComponents => {\n      this._assertInitialized();\n\n      const newMarkers = new Set(this._getInternalMarkers(markerComponents));\n      const markersToAdd = [];\n      const markersToRemove = [];\n\n      for (const marker of Array.from(newMarkers)) {\n        if (!this._currentMarkers.has(marker)) {\n          this._currentMarkers.add(marker);\n\n          markersToAdd.push(marker);\n        }\n      }\n\n      for (const marker of Array.from(this._currentMarkers)) {\n        if (!newMarkers.has(marker)) {\n          markersToRemove.push(marker);\n        }\n      }\n\n      this.markerClusterer.addMarkers(markersToAdd, true);\n      this.markerClusterer.removeMarkers(markersToRemove, true);\n      this.markerClusterer.repaint();\n\n      for (const marker of markersToRemove) {\n        this._currentMarkers.delete(marker);\n      }\n    });\n  }\n\n  _getInternalMarkers(markers) {\n    return markers.filter(markerComponent => !!markerComponent.marker).map(markerComponent => markerComponent.marker);\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._googleMap.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.markerClusterer) {\n        throw Error('Cannot interact with a MarkerClusterer before it has been initialized. ' + 'Please wait for the MarkerClusterer to load before trying to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapMarkerClusterer.ɵfac = function MapMarkerClusterer_Factory(t) {\n  return new (t || MapMarkerClusterer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapMarkerClusterer.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: MapMarkerClusterer,\n  selectors: [[\"map-marker-clusterer\"]],\n  contentQueries: function MapMarkerClusterer_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, MapMarker, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._markers = _t);\n    }\n  },\n  inputs: {\n    ariaLabelFn: \"ariaLabelFn\",\n    averageCenter: \"averageCenter\",\n    batchSize: \"batchSize\",\n    batchSizeIE: \"batchSizeIE\",\n    calculator: \"calculator\",\n    clusterClass: \"clusterClass\",\n    enableRetinaIcons: \"enableRetinaIcons\",\n    gridSize: \"gridSize\",\n    ignoreHidden: \"ignoreHidden\",\n    imageExtension: \"imageExtension\",\n    imagePath: \"imagePath\",\n    imageSizes: \"imageSizes\",\n    maxZoom: \"maxZoom\",\n    minimumClusterSize: \"minimumClusterSize\",\n    styles: \"styles\",\n    title: \"title\",\n    zIndex: \"zIndex\",\n    zoomOnClick: \"zoomOnClick\",\n    options: \"options\"\n  },\n  outputs: {\n    clusteringbegin: \"clusteringbegin\",\n    clusteringend: \"clusteringend\",\n    clusterClick: \"clusterClick\"\n  },\n  exportAs: [\"mapMarkerClusterer\"],\n  features: [i0.ɵɵNgOnChangesFeature],\n  ngContentSelectors: _c0,\n  decls: 1,\n  vars: 0,\n  template: function MapMarkerClusterer_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵprojection(0);\n    }\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapMarkerClusterer, [{\n    type: Component,\n    args: [{\n      selector: 'map-marker-clusterer',\n      exportAs: 'mapMarkerClusterer',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      template: '<ng-content></ng-content>',\n      encapsulation: ViewEncapsulation.None\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    ariaLabelFn: [{\n      type: Input\n    }],\n    averageCenter: [{\n      type: Input\n    }],\n    batchSize: [{\n      type: Input\n    }],\n    batchSizeIE: [{\n      type: Input\n    }],\n    calculator: [{\n      type: Input\n    }],\n    clusterClass: [{\n      type: Input\n    }],\n    enableRetinaIcons: [{\n      type: Input\n    }],\n    gridSize: [{\n      type: Input\n    }],\n    ignoreHidden: [{\n      type: Input\n    }],\n    imageExtension: [{\n      type: Input\n    }],\n    imagePath: [{\n      type: Input\n    }],\n    imageSizes: [{\n      type: Input\n    }],\n    maxZoom: [{\n      type: Input\n    }],\n    minimumClusterSize: [{\n      type: Input\n    }],\n    styles: [{\n      type: Input\n    }],\n    title: [{\n      type: Input\n    }],\n    zIndex: [{\n      type: Input\n    }],\n    zoomOnClick: [{\n      type: Input\n    }],\n    options: [{\n      type: Input\n    }],\n    clusteringbegin: [{\n      type: Output\n    }],\n    clusteringend: [{\n      type: Output\n    }],\n    clusterClick: [{\n      type: Output\n    }],\n    _markers: [{\n      type: ContentChildren,\n      args: [MapMarker, {\n        descendants: true\n      }]\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Polygon via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon\n */\n\n\nclass MapPolygon {\n  constructor(_map, _ngZone) {\n    this._map = _map;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    this._options = new BehaviorSubject({});\n    this._paths = new BehaviorSubject(undefined);\n    this._destroyed = new Subject();\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.click\n     */\n\n    this.polygonClick = this._eventManager.getLazyEmitter('click');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.dblclick\n     */\n\n    this.polygonDblclick = this._eventManager.getLazyEmitter('dblclick');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.drag\n     */\n\n    this.polygonDrag = this._eventManager.getLazyEmitter('drag');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.dragend\n     */\n\n    this.polygonDragend = this._eventManager.getLazyEmitter('dragend');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.dragstart\n     */\n\n    this.polygonDragstart = this._eventManager.getLazyEmitter('dragstart');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mousedown\n     */\n\n    this.polygonMousedown = this._eventManager.getLazyEmitter('mousedown');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mousemove\n     */\n\n    this.polygonMousemove = this._eventManager.getLazyEmitter('mousemove');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mouseout\n     */\n\n    this.polygonMouseout = this._eventManager.getLazyEmitter('mouseout');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mouseover\n     */\n\n    this.polygonMouseover = this._eventManager.getLazyEmitter('mouseover');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.mouseup\n     */\n\n    this.polygonMouseup = this._eventManager.getLazyEmitter('mouseup');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.rightclick\n     */\n\n    this.polygonRightclick = this._eventManager.getLazyEmitter('rightclick');\n  }\n\n  set options(options) {\n    this._options.next(options || {});\n  }\n\n  set paths(paths) {\n    this._paths.next(paths);\n  }\n\n  ngOnInit() {\n    if (this._map._isBrowser) {\n      this._combineOptions().pipe(take(1)).subscribe(options => {\n        // Create the object outside the zone so its events don't trigger change detection.\n        // We'll bring it back in inside the `MapEventManager` only for the events that the\n        // user has subscribed to.\n        this._ngZone.runOutsideAngular(() => {\n          this.polygon = new google.maps.Polygon(options);\n        });\n\n        this._assertInitialized();\n\n        this.polygon.setMap(this._map.googleMap);\n\n        this._eventManager.setTarget(this.polygon);\n      });\n\n      this._watchForOptionsChanges();\n\n      this._watchForPathChanges();\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    this._destroyed.next();\n\n    this._destroyed.complete();\n\n    if (this.polygon) {\n      this.polygon.setMap(null);\n    }\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getDraggable\n   */\n\n\n  getDraggable() {\n    this._assertInitialized();\n\n    return this.polygon.getDraggable();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getEditable\n   */\n\n\n  getEditable() {\n    this._assertInitialized();\n\n    return this.polygon.getEditable();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getPath\n   */\n\n\n  getPath() {\n    this._assertInitialized();\n\n    return this.polygon.getPath();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getPaths\n   */\n\n\n  getPaths() {\n    this._assertInitialized();\n\n    return this.polygon.getPaths();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/polygon#Polygon.getVisible\n   */\n\n\n  getVisible() {\n    this._assertInitialized();\n\n    return this.polygon.getVisible();\n  }\n\n  _combineOptions() {\n    return combineLatest([this._options, this._paths]).pipe(map(([options, paths]) => {\n      const combinedOptions = { ...options,\n        paths: paths || options.paths\n      };\n      return combinedOptions;\n    }));\n  }\n\n  _watchForOptionsChanges() {\n    this._options.pipe(takeUntil(this._destroyed)).subscribe(options => {\n      this._assertInitialized();\n\n      this.polygon.setOptions(options);\n    });\n  }\n\n  _watchForPathChanges() {\n    this._paths.pipe(takeUntil(this._destroyed)).subscribe(paths => {\n      if (paths) {\n        this._assertInitialized();\n\n        this.polygon.setPaths(paths);\n      }\n    });\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._map.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.polygon) {\n        throw Error('Cannot interact with a Google Map Polygon before it has been ' + 'initialized. Please wait for the Polygon to load before trying to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapPolygon.ɵfac = function MapPolygon_Factory(t) {\n  return new (t || MapPolygon)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapPolygon.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapPolygon,\n  selectors: [[\"map-polygon\"]],\n  inputs: {\n    options: \"options\",\n    paths: \"paths\"\n  },\n  outputs: {\n    polygonClick: \"polygonClick\",\n    polygonDblclick: \"polygonDblclick\",\n    polygonDrag: \"polygonDrag\",\n    polygonDragend: \"polygonDragend\",\n    polygonDragstart: \"polygonDragstart\",\n    polygonMousedown: \"polygonMousedown\",\n    polygonMousemove: \"polygonMousemove\",\n    polygonMouseout: \"polygonMouseout\",\n    polygonMouseover: \"polygonMouseover\",\n    polygonMouseup: \"polygonMouseup\",\n    polygonRightclick: \"polygonRightclick\"\n  },\n  exportAs: [\"mapPolygon\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapPolygon, [{\n    type: Directive,\n    args: [{\n      selector: 'map-polygon',\n      exportAs: 'mapPolygon'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    options: [{\n      type: Input\n    }],\n    paths: [{\n      type: Input\n    }],\n    polygonClick: [{\n      type: Output\n    }],\n    polygonDblclick: [{\n      type: Output\n    }],\n    polygonDrag: [{\n      type: Output\n    }],\n    polygonDragend: [{\n      type: Output\n    }],\n    polygonDragstart: [{\n      type: Output\n    }],\n    polygonMousedown: [{\n      type: Output\n    }],\n    polygonMousemove: [{\n      type: Output\n    }],\n    polygonMouseout: [{\n      type: Output\n    }],\n    polygonMouseover: [{\n      type: Output\n    }],\n    polygonMouseup: [{\n      type: Output\n    }],\n    polygonRightclick: [{\n      type: Output\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Polyline via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline\n */\n\n\nclass MapPolyline {\n  constructor(_map, _ngZone) {\n    this._map = _map;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    this._options = new BehaviorSubject({});\n    this._path = new BehaviorSubject(undefined);\n    this._destroyed = new Subject();\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.click\n     */\n\n    this.polylineClick = this._eventManager.getLazyEmitter('click');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.dblclick\n     */\n\n    this.polylineDblclick = this._eventManager.getLazyEmitter('dblclick');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.drag\n     */\n\n    this.polylineDrag = this._eventManager.getLazyEmitter('drag');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.dragend\n     */\n\n    this.polylineDragend = this._eventManager.getLazyEmitter('dragend');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.dragstart\n     */\n\n    this.polylineDragstart = this._eventManager.getLazyEmitter('dragstart');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mousedown\n     */\n\n    this.polylineMousedown = this._eventManager.getLazyEmitter('mousedown');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mousemove\n     */\n\n    this.polylineMousemove = this._eventManager.getLazyEmitter('mousemove');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mouseout\n     */\n\n    this.polylineMouseout = this._eventManager.getLazyEmitter('mouseout');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mouseover\n     */\n\n    this.polylineMouseover = this._eventManager.getLazyEmitter('mouseover');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.mouseup\n     */\n\n    this.polylineMouseup = this._eventManager.getLazyEmitter('mouseup');\n    /**\n     * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.rightclick\n     */\n\n    this.polylineRightclick = this._eventManager.getLazyEmitter('rightclick');\n  }\n\n  set options(options) {\n    this._options.next(options || {});\n  }\n\n  set path(path) {\n    this._path.next(path);\n  }\n\n  ngOnInit() {\n    if (this._map._isBrowser) {\n      this._combineOptions().pipe(take(1)).subscribe(options => {\n        // Create the object outside the zone so its events don't trigger change detection.\n        // We'll bring it back in inside the `MapEventManager` only for the events that the\n        // user has subscribed to.\n        this._ngZone.runOutsideAngular(() => this.polyline = new google.maps.Polyline(options));\n\n        this._assertInitialized();\n\n        this.polyline.setMap(this._map.googleMap);\n\n        this._eventManager.setTarget(this.polyline);\n      });\n\n      this._watchForOptionsChanges();\n\n      this._watchForPathChanges();\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    this._destroyed.next();\n\n    this._destroyed.complete();\n\n    if (this.polyline) {\n      this.polyline.setMap(null);\n    }\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.getDraggable\n   */\n\n\n  getDraggable() {\n    this._assertInitialized();\n\n    return this.polyline.getDraggable();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.getEditable\n   */\n\n\n  getEditable() {\n    this._assertInitialized();\n\n    return this.polyline.getEditable();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.getPath\n   */\n\n\n  getPath() {\n    this._assertInitialized();\n\n    return this.polyline.getPath();\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/polygon#Polyline.getVisible\n   */\n\n\n  getVisible() {\n    this._assertInitialized();\n\n    return this.polyline.getVisible();\n  }\n\n  _combineOptions() {\n    return combineLatest([this._options, this._path]).pipe(map(([options, path]) => {\n      const combinedOptions = { ...options,\n        path: path || options.path\n      };\n      return combinedOptions;\n    }));\n  }\n\n  _watchForOptionsChanges() {\n    this._options.pipe(takeUntil(this._destroyed)).subscribe(options => {\n      this._assertInitialized();\n\n      this.polyline.setOptions(options);\n    });\n  }\n\n  _watchForPathChanges() {\n    this._path.pipe(takeUntil(this._destroyed)).subscribe(path => {\n      if (path) {\n        this._assertInitialized();\n\n        this.polyline.setPath(path);\n      }\n    });\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._map.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.polyline) {\n        throw Error('Cannot interact with a Google Map Polyline before it has been ' + 'initialized. Please wait for the Polyline to load before trying to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapPolyline.ɵfac = function MapPolyline_Factory(t) {\n  return new (t || MapPolyline)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapPolyline.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapPolyline,\n  selectors: [[\"map-polyline\"]],\n  inputs: {\n    options: \"options\",\n    path: \"path\"\n  },\n  outputs: {\n    polylineClick: \"polylineClick\",\n    polylineDblclick: \"polylineDblclick\",\n    polylineDrag: \"polylineDrag\",\n    polylineDragend: \"polylineDragend\",\n    polylineDragstart: \"polylineDragstart\",\n    polylineMousedown: \"polylineMousedown\",\n    polylineMousemove: \"polylineMousemove\",\n    polylineMouseout: \"polylineMouseout\",\n    polylineMouseover: \"polylineMouseover\",\n    polylineMouseup: \"polylineMouseup\",\n    polylineRightclick: \"polylineRightclick\"\n  },\n  exportAs: [\"mapPolyline\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapPolyline, [{\n    type: Directive,\n    args: [{\n      selector: 'map-polyline',\n      exportAs: 'mapPolyline'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    options: [{\n      type: Input\n    }],\n    path: [{\n      type: Input\n    }],\n    polylineClick: [{\n      type: Output\n    }],\n    polylineDblclick: [{\n      type: Output\n    }],\n    polylineDrag: [{\n      type: Output\n    }],\n    polylineDragend: [{\n      type: Output\n    }],\n    polylineDragstart: [{\n      type: Output\n    }],\n    polylineMousedown: [{\n      type: Output\n    }],\n    polylineMousemove: [{\n      type: Output\n    }],\n    polylineMouseout: [{\n      type: Output\n    }],\n    polylineMouseover: [{\n      type: Output\n    }],\n    polylineMouseup: [{\n      type: Output\n    }],\n    polylineRightclick: [{\n      type: Output\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Rectangle via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle\n */\n\n\nclass MapRectangle {\n  constructor(_map, _ngZone) {\n    this._map = _map;\n    this._ngZone = _ngZone;\n    this._eventManager = new MapEventManager(this._ngZone);\n    this._options = new BehaviorSubject({});\n    this._bounds = new BehaviorSubject(undefined);\n    this._destroyed = new Subject();\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.boundsChanged\n     */\n\n    this.boundsChanged = this._eventManager.getLazyEmitter('bounds_changed');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.click\n     */\n\n    this.rectangleClick = this._eventManager.getLazyEmitter('click');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.dblclick\n     */\n\n    this.rectangleDblclick = this._eventManager.getLazyEmitter('dblclick');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.drag\n     */\n\n    this.rectangleDrag = this._eventManager.getLazyEmitter('drag');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.dragend\n     */\n\n    this.rectangleDragend = this._eventManager.getLazyEmitter('dragend');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.dragstart\n     */\n\n    this.rectangleDragstart = this._eventManager.getLazyEmitter('dragstart');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mousedown\n     */\n\n    this.rectangleMousedown = this._eventManager.getLazyEmitter('mousedown');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mousemove\n     */\n\n    this.rectangleMousemove = this._eventManager.getLazyEmitter('mousemove');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mouseout\n     */\n\n    this.rectangleMouseout = this._eventManager.getLazyEmitter('mouseout');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mouseover\n     */\n\n    this.rectangleMouseover = this._eventManager.getLazyEmitter('mouseover');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.mouseup\n     */\n\n    this.rectangleMouseup = this._eventManager.getLazyEmitter('mouseup');\n    /**\n     * See\n     * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.rightclick\n     */\n\n    this.rectangleRightclick = this._eventManager.getLazyEmitter('rightclick');\n  }\n\n  set options(options) {\n    this._options.next(options || {});\n  }\n\n  set bounds(bounds) {\n    this._bounds.next(bounds);\n  }\n\n  ngOnInit() {\n    if (this._map._isBrowser) {\n      this._combineOptions().pipe(take(1)).subscribe(options => {\n        // Create the object outside the zone so its events don't trigger change detection.\n        // We'll bring it back in inside the `MapEventManager` only for the events that the\n        // user has subscribed to.\n        this._ngZone.runOutsideAngular(() => {\n          this.rectangle = new google.maps.Rectangle(options);\n        });\n\n        this._assertInitialized();\n\n        this.rectangle.setMap(this._map.googleMap);\n\n        this._eventManager.setTarget(this.rectangle);\n      });\n\n      this._watchForOptionsChanges();\n\n      this._watchForBoundsChanges();\n    }\n  }\n\n  ngOnDestroy() {\n    this._eventManager.destroy();\n\n    this._destroyed.next();\n\n    this._destroyed.complete();\n\n    if (this.rectangle) {\n      this.rectangle.setMap(null);\n    }\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.getBounds\n   */\n\n\n  getBounds() {\n    this._assertInitialized();\n\n    return this.rectangle.getBounds();\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.getDraggable\n   */\n\n\n  getDraggable() {\n    this._assertInitialized();\n\n    return this.rectangle.getDraggable();\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.getEditable\n   */\n\n\n  getEditable() {\n    this._assertInitialized();\n\n    return this.rectangle.getEditable();\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/polygon#Rectangle.getVisible\n   */\n\n\n  getVisible() {\n    this._assertInitialized();\n\n    return this.rectangle.getVisible();\n  }\n\n  _combineOptions() {\n    return combineLatest([this._options, this._bounds]).pipe(map(([options, bounds]) => {\n      const combinedOptions = { ...options,\n        bounds: bounds || options.bounds\n      };\n      return combinedOptions;\n    }));\n  }\n\n  _watchForOptionsChanges() {\n    this._options.pipe(takeUntil(this._destroyed)).subscribe(options => {\n      this._assertInitialized();\n\n      this.rectangle.setOptions(options);\n    });\n  }\n\n  _watchForBoundsChanges() {\n    this._bounds.pipe(takeUntil(this._destroyed)).subscribe(bounds => {\n      if (bounds) {\n        this._assertInitialized();\n\n        this.rectangle.setBounds(bounds);\n      }\n    });\n  }\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._map.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.rectangle) {\n        throw Error('Cannot interact with a Google Map Rectangle before it has been initialized. ' + 'Please wait for the Rectangle to load before trying to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapRectangle.ɵfac = function MapRectangle_Factory(t) {\n  return new (t || MapRectangle)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapRectangle.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapRectangle,\n  selectors: [[\"map-rectangle\"]],\n  inputs: {\n    options: \"options\",\n    bounds: \"bounds\"\n  },\n  outputs: {\n    boundsChanged: \"boundsChanged\",\n    rectangleClick: \"rectangleClick\",\n    rectangleDblclick: \"rectangleDblclick\",\n    rectangleDrag: \"rectangleDrag\",\n    rectangleDragend: \"rectangleDragend\",\n    rectangleDragstart: \"rectangleDragstart\",\n    rectangleMousedown: \"rectangleMousedown\",\n    rectangleMousemove: \"rectangleMousemove\",\n    rectangleMouseout: \"rectangleMouseout\",\n    rectangleMouseover: \"rectangleMouseover\",\n    rectangleMouseup: \"rectangleMouseup\",\n    rectangleRightclick: \"rectangleRightclick\"\n  },\n  exportAs: [\"mapRectangle\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapRectangle, [{\n    type: Directive,\n    args: [{\n      selector: 'map-rectangle',\n      exportAs: 'mapRectangle'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    options: [{\n      type: Input\n    }],\n    bounds: [{\n      type: Input\n    }],\n    boundsChanged: [{\n      type: Output\n    }],\n    rectangleClick: [{\n      type: Output\n    }],\n    rectangleDblclick: [{\n      type: Output\n    }],\n    rectangleDrag: [{\n      type: Output\n    }],\n    rectangleDragend: [{\n      type: Output\n    }],\n    rectangleDragstart: [{\n      type: Output\n    }],\n    rectangleMousedown: [{\n      type: Output\n    }],\n    rectangleMousemove: [{\n      type: Output\n    }],\n    rectangleMouseout: [{\n      type: Output\n    }],\n    rectangleMouseover: [{\n      type: Output\n    }],\n    rectangleMouseup: [{\n      type: Output\n    }],\n    rectangleRightclick: [{\n      type: Output\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Traffic Layer via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/map#TrafficLayer\n */\n\n\nclass MapTrafficLayer {\n  constructor(_map, _ngZone) {\n    this._map = _map;\n    this._ngZone = _ngZone;\n    this._autoRefresh = new BehaviorSubject(true);\n    this._destroyed = new Subject();\n  }\n  /**\n   * Whether the traffic layer refreshes with updated information automatically.\n   */\n\n\n  set autoRefresh(autoRefresh) {\n    this._autoRefresh.next(autoRefresh);\n  }\n\n  ngOnInit() {\n    if (this._map._isBrowser) {\n      this._combineOptions().pipe(take(1)).subscribe(options => {\n        // Create the object outside the zone so its events don't trigger change detection.\n        this._ngZone.runOutsideAngular(() => {\n          this.trafficLayer = new google.maps.TrafficLayer(options);\n        });\n\n        this._assertInitialized();\n\n        this.trafficLayer.setMap(this._map.googleMap);\n      });\n\n      this._watchForAutoRefreshChanges();\n    }\n  }\n\n  ngOnDestroy() {\n    this._destroyed.next();\n\n    this._destroyed.complete();\n\n    if (this.trafficLayer) {\n      this.trafficLayer.setMap(null);\n    }\n  }\n\n  _combineOptions() {\n    return this._autoRefresh.pipe(map(autoRefresh => {\n      const combinedOptions = {\n        autoRefresh\n      };\n      return combinedOptions;\n    }));\n  }\n\n  _watchForAutoRefreshChanges() {\n    this._combineOptions().pipe(takeUntil(this._destroyed)).subscribe(options => {\n      this._assertInitialized();\n\n      this.trafficLayer.setOptions(options);\n    });\n  }\n\n  _assertInitialized() {\n    if (!this._map.googleMap) {\n      throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n    }\n\n    if (!this.trafficLayer) {\n      throw Error('Cannot interact with a Google Map Traffic Layer before it has been initialized. ' + 'Please wait for the Traffic Layer to load before trying to interact with it.');\n    }\n  }\n\n}\n\nMapTrafficLayer.ɵfac = function MapTrafficLayer_Factory(t) {\n  return new (t || MapTrafficLayer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapTrafficLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapTrafficLayer,\n  selectors: [[\"map-traffic-layer\"]],\n  inputs: {\n    autoRefresh: \"autoRefresh\"\n  },\n  exportAs: [\"mapTrafficLayer\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapTrafficLayer, [{\n    type: Directive,\n    args: [{\n      selector: 'map-traffic-layer',\n      exportAs: 'mapTrafficLayer'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    autoRefresh: [{\n      type: Input\n    }]\n  });\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular component that renders a Google Maps Transit Layer via the Google Maps JavaScript API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/map#TransitLayer\n */\n\n\nclass MapTransitLayer extends MapBaseLayer {\n  _initializeObject() {\n    this.transitLayer = new google.maps.TransitLayer();\n  }\n\n  _setMap() {\n    this._assertLayerInitialized();\n\n    this.transitLayer.setMap(this._map.googleMap);\n  }\n\n  _unsetMap() {\n    if (this.transitLayer) {\n      this.transitLayer.setMap(null);\n    }\n  }\n\n  _assertLayerInitialized() {\n    if (!this.transitLayer) {\n      throw Error('Cannot interact with a Google Map Transit Layer before it has been initialized. ' + 'Please wait for the Transit Layer to load before trying to interact with it.');\n    }\n  }\n\n}\n\nMapTransitLayer.ɵfac = /* @__PURE__ */function () {\n  let ɵMapTransitLayer_BaseFactory;\n  return function MapTransitLayer_Factory(t) {\n    return (ɵMapTransitLayer_BaseFactory || (ɵMapTransitLayer_BaseFactory = i0.ɵɵgetInheritedFactory(MapTransitLayer)))(t || MapTransitLayer);\n  };\n}();\n\nMapTransitLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapTransitLayer,\n  selectors: [[\"map-transit-layer\"]],\n  exportAs: [\"mapTransitLayer\"],\n  features: [i0.ɵɵInheritDefinitionFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapTransitLayer, [{\n    type: Directive,\n    args: [{\n      selector: 'map-transit-layer',\n      exportAs: 'mapTransitLayer'\n    }]\n  }], null, null);\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular directive that renders a Google Maps heatmap via the Google Maps JavaScript API.\n *\n * See: https://developers.google.com/maps/documentation/javascript/reference/visualization\n */\n\n\nclass MapHeatmapLayer {\n  constructor(_googleMap, _ngZone) {\n    this._googleMap = _googleMap;\n    this._ngZone = _ngZone;\n  }\n  /**\n   * Data shown on the heatmap.\n   * See: https://developers.google.com/maps/documentation/javascript/reference/visualization\n   */\n\n\n  set data(data) {\n    this._data = data;\n  }\n  /**\n   * Options used to configure the heatmap. See:\n   * developers.google.com/maps/documentation/javascript/reference/visualization#HeatmapLayerOptions\n   */\n\n\n  set options(options) {\n    this._options = options;\n  }\n\n  ngOnInit() {\n    if (this._googleMap._isBrowser) {\n      if (!window.google?.maps?.visualization && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Namespace `google.maps.visualization` not found, cannot construct heatmap. ' + 'Please install the Google Maps JavaScript API with the \"visualization\" library: ' + 'https://developers.google.com/maps/documentation/javascript/visualization');\n      } // Create the object outside the zone so its events don't trigger change detection.\n      // We'll bring it back in inside the `MapEventManager` only for the events that the\n      // user has subscribed to.\n\n\n      this._ngZone.runOutsideAngular(() => {\n        this.heatmap = new google.maps.visualization.HeatmapLayer(this._combineOptions());\n      });\n\n      this._assertInitialized();\n\n      this.heatmap.setMap(this._googleMap.googleMap);\n    }\n  }\n\n  ngOnChanges(changes) {\n    const {\n      _data,\n      heatmap\n    } = this;\n\n    if (heatmap) {\n      if (changes['options']) {\n        heatmap.setOptions(this._combineOptions());\n      }\n\n      if (changes['data'] && _data !== undefined) {\n        heatmap.setData(this._normalizeData(_data));\n      }\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.heatmap) {\n      this.heatmap.setMap(null);\n    }\n  }\n  /**\n   * Gets the data that is currently shown on the heatmap.\n   * See: developers.google.com/maps/documentation/javascript/reference/visualization#HeatmapLayer\n   */\n\n\n  getData() {\n    this._assertInitialized();\n\n    return this.heatmap.getData();\n  }\n  /** Creates a combined options object using the passed-in options and the individual inputs. */\n\n\n  _combineOptions() {\n    const options = this._options || {};\n    return { ...options,\n      data: this._normalizeData(this._data || options.data || []),\n      map: this._googleMap.googleMap\n    };\n  }\n  /**\n   * Most Google Maps APIs support both `LatLng` objects and `LatLngLiteral`. The latter is more\n   * convenient to write out, because the Google Maps API doesn't have to have been loaded in order\n   * to construct them. The `HeatmapLayer` appears to be an exception that only allows a `LatLng`\n   * object, or it throws a runtime error. Since it's more convenient and we expect that Angular\n   * users will load the API asynchronously, we allow them to pass in a `LatLngLiteral` and we\n   * convert it to a `LatLng` object before passing it off to Google Maps.\n   */\n\n\n  _normalizeData(data) {\n    const result = [];\n    data.forEach(item => {\n      result.push(isLatLngLiteral(item) ? new google.maps.LatLng(item.lat, item.lng) : item);\n    });\n    return result;\n  }\n  /** Asserts that the heatmap object has been initialized. */\n\n\n  _assertInitialized() {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (!this._googleMap.googleMap) {\n        throw Error('Cannot access Google Map information before the API has been initialized. ' + 'Please wait for the API to load before trying to interact with it.');\n      }\n\n      if (!this.heatmap) {\n        throw Error('Cannot interact with a Google Map HeatmapLayer before it has been ' + 'initialized. Please wait for the heatmap to load before trying to interact with it.');\n      }\n    }\n  }\n\n}\n\nMapHeatmapLayer.ɵfac = function MapHeatmapLayer_Factory(t) {\n  return new (t || MapHeatmapLayer)(i0.ɵɵdirectiveInject(GoogleMap), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nMapHeatmapLayer.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: MapHeatmapLayer,\n  selectors: [[\"map-heatmap-layer\"]],\n  inputs: {\n    data: \"data\",\n    options: \"options\"\n  },\n  exportAs: [\"mapHeatmapLayer\"],\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapHeatmapLayer, [{\n    type: Directive,\n    args: [{\n      selector: 'map-heatmap-layer',\n      exportAs: 'mapHeatmapLayer'\n    }]\n  }], function () {\n    return [{\n      type: GoogleMap\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    data: [{\n      type: Input\n    }],\n    options: [{\n      type: Input\n    }]\n  });\n})();\n/** Asserts that an object is a `LatLngLiteral`. */\n\n\nfunction isLatLngLiteral(value) {\n  return value && typeof value.lat === 'number' && typeof value.lng === 'number';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst COMPONENTS = [GoogleMap, MapBaseLayer, MapBicyclingLayer, MapCircle, MapDirectionsRenderer, MapGroundOverlay, MapInfoWindow, MapKmlLayer, MapMarker, MapMarkerClusterer, MapPolygon, MapPolyline, MapRectangle, MapTrafficLayer, MapTransitLayer, MapHeatmapLayer];\n\nclass GoogleMapsModule {}\n\nGoogleMapsModule.ɵfac = function GoogleMapsModule_Factory(t) {\n  return new (t || GoogleMapsModule)();\n};\n\nGoogleMapsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: GoogleMapsModule,\n  declarations: [GoogleMap, MapBaseLayer, MapBicyclingLayer, MapCircle, MapDirectionsRenderer, MapGroundOverlay, MapInfoWindow, MapKmlLayer, MapMarker, MapMarkerClusterer, MapPolygon, MapPolyline, MapRectangle, MapTrafficLayer, MapTransitLayer, MapHeatmapLayer],\n  exports: [GoogleMap, MapBaseLayer, MapBicyclingLayer, MapCircle, MapDirectionsRenderer, MapGroundOverlay, MapInfoWindow, MapKmlLayer, MapMarker, MapMarkerClusterer, MapPolygon, MapPolyline, MapRectangle, MapTrafficLayer, MapTransitLayer, MapHeatmapLayer]\n});\nGoogleMapsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(GoogleMapsModule, [{\n    type: NgModule,\n    args: [{\n      declarations: COMPONENTS,\n      exports: COMPONENTS\n    }]\n  }], null, null);\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular service that wraps the Google Maps DirectionsService from the Google Maps JavaScript\n * API.\n *\n * See developers.google.com/maps/documentation/javascript/reference/directions#DirectionsService\n */\n\n\nclass MapDirectionsService {\n  constructor(_ngZone) {\n    this._ngZone = _ngZone;\n  }\n  /**\n   * See\n   * developers.google.com/maps/documentation/javascript/reference/directions\n   * #DirectionsService.route\n   */\n\n\n  route(request) {\n    return new Observable(observer => {\n      // Initialize the `DirectionsService` lazily since the Google Maps API may\n      // not have been loaded when the provider is instantiated.\n      if (!this._directionsService) {\n        this._directionsService = new google.maps.DirectionsService();\n      }\n\n      this._directionsService.route(request, (result, status) => {\n        this._ngZone.run(() => {\n          observer.next({\n            result: result || undefined,\n            status\n          });\n          observer.complete();\n        });\n      });\n    });\n  }\n\n}\n\nMapDirectionsService.ɵfac = function MapDirectionsService_Factory(t) {\n  return new (t || MapDirectionsService)(i0.ɵɵinject(i0.NgZone));\n};\n\nMapDirectionsService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: MapDirectionsService,\n  factory: MapDirectionsService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapDirectionsService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})(); /// <reference types=\"google.maps\" />\n\n/**\n * Angular service that wraps the Google Maps Geocoder from the Google Maps JavaScript API.\n * See developers.google.com/maps/documentation/javascript/reference/geocoder#Geocoder\n */\n\n\nclass MapGeocoder {\n  constructor(_ngZone) {\n    this._ngZone = _ngZone;\n  }\n  /**\n   * See developers.google.com/maps/documentation/javascript/reference/geocoder#Geocoder.geocode\n   */\n\n\n  geocode(request) {\n    return new Observable(observer => {\n      // Initialize the `Geocoder` lazily since the Google Maps API may\n      // not have been loaded when the provider is instantiated.\n      if (!this._geocoder) {\n        this._geocoder = new google.maps.Geocoder();\n      }\n\n      this._geocoder.geocode(request, (results, status) => {\n        this._ngZone.run(() => {\n          observer.next({\n            results: results || [],\n            status\n          });\n          observer.complete();\n        });\n      });\n    });\n  }\n\n}\n\nMapGeocoder.ɵfac = function MapGeocoder_Factory(t) {\n  return new (t || MapGeocoder)(i0.ɵɵinject(i0.NgZone));\n};\n\nMapGeocoder.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: MapGeocoder,\n  factory: MapGeocoder.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MapGeocoder, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { GoogleMap, GoogleMapsModule, MapBaseLayer, MapBicyclingLayer, MapCircle, MapDirectionsRenderer, MapDirectionsService, MapGeocoder, MapGroundOverlay, MapHeatmapLayer, MapInfoWindow, MapKmlLayer, MapMarker, MapMarkerClusterer, MapPolygon, MapPolyline, MapRectangle, MapTrafficLayer, MapTransitLayer }; //# sourceMappingURL=google-maps.mjs.map","map":null,"metadata":{},"sourceType":"module"}