{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.mqtt = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      'use strict';\n\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      } // Support decoding URL-safe base64 strings, as Node.js does.\n      // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n      revLookup['-'.charCodeAt(0)] = 62;\n      revLookup['_'.charCodeAt(0)] = 63;\n\n      function getLens(b64) {\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        } // Trim off extra bytes after placeholder bytes are found\n        // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n        var validLen = b64.indexOf('=');\n        if (validLen === -1) validLen = len;\n        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      } // base64 is 4/3 + up to two characters of the original data\n\n\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i;\n\n        for (i = 0; i < len; i += 4) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[curByte++] = tmp >> 16 & 0xFF;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        return arr;\n      }\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n      }\n\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n\n        for (var i = start; i < end; i += 3) {\n          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n          output.push(tripletToBase64(tmp));\n        }\n\n        return output.join('');\n      }\n\n      function fromByteArray(uint8) {\n        var tmp;\n        var len = uint8.length;\n        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n        var parts = [];\n        var maxChunkLength = 16383; // must be multiple of 3\n        // go through the array every three bytes, we'll deal with trailing stuff later\n\n        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n        } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n        if (extraBytes === 1) {\n          tmp = uint8[len - 1];\n          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n        }\n\n        return parts.join('');\n      }\n    }, {}],\n    2: [function (require, module, exports) {}, {}],\n    3: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          /*!\n           * The buffer module from node.js, for the browser.\n           *\n           * @author   Feross Aboukhadijeh <https://feross.org>\n           * @license  MIT\n           */\n\n          /* eslint-disable no-proto */\n          'use strict';\n\n          var base64 = require('base64-js');\n\n          var ieee754 = require('ieee754');\n\n          exports.Buffer = Buffer;\n          exports.SlowBuffer = SlowBuffer;\n          exports.INSPECT_MAX_BYTES = 50;\n          var K_MAX_LENGTH = 0x7fffffff;\n          exports.kMaxLength = K_MAX_LENGTH;\n          /**\n           * If `Buffer.TYPED_ARRAY_SUPPORT`:\n           *   === true    Use Uint8Array implementation (fastest)\n           *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n           *               implementation (most compatible, even IE6)\n           *\n           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n           * Opera 11.6+, iOS 4.2+.\n           *\n           * We report that the browser does not support typed arrays if the are not subclassable\n           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n           * for __proto__ and has a buggy typed array implementation.\n           */\n\n          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');\n          }\n\n          function typedArraySupport() {\n            // Can typed array instances can be augmented?\n            try {\n              var arr = new Uint8Array(1);\n              arr.__proto__ = {\n                __proto__: Uint8Array.prototype,\n                foo: function () {\n                  return 42;\n                }\n              };\n              return arr.foo() === 42;\n            } catch (e) {\n              return false;\n            }\n          }\n\n          Object.defineProperty(Buffer.prototype, 'parent', {\n            enumerable: true,\n            get: function () {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.buffer;\n            }\n          });\n          Object.defineProperty(Buffer.prototype, 'offset', {\n            enumerable: true,\n            get: function () {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.byteOffset;\n            }\n          });\n\n          function createBuffer(length) {\n            if (length > K_MAX_LENGTH) {\n              throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n            } // Return an augmented `Uint8Array` instance\n\n\n            var buf = new Uint8Array(length);\n            buf.__proto__ = Buffer.prototype;\n            return buf;\n          }\n          /**\n           * The Buffer constructor returns instances of `Uint8Array` that have their\n           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n           * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n           * returns a single octet.\n           *\n           * The `Uint8Array` prototype remains unmodified.\n           */\n\n\n          function Buffer(arg, encodingOrOffset, length) {\n            // Common case.\n            if (typeof arg === 'number') {\n              if (typeof encodingOrOffset === 'string') {\n                throw new TypeError('The \"string\" argument must be of type string. Received type number');\n              }\n\n              return allocUnsafe(arg);\n            }\n\n            return from(arg, encodingOrOffset, length);\n          } // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\n\n          if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {\n            Object.defineProperty(Buffer, Symbol.species, {\n              value: null,\n              configurable: true,\n              enumerable: false,\n              writable: false\n            });\n          }\n\n          Buffer.poolSize = 8192; // not used by this implementation\n\n          function from(value, encodingOrOffset, length) {\n            if (typeof value === 'string') {\n              return fromString(value, encodingOrOffset);\n            }\n\n            if (ArrayBuffer.isView(value)) {\n              return fromArrayLike(value);\n            }\n\n            if (value == null) {\n              throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n            }\n\n            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n              return fromArrayBuffer(value, encodingOrOffset, length);\n            }\n\n            if (typeof value === 'number') {\n              throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n            }\n\n            var valueOf = value.valueOf && value.valueOf();\n\n            if (valueOf != null && valueOf !== value) {\n              return Buffer.from(valueOf, encodingOrOffset, length);\n            }\n\n            var b = fromObject(value);\n            if (b) return b;\n\n            if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {\n              return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n            }\n\n            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n          }\n          /**\n           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n           * if value is a number.\n           * Buffer.from(str[, encoding])\n           * Buffer.from(array)\n           * Buffer.from(buffer)\n           * Buffer.from(arrayBuffer[, byteOffset[, length]])\n           **/\n\n\n          Buffer.from = function (value, encodingOrOffset, length) {\n            return from(value, encodingOrOffset, length);\n          }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n          // https://github.com/feross/buffer/pull/148\n\n\n          Buffer.prototype.__proto__ = Uint8Array.prototype;\n          Buffer.__proto__ = Uint8Array;\n\n          function assertSize(size) {\n            if (typeof size !== 'number') {\n              throw new TypeError('\"size\" argument must be of type number');\n            } else if (size < 0) {\n              throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n            }\n          }\n\n          function alloc(size, fill, encoding) {\n            assertSize(size);\n\n            if (size <= 0) {\n              return createBuffer(size);\n            }\n\n            if (fill !== undefined) {\n              // Only pay attention to encoding if it's a string. This\n              // prevents accidentally sending in a number that would\n              // be interpretted as a start offset.\n              return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n            }\n\n            return createBuffer(size);\n          }\n          /**\n           * Creates a new filled Buffer instance.\n           * alloc(size[, fill[, encoding]])\n           **/\n\n\n          Buffer.alloc = function (size, fill, encoding) {\n            return alloc(size, fill, encoding);\n          };\n\n          function allocUnsafe(size) {\n            assertSize(size);\n            return createBuffer(size < 0 ? 0 : checked(size) | 0);\n          }\n          /**\n           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n           * */\n\n\n          Buffer.allocUnsafe = function (size) {\n            return allocUnsafe(size);\n          };\n          /**\n           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n           */\n\n\n          Buffer.allocUnsafeSlow = function (size) {\n            return allocUnsafe(size);\n          };\n\n          function fromString(string, encoding) {\n            if (typeof encoding !== 'string' || encoding === '') {\n              encoding = 'utf8';\n            }\n\n            if (!Buffer.isEncoding(encoding)) {\n              throw new TypeError('Unknown encoding: ' + encoding);\n            }\n\n            var length = byteLength(string, encoding) | 0;\n            var buf = createBuffer(length);\n            var actual = buf.write(string, encoding);\n\n            if (actual !== length) {\n              // Writing a hex string, for example, that contains invalid characters will\n              // cause everything after the first invalid character to be ignored. (e.g.\n              // 'abxxcd' will be treated as 'ab')\n              buf = buf.slice(0, actual);\n            }\n\n            return buf;\n          }\n\n          function fromArrayLike(array) {\n            var length = array.length < 0 ? 0 : checked(array.length) | 0;\n            var buf = createBuffer(length);\n\n            for (var i = 0; i < length; i += 1) {\n              buf[i] = array[i] & 255;\n            }\n\n            return buf;\n          }\n\n          function fromArrayBuffer(array, byteOffset, length) {\n            if (byteOffset < 0 || array.byteLength < byteOffset) {\n              throw new RangeError('\"offset\" is outside of buffer bounds');\n            }\n\n            if (array.byteLength < byteOffset + (length || 0)) {\n              throw new RangeError('\"length\" is outside of buffer bounds');\n            }\n\n            var buf;\n\n            if (byteOffset === undefined && length === undefined) {\n              buf = new Uint8Array(array);\n            } else if (length === undefined) {\n              buf = new Uint8Array(array, byteOffset);\n            } else {\n              buf = new Uint8Array(array, byteOffset, length);\n            } // Return an augmented `Uint8Array` instance\n\n\n            buf.__proto__ = Buffer.prototype;\n            return buf;\n          }\n\n          function fromObject(obj) {\n            if (Buffer.isBuffer(obj)) {\n              var len = checked(obj.length) | 0;\n              var buf = createBuffer(len);\n\n              if (buf.length === 0) {\n                return buf;\n              }\n\n              obj.copy(buf, 0, 0, len);\n              return buf;\n            }\n\n            if (obj.length !== undefined) {\n              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n                return createBuffer(0);\n              }\n\n              return fromArrayLike(obj);\n            }\n\n            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n              return fromArrayLike(obj.data);\n            }\n          }\n\n          function checked(length) {\n            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n            // length is NaN (which is otherwise coerced to zero.)\n            if (length >= K_MAX_LENGTH) {\n              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n            }\n\n            return length | 0;\n          }\n\n          function SlowBuffer(length) {\n            if (+length != length) {\n              // eslint-disable-line eqeqeq\n              length = 0;\n            }\n\n            return Buffer.alloc(+length);\n          }\n\n          Buffer.isBuffer = function isBuffer(b) {\n            return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n          };\n\n          Buffer.compare = function compare(a, b) {\n            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\n            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n              throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n            }\n\n            if (a === b) return 0;\n            var x = a.length;\n            var y = b.length;\n\n            for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n              if (a[i] !== b[i]) {\n                x = a[i];\n                y = b[i];\n                break;\n              }\n            }\n\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          };\n\n          Buffer.isEncoding = function isEncoding(encoding) {\n            switch (String(encoding).toLowerCase()) {\n              case 'hex':\n              case 'utf8':\n              case 'utf-8':\n              case 'ascii':\n              case 'latin1':\n              case 'binary':\n              case 'base64':\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return true;\n\n              default:\n                return false;\n            }\n          };\n\n          Buffer.concat = function concat(list, length) {\n            if (!Array.isArray(list)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n\n            if (list.length === 0) {\n              return Buffer.alloc(0);\n            }\n\n            var i;\n\n            if (length === undefined) {\n              length = 0;\n\n              for (i = 0; i < list.length; ++i) {\n                length += list[i].length;\n              }\n            }\n\n            var buffer = Buffer.allocUnsafe(length);\n            var pos = 0;\n\n            for (i = 0; i < list.length; ++i) {\n              var buf = list[i];\n\n              if (isInstance(buf, Uint8Array)) {\n                buf = Buffer.from(buf);\n              }\n\n              if (!Buffer.isBuffer(buf)) {\n                throw new TypeError('\"list\" argument must be an Array of Buffers');\n              }\n\n              buf.copy(buffer, pos);\n              pos += buf.length;\n            }\n\n            return buffer;\n          };\n\n          function byteLength(string, encoding) {\n            if (Buffer.isBuffer(string)) {\n              return string.length;\n            }\n\n            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n              return string.byteLength;\n            }\n\n            if (typeof string !== 'string') {\n              throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);\n            }\n\n            var len = string.length;\n            var mustMatch = arguments.length > 2 && arguments[2] === true;\n            if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion\n\n            var loweredCase = false;\n\n            for (;;) {\n              switch (encoding) {\n                case 'ascii':\n                case 'latin1':\n                case 'binary':\n                  return len;\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8ToBytes(string).length;\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return len * 2;\n\n                case 'hex':\n                  return len >>> 1;\n\n                case 'base64':\n                  return base64ToBytes(string).length;\n\n                default:\n                  if (loweredCase) {\n                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n                  }\n\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          }\n\n          Buffer.byteLength = byteLength;\n\n          function slowToString(encoding, start, end) {\n            var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n            // property of a typed array.\n            // This behaves neither like String nor Uint8Array in that we set start/end\n            // to their upper/lower bounds if the value passed is out of range.\n            // undefined is handled specially as per ECMA-262 6th Edition,\n            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n            if (start === undefined || start < 0) {\n              start = 0;\n            } // Return early if start > this.length. Done here to prevent potential uint32\n            // coercion fail below.\n\n\n            if (start > this.length) {\n              return '';\n            }\n\n            if (end === undefined || end > this.length) {\n              end = this.length;\n            }\n\n            if (end <= 0) {\n              return '';\n            } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n            end >>>= 0;\n            start >>>= 0;\n\n            if (end <= start) {\n              return '';\n            }\n\n            if (!encoding) encoding = 'utf8';\n\n            while (true) {\n              switch (encoding) {\n                case 'hex':\n                  return hexSlice(this, start, end);\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Slice(this, start, end);\n\n                case 'ascii':\n                  return asciiSlice(this, start, end);\n\n                case 'latin1':\n                case 'binary':\n                  return latin1Slice(this, start, end);\n\n                case 'base64':\n                  return base64Slice(this, start, end);\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return utf16leSlice(this, start, end);\n\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = (encoding + '').toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n          // reliably in a browserify context because there could be multiple different\n          // copies of the 'buffer' package in use. This method works even for Buffer\n          // instances that were created from another copy of the `buffer` package.\n          // See: https://github.com/feross/buffer/issues/154\n\n\n          Buffer.prototype._isBuffer = true;\n\n          function swap(b, n, m) {\n            var i = b[n];\n            b[n] = b[m];\n            b[m] = i;\n          }\n\n          Buffer.prototype.swap16 = function swap16() {\n            var len = this.length;\n\n            if (len % 2 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 16-bits');\n            }\n\n            for (var i = 0; i < len; i += 2) {\n              swap(this, i, i + 1);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.swap32 = function swap32() {\n            var len = this.length;\n\n            if (len % 4 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 32-bits');\n            }\n\n            for (var i = 0; i < len; i += 4) {\n              swap(this, i, i + 3);\n              swap(this, i + 1, i + 2);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.swap64 = function swap64() {\n            var len = this.length;\n\n            if (len % 8 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 64-bits');\n            }\n\n            for (var i = 0; i < len; i += 8) {\n              swap(this, i, i + 7);\n              swap(this, i + 1, i + 6);\n              swap(this, i + 2, i + 5);\n              swap(this, i + 3, i + 4);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.toString = function toString() {\n            var length = this.length;\n            if (length === 0) return '';\n            if (arguments.length === 0) return utf8Slice(this, 0, length);\n            return slowToString.apply(this, arguments);\n          };\n\n          Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n          Buffer.prototype.equals = function equals(b) {\n            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n            if (this === b) return true;\n            return Buffer.compare(this, b) === 0;\n          };\n\n          Buffer.prototype.inspect = function inspect() {\n            var str = '';\n            var max = exports.INSPECT_MAX_BYTES;\n            str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n            if (this.length > max) str += ' ... ';\n            return '<Buffer ' + str + '>';\n          };\n\n          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n            if (isInstance(target, Uint8Array)) {\n              target = Buffer.from(target, target.offset, target.byteLength);\n            }\n\n            if (!Buffer.isBuffer(target)) {\n              throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);\n            }\n\n            if (start === undefined) {\n              start = 0;\n            }\n\n            if (end === undefined) {\n              end = target ? target.length : 0;\n            }\n\n            if (thisStart === undefined) {\n              thisStart = 0;\n            }\n\n            if (thisEnd === undefined) {\n              thisEnd = this.length;\n            }\n\n            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n              throw new RangeError('out of range index');\n            }\n\n            if (thisStart >= thisEnd && start >= end) {\n              return 0;\n            }\n\n            if (thisStart >= thisEnd) {\n              return -1;\n            }\n\n            if (start >= end) {\n              return 1;\n            }\n\n            start >>>= 0;\n            end >>>= 0;\n            thisStart >>>= 0;\n            thisEnd >>>= 0;\n            if (this === target) return 0;\n            var x = thisEnd - thisStart;\n            var y = end - start;\n            var len = Math.min(x, y);\n            var thisCopy = this.slice(thisStart, thisEnd);\n            var targetCopy = target.slice(start, end);\n\n            for (var i = 0; i < len; ++i) {\n              if (thisCopy[i] !== targetCopy[i]) {\n                x = thisCopy[i];\n                y = targetCopy[i];\n                break;\n              }\n            }\n\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n          //\n          // Arguments:\n          // - buffer - a Buffer to search\n          // - val - a string, Buffer, or number\n          // - byteOffset - an index into `buffer`; will be clamped to an int32\n          // - encoding - an optional encoding, relevant is val is a string\n          // - dir - true for indexOf, false for lastIndexOf\n\n\n          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n            // Empty buffer means no match\n            if (buffer.length === 0) return -1; // Normalize byteOffset\n\n            if (typeof byteOffset === 'string') {\n              encoding = byteOffset;\n              byteOffset = 0;\n            } else if (byteOffset > 0x7fffffff) {\n              byteOffset = 0x7fffffff;\n            } else if (byteOffset < -0x80000000) {\n              byteOffset = -0x80000000;\n            }\n\n            byteOffset = +byteOffset; // Coerce to Number.\n\n            if (numberIsNaN(byteOffset)) {\n              // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n              byteOffset = dir ? 0 : buffer.length - 1;\n            } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n            if (byteOffset >= buffer.length) {\n              if (dir) return -1;else byteOffset = buffer.length - 1;\n            } else if (byteOffset < 0) {\n              if (dir) byteOffset = 0;else return -1;\n            } // Normalize val\n\n\n            if (typeof val === 'string') {\n              val = Buffer.from(val, encoding);\n            } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n            if (Buffer.isBuffer(val)) {\n              // Special case: looking for empty string/buffer always fails\n              if (val.length === 0) {\n                return -1;\n              }\n\n              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n            } else if (typeof val === 'number') {\n              val = val & 0xFF; // Search for a byte value [0-255]\n\n              if (typeof Uint8Array.prototype.indexOf === 'function') {\n                if (dir) {\n                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n                } else {\n                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n                }\n              }\n\n              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n            }\n\n            throw new TypeError('val must be string, number or Buffer');\n          }\n\n          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n            var indexSize = 1;\n            var arrLength = arr.length;\n            var valLength = val.length;\n\n            if (encoding !== undefined) {\n              encoding = String(encoding).toLowerCase();\n\n              if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n                if (arr.length < 2 || val.length < 2) {\n                  return -1;\n                }\n\n                indexSize = 2;\n                arrLength /= 2;\n                valLength /= 2;\n                byteOffset /= 2;\n              }\n            }\n\n            function read(buf, i) {\n              if (indexSize === 1) {\n                return buf[i];\n              } else {\n                return buf.readUInt16BE(i * indexSize);\n              }\n            }\n\n            var i;\n\n            if (dir) {\n              var foundIndex = -1;\n\n              for (i = byteOffset; i < arrLength; i++) {\n                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                  if (foundIndex === -1) foundIndex = i;\n                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n                } else {\n                  if (foundIndex !== -1) i -= i - foundIndex;\n                  foundIndex = -1;\n                }\n              }\n            } else {\n              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n              for (i = byteOffset; i >= 0; i--) {\n                var found = true;\n\n                for (var j = 0; j < valLength; j++) {\n                  if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                  }\n                }\n\n                if (found) return i;\n              }\n            }\n\n            return -1;\n          }\n\n          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n            return this.indexOf(val, byteOffset, encoding) !== -1;\n          };\n\n          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n          };\n\n          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n          };\n\n          function hexWrite(buf, string, offset, length) {\n            offset = Number(offset) || 0;\n            var remaining = buf.length - offset;\n\n            if (!length) {\n              length = remaining;\n            } else {\n              length = Number(length);\n\n              if (length > remaining) {\n                length = remaining;\n              }\n            }\n\n            var strLen = string.length;\n\n            if (length > strLen / 2) {\n              length = strLen / 2;\n            }\n\n            for (var i = 0; i < length; ++i) {\n              var parsed = parseInt(string.substr(i * 2, 2), 16);\n              if (numberIsNaN(parsed)) return i;\n              buf[offset + i] = parsed;\n            }\n\n            return i;\n          }\n\n          function utf8Write(buf, string, offset, length) {\n            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n          }\n\n          function asciiWrite(buf, string, offset, length) {\n            return blitBuffer(asciiToBytes(string), buf, offset, length);\n          }\n\n          function latin1Write(buf, string, offset, length) {\n            return asciiWrite(buf, string, offset, length);\n          }\n\n          function base64Write(buf, string, offset, length) {\n            return blitBuffer(base64ToBytes(string), buf, offset, length);\n          }\n\n          function ucs2Write(buf, string, offset, length) {\n            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n          }\n\n          Buffer.prototype.write = function write(string, offset, length, encoding) {\n            // Buffer#write(string)\n            if (offset === undefined) {\n              encoding = 'utf8';\n              length = this.length;\n              offset = 0; // Buffer#write(string, encoding)\n            } else if (length === undefined && typeof offset === 'string') {\n              encoding = offset;\n              length = this.length;\n              offset = 0; // Buffer#write(string, offset[, length][, encoding])\n            } else if (isFinite(offset)) {\n              offset = offset >>> 0;\n\n              if (isFinite(length)) {\n                length = length >>> 0;\n                if (encoding === undefined) encoding = 'utf8';\n              } else {\n                encoding = length;\n                length = undefined;\n              }\n            } else {\n              throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n            }\n\n            var remaining = this.length - offset;\n            if (length === undefined || length > remaining) length = remaining;\n\n            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n              throw new RangeError('Attempt to write outside buffer bounds');\n            }\n\n            if (!encoding) encoding = 'utf8';\n            var loweredCase = false;\n\n            for (;;) {\n              switch (encoding) {\n                case 'hex':\n                  return hexWrite(this, string, offset, length);\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Write(this, string, offset, length);\n\n                case 'ascii':\n                  return asciiWrite(this, string, offset, length);\n\n                case 'latin1':\n                case 'binary':\n                  return latin1Write(this, string, offset, length);\n\n                case 'base64':\n                  // Warning: maxLength not taken into account in base64Write\n                  return base64Write(this, string, offset, length);\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return ucs2Write(this, string, offset, length);\n\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          };\n\n          Buffer.prototype.toJSON = function toJSON() {\n            return {\n              type: 'Buffer',\n              data: Array.prototype.slice.call(this._arr || this, 0)\n            };\n          };\n\n          function base64Slice(buf, start, end) {\n            if (start === 0 && end === buf.length) {\n              return base64.fromByteArray(buf);\n            } else {\n              return base64.fromByteArray(buf.slice(start, end));\n            }\n          }\n\n          function utf8Slice(buf, start, end) {\n            end = Math.min(buf.length, end);\n            var res = [];\n            var i = start;\n\n            while (i < end) {\n              var firstByte = buf[i];\n              var codePoint = null;\n              var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n              if (i + bytesPerSequence <= end) {\n                var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n                switch (bytesPerSequence) {\n                  case 1:\n                    if (firstByte < 0x80) {\n                      codePoint = firstByte;\n                    }\n\n                    break;\n\n                  case 2:\n                    secondByte = buf[i + 1];\n\n                    if ((secondByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n                      if (tempCodePoint > 0x7F) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                    break;\n\n                  case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                    break;\n\n                  case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                }\n              }\n\n              if (codePoint === null) {\n                // we did not generate a valid codePoint so insert a\n                // replacement char (U+FFFD) and advance only 1 byte\n                codePoint = 0xFFFD;\n                bytesPerSequence = 1;\n              } else if (codePoint > 0xFFFF) {\n                // encode to utf16 (surrogate pair dance)\n                codePoint -= 0x10000;\n                res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n                codePoint = 0xDC00 | codePoint & 0x3FF;\n              }\n\n              res.push(codePoint);\n              i += bytesPerSequence;\n            }\n\n            return decodeCodePointsArray(res);\n          } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n          // the lowest limit is Chrome, with 0x10000 args.\n          // We go 1 magnitude less, for safety\n\n\n          var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n          function decodeCodePointsArray(codePoints) {\n            var len = codePoints.length;\n\n            if (len <= MAX_ARGUMENTS_LENGTH) {\n              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n            } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n            var res = '';\n            var i = 0;\n\n            while (i < len) {\n              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n            }\n\n            return res;\n          }\n\n          function asciiSlice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i] & 0x7F);\n            }\n\n            return ret;\n          }\n\n          function latin1Slice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i]);\n            }\n\n            return ret;\n          }\n\n          function hexSlice(buf, start, end) {\n            var len = buf.length;\n            if (!start || start < 0) start = 0;\n            if (!end || end < 0 || end > len) end = len;\n            var out = '';\n\n            for (var i = start; i < end; ++i) {\n              out += toHex(buf[i]);\n            }\n\n            return out;\n          }\n\n          function utf16leSlice(buf, start, end) {\n            var bytes = buf.slice(start, end);\n            var res = '';\n\n            for (var i = 0; i < bytes.length; i += 2) {\n              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n            }\n\n            return res;\n          }\n\n          Buffer.prototype.slice = function slice(start, end) {\n            var len = this.length;\n            start = ~~start;\n            end = end === undefined ? len : ~~end;\n\n            if (start < 0) {\n              start += len;\n              if (start < 0) start = 0;\n            } else if (start > len) {\n              start = len;\n            }\n\n            if (end < 0) {\n              end += len;\n              if (end < 0) end = 0;\n            } else if (end > len) {\n              end = len;\n            }\n\n            if (end < start) end = start;\n            var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance\n\n            newBuf.__proto__ = Buffer.prototype;\n            return newBuf;\n          };\n          /*\n           * Need to make sure that buffer isn't trying to write out of bounds.\n           */\n\n\n          function checkOffset(offset, ext, length) {\n            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n          }\n\n          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n\n            return val;\n          };\n\n          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              checkOffset(offset, byteLength, this.length);\n            }\n\n            var val = this[offset + --byteLength];\n            var mul = 1;\n\n            while (byteLength > 0 && (mul *= 0x100)) {\n              val += this[offset + --byteLength] * mul;\n            }\n\n            return val;\n          };\n\n          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            return this[offset];\n          };\n\n          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] | this[offset + 1] << 8;\n          };\n\n          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] << 8 | this[offset + 1];\n          };\n\n          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n          };\n\n          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n          };\n\n          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n\n          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var i = byteLength;\n            var mul = 1;\n            var val = this[offset + --i];\n\n            while (i > 0 && (mul *= 0x100)) {\n              val += this[offset + --i] * mul;\n            }\n\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n\n          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            if (!(this[offset] & 0x80)) return this[offset];\n            return (0xff - this[offset] + 1) * -1;\n          };\n\n          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset] | this[offset + 1] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n\n          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset + 1] | this[offset] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n\n          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n          };\n\n          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n          };\n\n          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, true, 23, 4);\n          };\n\n          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, false, 23, 4);\n          };\n\n          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, true, 52, 8);\n          };\n\n          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, false, 52, 8);\n          };\n\n          function checkInt(buf, value, offset, ext, max, min) {\n            if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n            if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n          }\n\n          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n\n            var mul = 1;\n            var i = 0;\n            this[offset] = value & 0xFF;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n\n            var i = byteLength - 1;\n            var mul = 1;\n            this[offset + i] = value & 0xFF;\n\n            while (--i >= 0 && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n\n          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset + 3] = value >>> 24;\n            this[offset + 2] = value >>> 16;\n            this[offset + 1] = value >>> 8;\n            this[offset] = value & 0xff;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n\n            var i = 0;\n            var mul = 1;\n            var sub = 0;\n            this[offset] = value & 0xFF;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n                sub = 1;\n              }\n\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n\n            var i = byteLength - 1;\n            var mul = 1;\n            var sub = 0;\n            this[offset + i] = value & 0xFF;\n\n            while (--i >= 0 && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n                sub = 1;\n              }\n\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n            if (value < 0) value = 0xff + value + 1;\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n\n          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            this[offset + 2] = value >>> 16;\n            this[offset + 3] = value >>> 24;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            if (value < 0) value = 0xffffffff + value + 1;\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n\n          function checkIEEE754(buf, value, offset, ext, max, min) {\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n            if (offset < 0) throw new RangeError('Index out of range');\n          }\n\n          function writeFloat(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n            }\n\n            ieee754.write(buf, value, offset, littleEndian, 23, 4);\n            return offset + 4;\n          }\n\n          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, true, noAssert);\n          };\n\n          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, false, noAssert);\n          };\n\n          function writeDouble(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n            }\n\n            ieee754.write(buf, value, offset, littleEndian, 52, 8);\n            return offset + 8;\n          }\n\n          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, true, noAssert);\n          };\n\n          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, false, noAssert);\n          }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n          Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n            if (!start) start = 0;\n            if (!end && end !== 0) end = this.length;\n            if (targetStart >= target.length) targetStart = target.length;\n            if (!targetStart) targetStart = 0;\n            if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n            if (end === start) return 0;\n            if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n            if (targetStart < 0) {\n              throw new RangeError('targetStart out of bounds');\n            }\n\n            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n            if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n            if (end > this.length) end = this.length;\n\n            if (target.length - targetStart < end - start) {\n              end = target.length - targetStart + start;\n            }\n\n            var len = end - start;\n\n            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n              // Use built-in when available, missing from IE11\n              this.copyWithin(targetStart, start, end);\n            } else if (this === target && start < targetStart && targetStart < end) {\n              // descending copy from end\n              for (var i = len - 1; i >= 0; --i) {\n                target[i + targetStart] = this[i + start];\n              }\n            } else {\n              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n            }\n\n            return len;\n          }; // Usage:\n          //    buffer.fill(number[, offset[, end]])\n          //    buffer.fill(buffer[, offset[, end]])\n          //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n          Buffer.prototype.fill = function fill(val, start, end, encoding) {\n            // Handle string cases:\n            if (typeof val === 'string') {\n              if (typeof start === 'string') {\n                encoding = start;\n                start = 0;\n                end = this.length;\n              } else if (typeof end === 'string') {\n                encoding = end;\n                end = this.length;\n              }\n\n              if (encoding !== undefined && typeof encoding !== 'string') {\n                throw new TypeError('encoding must be a string');\n              }\n\n              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n                throw new TypeError('Unknown encoding: ' + encoding);\n              }\n\n              if (val.length === 1) {\n                var code = val.charCodeAt(0);\n\n                if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {\n                  // Fast path: If `val` fits into a single byte, use that numeric value.\n                  val = code;\n                }\n              }\n            } else if (typeof val === 'number') {\n              val = val & 255;\n            } // Invalid ranges are not set to a default, so can range check early.\n\n\n            if (start < 0 || this.length < start || this.length < end) {\n              throw new RangeError('Out of range index');\n            }\n\n            if (end <= start) {\n              return this;\n            }\n\n            start = start >>> 0;\n            end = end === undefined ? this.length : end >>> 0;\n            if (!val) val = 0;\n            var i;\n\n            if (typeof val === 'number') {\n              for (i = start; i < end; ++i) {\n                this[i] = val;\n              }\n            } else {\n              var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n              var len = bytes.length;\n\n              if (len === 0) {\n                throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n              }\n\n              for (i = 0; i < end - start; ++i) {\n                this[i + start] = bytes[i % len];\n              }\n            }\n\n            return this;\n          }; // HELPER FUNCTIONS\n          // ================\n\n\n          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n          function base64clean(str) {\n            // Node takes equal signs as end of the Base64 encoding\n            str = str.split('=')[0]; // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\n            str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n            if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n            while (str.length % 4 !== 0) {\n              str = str + '=';\n            }\n\n            return str;\n          }\n\n          function toHex(n) {\n            if (n < 16) return '0' + n.toString(16);\n            return n.toString(16);\n          }\n\n          function utf8ToBytes(string, units) {\n            units = units || Infinity;\n            var codePoint;\n            var length = string.length;\n            var leadSurrogate = null;\n            var bytes = [];\n\n            for (var i = 0; i < length; ++i) {\n              codePoint = string.charCodeAt(i); // is surrogate component\n\n              if (codePoint > 0xD7FF && codePoint < 0xE000) {\n                // last char was a lead\n                if (!leadSurrogate) {\n                  // no lead yet\n                  if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } // valid lead\n\n\n                  leadSurrogate = codePoint;\n                  continue;\n                } // 2 leads in a row\n\n\n                if (codePoint < 0xDC00) {\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  leadSurrogate = codePoint;\n                  continue;\n                } // valid surrogate pair\n\n\n                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n              } else if (leadSurrogate) {\n                // valid bmp char, but last char was a lead\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              }\n\n              leadSurrogate = null; // encode utf8\n\n              if (codePoint < 0x80) {\n                if ((units -= 1) < 0) break;\n                bytes.push(codePoint);\n              } else if (codePoint < 0x800) {\n                if ((units -= 2) < 0) break;\n                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x10000) {\n                if ((units -= 3) < 0) break;\n                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x110000) {\n                if ((units -= 4) < 0) break;\n                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else {\n                throw new Error('Invalid code point');\n              }\n            }\n\n            return bytes;\n          }\n\n          function asciiToBytes(str) {\n            var byteArray = [];\n\n            for (var i = 0; i < str.length; ++i) {\n              // Node's code seems to be doing this and not & 0x7F..\n              byteArray.push(str.charCodeAt(i) & 0xFF);\n            }\n\n            return byteArray;\n          }\n\n          function utf16leToBytes(str, units) {\n            var c, hi, lo;\n            var byteArray = [];\n\n            for (var i = 0; i < str.length; ++i) {\n              if ((units -= 2) < 0) break;\n              c = str.charCodeAt(i);\n              hi = c >> 8;\n              lo = c % 256;\n              byteArray.push(lo);\n              byteArray.push(hi);\n            }\n\n            return byteArray;\n          }\n\n          function base64ToBytes(str) {\n            return base64.toByteArray(base64clean(str));\n          }\n\n          function blitBuffer(src, dst, offset, length) {\n            for (var i = 0; i < length; ++i) {\n              if (i + offset >= dst.length || i >= src.length) break;\n              dst[i + offset] = src[i];\n            }\n\n            return i;\n          } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n          // the `instanceof` check but they should be treated as of that type.\n          // See: https://github.com/feross/buffer/issues/166\n\n\n          function isInstance(obj, type) {\n            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n          }\n\n          function numberIsNaN(obj) {\n            // For IE11 support\n            return obj !== obj; // eslint-disable-line no-self-compare\n          }\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"base64-js\": 1,\n      \"buffer\": 3,\n      \"ieee754\": 5\n    }],\n    4: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict';\n\n      var R = typeof Reflect === 'object' ? Reflect : null;\n      var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n        return Function.prototype.apply.call(target, receiver, args);\n      };\n      var ReflectOwnKeys;\n\n      if (R && typeof R.ownKeys === 'function') {\n        ReflectOwnKeys = R.ownKeys;\n      } else if (Object.getOwnPropertySymbols) {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n        };\n      } else {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n          return Object.getOwnPropertyNames(target);\n        };\n      }\n\n      function ProcessEmitWarning(warning) {\n        if (console && console.warn) console.warn(warning);\n      }\n\n      var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n        return value !== value;\n      };\n\n      function EventEmitter() {\n        EventEmitter.init.call(this);\n      }\n\n      module.exports = EventEmitter;\n      module.exports.once = once; // Backwards-compat with node 0.10.x\n\n      EventEmitter.EventEmitter = EventEmitter;\n      EventEmitter.prototype._events = undefined;\n      EventEmitter.prototype._eventsCount = 0;\n      EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n      // added to it. This is a useful default which helps finding memory leaks.\n\n      var defaultMaxListeners = 10;\n\n      function checkListener(listener) {\n        if (typeof listener !== 'function') {\n          throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n        }\n      }\n\n      Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n        enumerable: true,\n        get: function () {\n          return defaultMaxListeners;\n        },\n        set: function (arg) {\n          if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n            throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n          }\n\n          defaultMaxListeners = arg;\n        }\n      });\n\n      EventEmitter.init = function () {\n        if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        }\n\n        this._maxListeners = this._maxListeners || undefined;\n      }; // Obviously not all Emitters should be limited to 10. This function allows\n      // that to be increased. Set to zero for unlimited.\n\n\n      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n        if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n          throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n        }\n\n        this._maxListeners = n;\n        return this;\n      };\n\n      function _getMaxListeners(that) {\n        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n        return that._maxListeners;\n      }\n\n      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n        return _getMaxListeners(this);\n      };\n\n      EventEmitter.prototype.emit = function emit(type) {\n        var args = [];\n\n        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n\n        var doError = type === 'error';\n        var events = this._events;\n        if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n        if (doError) {\n          var er;\n          if (args.length > 0) er = args[0];\n\n          if (er instanceof Error) {\n            // Note: The comments on the `throw` lines are intentional, they show\n            // up in Node's output if this results in an unhandled exception.\n            throw er; // Unhandled 'error' event\n          } // At least give some kind of context to the user\n\n\n          var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n          err.context = er;\n          throw err; // Unhandled 'error' event\n        }\n\n        var handler = events[type];\n        if (handler === undefined) return false;\n\n        if (typeof handler === 'function') {\n          ReflectApply(handler, this, args);\n        } else {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n\n          for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n        }\n\n        return true;\n      };\n\n      function _addListener(target, type, listener, prepend) {\n        var m;\n        var events;\n        var existing;\n        checkListener(listener);\n        events = target._events;\n\n        if (events === undefined) {\n          events = target._events = Object.create(null);\n          target._eventsCount = 0;\n        } else {\n          // To avoid recursion in the case that type === \"newListener\"! Before\n          // adding it to the listeners, first emit \"newListener\".\n          if (events.newListener !== undefined) {\n            target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n\n            events = target._events;\n          }\n\n          existing = events[type];\n        }\n\n        if (existing === undefined) {\n          // Optimize the case of one listener. Don't need the extra array object.\n          existing = events[type] = listener;\n          ++target._eventsCount;\n        } else {\n          if (typeof existing === 'function') {\n            // Adding the second element, need to change to array.\n            existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n          } else if (prepend) {\n            existing.unshift(listener);\n          } else {\n            existing.push(listener);\n          } // Check for listener leak\n\n\n          m = _getMaxListeners(target);\n\n          if (m > 0 && existing.length > m && !existing.warned) {\n            existing.warned = true; // No error code for this since it is a Warning\n            // eslint-disable-next-line no-restricted-syntax\n\n            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n            w.name = 'MaxListenersExceededWarning';\n            w.emitter = target;\n            w.type = type;\n            w.count = existing.length;\n            ProcessEmitWarning(w);\n          }\n        }\n\n        return target;\n      }\n\n      EventEmitter.prototype.addListener = function addListener(type, listener) {\n        return _addListener(this, type, listener, false);\n      };\n\n      EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n      EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n        return _addListener(this, type, listener, true);\n      };\n\n      function onceWrapper() {\n        if (!this.fired) {\n          this.target.removeListener(this.type, this.wrapFn);\n          this.fired = true;\n          if (arguments.length === 0) return this.listener.call(this.target);\n          return this.listener.apply(this.target, arguments);\n        }\n      }\n\n      function _onceWrap(target, type, listener) {\n        var state = {\n          fired: false,\n          wrapFn: undefined,\n          target: target,\n          type: type,\n          listener: listener\n        };\n        var wrapped = onceWrapper.bind(state);\n        wrapped.listener = listener;\n        state.wrapFn = wrapped;\n        return wrapped;\n      }\n\n      EventEmitter.prototype.once = function once(type, listener) {\n        checkListener(listener);\n        this.on(type, _onceWrap(this, type, listener));\n        return this;\n      };\n\n      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n        checkListener(listener);\n        this.prependListener(type, _onceWrap(this, type, listener));\n        return this;\n      }; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\n      EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n        var list, events, position, i, originalListener;\n        checkListener(listener);\n        events = this._events;\n        if (events === undefined) return this;\n        list = events[type];\n        if (list === undefined) return this;\n\n        if (list === listener || list.listener === listener) {\n          if (--this._eventsCount === 0) this._events = Object.create(null);else {\n            delete events[type];\n            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n          }\n        } else if (typeof list !== 'function') {\n          position = -1;\n\n          for (i = list.length - 1; i >= 0; i--) {\n            if (list[i] === listener || list[i].listener === listener) {\n              originalListener = list[i].listener;\n              position = i;\n              break;\n            }\n          }\n\n          if (position < 0) return this;\n          if (position === 0) list.shift();else {\n            spliceOne(list, position);\n          }\n          if (list.length === 1) events[type] = list[0];\n          if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n        }\n\n        return this;\n      };\n\n      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n        var listeners, events, i;\n        events = this._events;\n        if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n        if (events.removeListener === undefined) {\n          if (arguments.length === 0) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n          } else if (events[type] !== undefined) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n          }\n\n          return this;\n        } // emit removeListener for all listeners on all events\n\n\n        if (arguments.length === 0) {\n          var keys = Object.keys(events);\n          var key;\n\n          for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n          }\n\n          this.removeAllListeners('removeListener');\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n          return this;\n        }\n\n        listeners = events[type];\n\n        if (typeof listeners === 'function') {\n          this.removeListener(type, listeners);\n        } else if (listeners !== undefined) {\n          // LIFO order\n          for (i = listeners.length - 1; i >= 0; i--) {\n            this.removeListener(type, listeners[i]);\n          }\n        }\n\n        return this;\n      };\n\n      function _listeners(target, type, unwrap) {\n        var events = target._events;\n        if (events === undefined) return [];\n        var evlistener = events[type];\n        if (evlistener === undefined) return [];\n        if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n      }\n\n      EventEmitter.prototype.listeners = function listeners(type) {\n        return _listeners(this, type, true);\n      };\n\n      EventEmitter.prototype.rawListeners = function rawListeners(type) {\n        return _listeners(this, type, false);\n      };\n\n      EventEmitter.listenerCount = function (emitter, type) {\n        if (typeof emitter.listenerCount === 'function') {\n          return emitter.listenerCount(type);\n        } else {\n          return listenerCount.call(emitter, type);\n        }\n      };\n\n      EventEmitter.prototype.listenerCount = listenerCount;\n\n      function listenerCount(type) {\n        var events = this._events;\n\n        if (events !== undefined) {\n          var evlistener = events[type];\n\n          if (typeof evlistener === 'function') {\n            return 1;\n          } else if (evlistener !== undefined) {\n            return evlistener.length;\n          }\n        }\n\n        return 0;\n      }\n\n      EventEmitter.prototype.eventNames = function eventNames() {\n        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n      };\n\n      function arrayClone(arr, n) {\n        var copy = new Array(n);\n\n        for (var i = 0; i < n; ++i) copy[i] = arr[i];\n\n        return copy;\n      }\n\n      function spliceOne(list, index) {\n        for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n\n        list.pop();\n      }\n\n      function unwrapListeners(arr) {\n        var ret = new Array(arr.length);\n\n        for (var i = 0; i < ret.length; ++i) {\n          ret[i] = arr[i].listener || arr[i];\n        }\n\n        return ret;\n      }\n\n      function once(emitter, name) {\n        return new Promise(function (resolve, reject) {\n          function errorListener(err) {\n            emitter.removeListener(name, resolver);\n            reject(err);\n          }\n\n          function resolver() {\n            if (typeof emitter.removeListener === 'function') {\n              emitter.removeListener('error', errorListener);\n            }\n\n            resolve([].slice.call(arguments));\n          }\n\n          ;\n          eventTargetAgnosticAddListener(emitter, name, resolver, {\n            once: true\n          });\n\n          if (name !== 'error') {\n            addErrorHandlerIfEventEmitter(emitter, errorListener, {\n              once: true\n            });\n          }\n        });\n      }\n\n      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n        if (typeof emitter.on === 'function') {\n          eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n        }\n      }\n\n      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n        if (typeof emitter.on === 'function') {\n          if (flags.once) {\n            emitter.once(name, listener);\n          } else {\n            emitter.on(name, listener);\n          }\n        } else if (typeof emitter.addEventListener === 'function') {\n          // EventTarget does not have `error` event semantics like Node\n          // EventEmitters, we do not listen for `error` events here.\n          emitter.addEventListener(name, function wrapListener(arg) {\n            // IE does not have builtin `{ once: true }` support so we\n            // have to do it manually.\n            if (flags.once) {\n              emitter.removeEventListener(name, wrapListener);\n            }\n\n            listener(arg);\n          });\n        } else {\n          throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n        }\n      }\n    }, {}],\n    5: [function (require, module, exports) {\n      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n        i += d;\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n    }, {}],\n    6: [function (require, module, exports) {\n      /*!\n       * Determine if an object is a Buffer\n       *\n       * @author   Feross Aboukhadijeh <https://feross.org>\n       * @license  MIT\n       */\n      // The _isBuffer check is for Safari 5-7 support, because it's missing\n      // Object.prototype.constructor. Remove this eventually\n      module.exports = function (obj) {\n        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n      };\n\n      function isBuffer(obj) {\n        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n      } // For Node v0.10 support. Remove this eventually.\n\n\n      function isSlowBuffer(obj) {\n        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n      }\n    }, {}],\n    7: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          'use strict';\n          /**\n           * Module dependencies\n           */\n\n          var EventEmitter = require('events').EventEmitter;\n\n          var Store = require('./store');\n\n          var mqttPacket = require('mqtt-packet');\n\n          var Writable = require('readable-stream').Writable;\n\n          var inherits = require('inherits');\n\n          var reInterval = require('reinterval');\n\n          var validations = require('./validations');\n\n          var xtend = require('xtend');\n\n          var debug = require('debug')('mqttjs:client');\n\n          var nextTick = process ? process.nextTick : function (callback) {\n            setTimeout(callback, 0);\n          };\n\n          var setImmediate = global.setImmediate || function (callback) {\n            // works in node v0.8\n            nextTick(callback);\n          };\n\n          var defaultConnectOptions = {\n            keepalive: 60,\n            reschedulePings: true,\n            protocolId: 'MQTT',\n            protocolVersion: 4,\n            reconnectPeriod: 1000,\n            connectTimeout: 30 * 1000,\n            clean: true,\n            resubscribe: true\n          };\n          var socketErrors = ['ECONNREFUSED', 'EADDRINUSE', 'ECONNRESET', 'ENOTFOUND']; // Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\n          var errors = {\n            0: '',\n            1: 'Unacceptable protocol version',\n            2: 'Identifier rejected',\n            3: 'Server unavailable',\n            4: 'Bad username or password',\n            5: 'Not authorized',\n            16: 'No matching subscribers',\n            17: 'No subscription existed',\n            128: 'Unspecified error',\n            129: 'Malformed Packet',\n            130: 'Protocol Error',\n            131: 'Implementation specific error',\n            132: 'Unsupported Protocol Version',\n            133: 'Client Identifier not valid',\n            134: 'Bad User Name or Password',\n            135: 'Not authorized',\n            136: 'Server unavailable',\n            137: 'Server busy',\n            138: 'Banned',\n            139: 'Server shutting down',\n            140: 'Bad authentication method',\n            141: 'Keep Alive timeout',\n            142: 'Session taken over',\n            143: 'Topic Filter invalid',\n            144: 'Topic Name invalid',\n            145: 'Packet identifier in use',\n            146: 'Packet Identifier not found',\n            147: 'Receive Maximum exceeded',\n            148: 'Topic Alias invalid',\n            149: 'Packet too large',\n            150: 'Message rate too high',\n            151: 'Quota exceeded',\n            152: 'Administrative action',\n            153: 'Payload format invalid',\n            154: 'Retain not supported',\n            155: 'QoS not supported',\n            156: 'Use another server',\n            157: 'Server moved',\n            158: 'Shared Subscriptions not supported',\n            159: 'Connection rate exceeded',\n            160: 'Maximum connect time',\n            161: 'Subscription Identifiers not supported',\n            162: 'Wildcard Subscriptions not supported'\n          };\n\n          function defaultId() {\n            return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n          }\n\n          function sendPacket(client, packet, cb) {\n            debug('sendPacket :: packet: %O', packet);\n            debug('sendPacket :: emitting `packetsend`');\n            client.emit('packetsend', packet);\n            debug('sendPacket :: writing to stream');\n            var result = mqttPacket.writeToStream(packet, client.stream, client.options);\n            debug('sendPacket :: writeToStream result %s', result);\n\n            if (!result && cb) {\n              debug('sendPacket :: handle events on `drain` once through callback.');\n              client.stream.once('drain', cb);\n            } else if (cb) {\n              debug('sendPacket :: invoking cb');\n              cb();\n            }\n          }\n\n          function flush(queue) {\n            if (queue) {\n              debug('flush: queue exists? %b', !!queue);\n              Object.keys(queue).forEach(function (messageId) {\n                if (typeof queue[messageId].cb === 'function') {\n                  queue[messageId].cb(new Error('Connection closed'));\n                  delete queue[messageId];\n                }\n              });\n            }\n          }\n\n          function flushVolatile(queue) {\n            if (queue) {\n              debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n              Object.keys(queue).forEach(function (messageId) {\n                if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n                  queue[messageId].cb(new Error('Connection closed'));\n                  delete queue[messageId];\n                }\n              });\n            }\n          }\n\n          function storeAndSend(client, packet, cb, cbStorePut) {\n            debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n            client.outgoingStore.put(packet, function storedPacket(err) {\n              if (err) {\n                return cb && cb(err);\n              }\n\n              cbStorePut();\n              sendPacket(client, packet, cb);\n            });\n          }\n\n          function nop(error) {\n            debug('nop ::', error);\n          }\n          /**\n           * MqttClient constructor\n           *\n           * @param {Stream} stream - stream\n           * @param {Object} [options] - connection options\n           * (see Connection#connect)\n           */\n\n\n          function MqttClient(streamBuilder, options) {\n            var k;\n            var that = this;\n\n            if (!(this instanceof MqttClient)) {\n              return new MqttClient(streamBuilder, options);\n            }\n\n            this.options = options || {}; // Defaults\n\n            for (k in defaultConnectOptions) {\n              if (typeof this.options[k] === 'undefined') {\n                this.options[k] = defaultConnectOptions[k];\n              } else {\n                this.options[k] = options[k];\n              }\n            }\n\n            debug('MqttClient :: options.protocol', options.protocol);\n            debug('MqttClient :: options.protocolVersion', options.protocolVersion);\n            debug('MqttClient :: options.username', options.username);\n            debug('MqttClient :: options.keepalive', options.keepalive);\n            debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n            debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n            this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n            debug('MqttClient :: clientId', this.options.clientId);\n            this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n              arguments[3](0);\n            };\n            this.streamBuilder = streamBuilder; // Inflight message storages\n\n            this.outgoingStore = options.outgoingStore || new Store();\n            this.incomingStore = options.incomingStore || new Store(); // Should QoS zero messages be queued when the connection is broken?\n\n            this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero; // map of subscribed topics to support reconnection\n\n            this._resubscribeTopics = {}; // map of a subscribe messageId and a topic\n\n            this.messageIdToTopic = {}; // Ping timer, setup in _setupPingTimer\n\n            this.pingTimer = null; // Is the client connected?\n\n            this.connected = false; // Are we disconnecting?\n\n            this.disconnecting = false; // Packet queue\n\n            this.queue = []; // connack timer\n\n            this.connackTimer = null; // Reconnect timer\n\n            this.reconnectTimer = null; // Is processing store?\n\n            this._storeProcessing = false; // Packet Ids are put into the store during store processing\n\n            this._packetIdsDuringStoreProcessing = {};\n            /**\n             * MessageIDs starting with 1\n             * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n             */\n\n            this.nextId = Math.max(1, Math.floor(Math.random() * 65535)); // Inflight callbacks\n\n            this.outgoing = {}; // True if connection is first time.\n\n            this._firstConnection = true; // Send queued packets\n\n            this.on('connect', function () {\n              var queue = this.queue;\n\n              function deliver() {\n                var entry = queue.shift();\n                debug('deliver :: entry %o', entry);\n                var packet = null;\n\n                if (!entry) {\n                  return;\n                }\n\n                packet = entry.packet;\n                debug('deliver :: call _sendPacket for %o', packet);\n\n                that._sendPacket(packet, function (err) {\n                  if (entry.cb) {\n                    entry.cb(err);\n                  }\n\n                  deliver();\n                });\n              }\n\n              debug('connect :: sending queued packets');\n              deliver();\n            });\n            this.on('close', function () {\n              debug('close :: connected set to `false`');\n              this.connected = false;\n              debug('close :: clearing connackTimer');\n              clearTimeout(this.connackTimer);\n              debug('close :: clearing ping timer');\n\n              if (that.pingTimer !== null) {\n                that.pingTimer.clear();\n                that.pingTimer = null;\n              }\n\n              debug('close :: calling _setupReconnect');\n\n              this._setupReconnect();\n            });\n            EventEmitter.call(this);\n            debug('MqttClient :: setting up stream');\n\n            this._setupStream();\n          }\n\n          inherits(MqttClient, EventEmitter);\n          /**\n           * setup the event handlers in the inner stream.\n           *\n           * @api private\n           */\n\n          MqttClient.prototype._setupStream = function () {\n            var connectPacket;\n            var that = this;\n            var writable = new Writable();\n            var parser = mqttPacket.parser(this.options);\n            var completeParse = null;\n            var packets = [];\n            debug('_setupStream :: calling method to clear reconnect');\n\n            this._clearReconnect();\n\n            debug('_setupStream :: using streamBuilder provided to client to create stream');\n            this.stream = this.streamBuilder(this);\n            parser.on('packet', function (packet) {\n              debug('parser :: on packet push to packets array.');\n              packets.push(packet);\n            });\n\n            function nextTickWork() {\n              if (packets.length) {\n                nextTick(work);\n              } else {\n                var done = completeParse;\n                completeParse = null;\n                done();\n              }\n            }\n\n            function work() {\n              debug('work :: getting next packet in queue');\n              var packet = packets.shift();\n\n              if (packet) {\n                debug('work :: packet pulled from queue');\n\n                that._handlePacket(packet, nextTickWork);\n              } else {\n                debug('work :: no packets in queue');\n                var done = completeParse;\n                completeParse = null;\n                debug('work :: done flag is %s', !!done);\n                if (done) done();\n              }\n            }\n\n            writable._write = function (buf, enc, done) {\n              completeParse = done;\n              debug('writable stream :: parsing buffer');\n              parser.parse(buf);\n              work();\n            };\n\n            function streamErrorHandler(error) {\n              debug('streamErrorHandler :: error', error.message);\n\n              if (socketErrors.includes(error.code)) {\n                // handle error\n                debug('streamErrorHandler :: emitting error');\n                that.emit('error', error);\n              } else {\n                nop(error);\n              }\n            }\n\n            debug('_setupStream :: pipe stream to writable stream');\n            this.stream.pipe(writable); // Suppress connection errors\n\n            this.stream.on('error', streamErrorHandler); // Echo stream close\n\n            this.stream.on('close', function () {\n              debug('(%s)stream :: on close', that.options.clientId);\n              flushVolatile(that.outgoing);\n              debug('stream: emit close to MqttClient');\n              that.emit('close');\n            }); // Send a connect packet\n\n            debug('_setupStream: sending packet `connect`');\n            connectPacket = Object.create(this.options);\n            connectPacket.cmd = 'connect'; // avoid message queue\n\n            sendPacket(this, connectPacket); // Echo connection errors\n\n            parser.on('error', this.emit.bind(this, 'error')); // auth\n\n            if (this.options.properties) {\n              if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n                that.end(() => this.emit('error', new Error('Packet has no Authentication Method')));\n                return this;\n              }\n\n              if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n                var authPacket = xtend({\n                  cmd: 'auth',\n                  reasonCode: 0\n                }, this.options.authPacket);\n                sendPacket(this, authPacket);\n              }\n            } // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n\n\n            this.stream.setMaxListeners(1000);\n            clearTimeout(this.connackTimer);\n            this.connackTimer = setTimeout(function () {\n              debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n\n              that._cleanUp(true);\n            }, this.options.connectTimeout);\n          };\n\n          MqttClient.prototype._handlePacket = function (packet, done) {\n            var options = this.options;\n\n            if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n              this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n              this.end({\n                reasonCode: 149,\n                properties: {\n                  reasonString: 'Maximum packet size was exceeded'\n                }\n              });\n              return this;\n            }\n\n            debug('_handlePacket :: emitting packetreceive');\n            this.emit('packetreceive', packet);\n\n            switch (packet.cmd) {\n              case 'publish':\n                this._handlePublish(packet, done);\n\n                break;\n\n              case 'puback':\n              case 'pubrec':\n              case 'pubcomp':\n              case 'suback':\n              case 'unsuback':\n                this._handleAck(packet);\n\n                done();\n                break;\n\n              case 'pubrel':\n                this._handlePubrel(packet, done);\n\n                break;\n\n              case 'connack':\n                this._handleConnack(packet);\n\n                done();\n                break;\n\n              case 'pingresp':\n                this._handlePingresp(packet);\n\n                done();\n                break;\n\n              case 'disconnect':\n                this._handleDisconnect(packet);\n\n                done();\n                break;\n\n              default:\n                // do nothing\n                // maybe we should do an error handling\n                // or just log it\n                break;\n            }\n          };\n\n          MqttClient.prototype._checkDisconnecting = function (callback) {\n            if (this.disconnecting) {\n              if (callback) {\n                callback(new Error('client disconnecting'));\n              } else {\n                this.emit('error', new Error('client disconnecting'));\n              }\n            }\n\n            return this.disconnecting;\n          };\n          /**\n           * publish - publish <message> to <topic>\n           *\n           * @param {String} topic - topic to publish to\n           * @param {String, Buffer} message - message to publish\n           * @param {Object} [opts] - publish options, includes:\n           *    {Number} qos - qos level to publish on\n           *    {Boolean} retain - whether or not to retain the message\n           *    {Boolean} dup - whether or not mark a message as duplicate\n           *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n           * @param {Function} [callback] - function(err){}\n           *    called when publish succeeds or fails\n           * @returns {MqttClient} this - for chaining\n           * @api public\n           *\n           * @example client.publish('topic', 'message');\n           * @example\n           *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n           * @example client.publish('topic', 'message', console.log);\n           */\n\n\n          MqttClient.prototype.publish = function (topic, message, opts, callback) {\n            debug('publish :: message `%s` to topic `%s`', message, topic);\n            var packet;\n            var options = this.options; // .publish(topic, payload, cb);\n\n            if (typeof opts === 'function') {\n              callback = opts;\n              opts = null;\n            } // default opts\n\n\n            var defaultOpts = {\n              qos: 0,\n              retain: false,\n              dup: false\n            };\n            opts = xtend(defaultOpts, opts);\n\n            if (this._checkDisconnecting(callback)) {\n              return this;\n            }\n\n            packet = {\n              cmd: 'publish',\n              topic: topic,\n              payload: message,\n              qos: opts.qos,\n              retain: opts.retain,\n              messageId: this._nextId(),\n              dup: opts.dup\n            };\n\n            if (options.protocolVersion === 5) {\n              packet.properties = opts.properties;\n\n              if (!options.properties && packet.properties && packet.properties.topicAlias || opts.properties && options.properties && (opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum || !options.properties.topicAliasMaximum && opts.properties.topicAlias)) {\n                /*\n                if we are don`t setup topic alias or\n                topic alias maximum less than topic alias or\n                server don`t give topic alias maximum,\n                we are removing topic alias from packet\n                */\n                delete packet.properties.topicAlias;\n              }\n            }\n\n            debug('publish :: qos', opts.qos);\n\n            switch (opts.qos) {\n              case 1:\n              case 2:\n                // Add to callbacks\n                this.outgoing[packet.messageId] = {\n                  volatile: false,\n                  cb: callback || nop\n                };\n\n                if (this._storeProcessing) {\n                  debug('_storeProcessing enabled');\n                  this._packetIdsDuringStoreProcessing[packet.messageId] = false;\n\n                  this._storePacket(packet, undefined, opts.cbStorePut);\n                } else {\n                  debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n                  this._sendPacket(packet, undefined, opts.cbStorePut);\n                }\n\n                break;\n\n              default:\n                if (this._storeProcessing) {\n                  debug('_storeProcessing enabled');\n\n                  this._storePacket(packet, callback, opts.cbStorePut);\n                } else {\n                  debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n                  this._sendPacket(packet, callback, opts.cbStorePut);\n                }\n\n                break;\n            }\n\n            return this;\n          };\n          /**\n           * subscribe - subscribe to <topic>\n           *\n           * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n           * @param {Object} [opts] - optional subscription options, includes:\n           *    {Number} qos - subscribe qos level\n           * @param {Function} [callback] - function(err, granted){} where:\n           *    {Error} err - subscription error (none at the moment!)\n           *    {Array} granted - array of {topic: 't', qos: 0}\n           * @returns {MqttClient} this - for chaining\n           * @api public\n           * @example client.subscribe('topic');\n           * @example client.subscribe('topic', {qos: 1});\n           * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n           * @example client.subscribe('topic', console.log);\n           */\n\n\n          MqttClient.prototype.subscribe = function () {\n            var packet;\n            var args = new Array(arguments.length);\n\n            for (var i = 0; i < arguments.length; i++) {\n              args[i] = arguments[i];\n            }\n\n            var subs = [];\n            var obj = args.shift();\n            var resubscribe = obj.resubscribe;\n            var callback = args.pop() || nop;\n            var opts = args.pop();\n            var invalidTopic;\n            var that = this;\n            var version = this.options.protocolVersion;\n            delete obj.resubscribe;\n\n            if (typeof obj === 'string') {\n              obj = [obj];\n            }\n\n            if (typeof callback !== 'function') {\n              opts = callback;\n              callback = nop;\n            }\n\n            invalidTopic = validations.validateTopics(obj);\n\n            if (invalidTopic !== null) {\n              setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n              return this;\n            }\n\n            if (this._checkDisconnecting(callback)) {\n              debug('subscribe: discconecting true');\n              return this;\n            }\n\n            var defaultOpts = {\n              qos: 0\n            };\n\n            if (version === 5) {\n              defaultOpts.nl = false;\n              defaultOpts.rap = false;\n              defaultOpts.rh = 0;\n            }\n\n            opts = xtend(defaultOpts, opts);\n\n            if (Array.isArray(obj)) {\n              obj.forEach(function (topic) {\n                debug('subscribe: array topic %s', topic);\n\n                if (!that._resubscribeTopics.hasOwnProperty(topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n                  var currentOpts = {\n                    topic: topic,\n                    qos: opts.qos\n                  };\n\n                  if (version === 5) {\n                    currentOpts.nl = opts.nl;\n                    currentOpts.rap = opts.rap;\n                    currentOpts.rh = opts.rh;\n                    currentOpts.properties = opts.properties;\n                  }\n\n                  debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n                  subs.push(currentOpts);\n                }\n              });\n            } else {\n              Object.keys(obj).forEach(function (k) {\n                debug('subscribe: object topic %s', k);\n\n                if (!that._resubscribeTopics.hasOwnProperty(k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n                  var currentOpts = {\n                    topic: k,\n                    qos: obj[k].qos\n                  };\n\n                  if (version === 5) {\n                    currentOpts.nl = obj[k].nl;\n                    currentOpts.rap = obj[k].rap;\n                    currentOpts.rh = obj[k].rh;\n                    currentOpts.properties = opts.properties;\n                  }\n\n                  debug('subscribe: pushing `%s` to subs list', currentOpts);\n                  subs.push(currentOpts);\n                }\n              });\n            }\n\n            packet = {\n              cmd: 'subscribe',\n              subscriptions: subs,\n              qos: 1,\n              retain: false,\n              dup: false,\n              messageId: this._nextId()\n            };\n\n            if (opts.properties) {\n              packet.properties = opts.properties;\n            }\n\n            if (!subs.length) {\n              callback(null, []);\n              return;\n            } // subscriptions to resubscribe to in case of disconnect\n\n\n            if (this.options.resubscribe) {\n              debug('subscribe :: resubscribe true');\n              var topics = [];\n              subs.forEach(function (sub) {\n                if (that.options.reconnectPeriod > 0) {\n                  var topic = {\n                    qos: sub.qos\n                  };\n\n                  if (version === 5) {\n                    topic.nl = sub.nl || false;\n                    topic.rap = sub.rap || false;\n                    topic.rh = sub.rh || 0;\n                    topic.properties = sub.properties;\n                  }\n\n                  that._resubscribeTopics[sub.topic] = topic;\n                  topics.push(sub.topic);\n                }\n              });\n              that.messageIdToTopic[packet.messageId] = topics;\n            }\n\n            this.outgoing[packet.messageId] = {\n              volatile: true,\n              cb: function (err, packet) {\n                if (!err) {\n                  var granted = packet.granted;\n\n                  for (var i = 0; i < granted.length; i += 1) {\n                    subs[i].qos = granted[i];\n                  }\n                }\n\n                callback(err, subs);\n              }\n            };\n            debug('subscribe :: call _sendPacket');\n\n            this._sendPacket(packet);\n\n            return this;\n          };\n          /**\n           * unsubscribe - unsubscribe from topic(s)\n           *\n           * @param {String, Array} topic - topics to unsubscribe from\n           * @param {Object} [opts] - optional subscription options, includes:\n           *    {Object} properties - properties of unsubscribe packet\n           * @param {Function} [callback] - callback fired on unsuback\n           * @returns {MqttClient} this - for chaining\n           * @api public\n           * @example client.unsubscribe('topic');\n           * @example client.unsubscribe('topic', console.log);\n           */\n\n\n          MqttClient.prototype.unsubscribe = function () {\n            var packet = {\n              cmd: 'unsubscribe',\n              qos: 1,\n              messageId: this._nextId()\n            };\n            var that = this;\n            var args = new Array(arguments.length);\n\n            for (var i = 0; i < arguments.length; i++) {\n              args[i] = arguments[i];\n            }\n\n            var topic = args.shift();\n            var callback = args.pop() || nop;\n            var opts = args.pop();\n\n            if (typeof topic === 'string') {\n              topic = [topic];\n            }\n\n            if (typeof callback !== 'function') {\n              opts = callback;\n              callback = nop;\n            }\n\n            if (this._checkDisconnecting(callback)) {\n              return this;\n            }\n\n            if (typeof topic === 'string') {\n              packet.unsubscriptions = [topic];\n            } else if (Array.isArray(topic)) {\n              packet.unsubscriptions = topic;\n            }\n\n            if (this.options.resubscribe) {\n              packet.unsubscriptions.forEach(function (topic) {\n                delete that._resubscribeTopics[topic];\n              });\n            }\n\n            if (typeof opts === 'object' && opts.properties) {\n              packet.properties = opts.properties;\n            }\n\n            this.outgoing[packet.messageId] = {\n              volatile: true,\n              cb: callback\n            };\n            debug('unsubscribe: call _sendPacket');\n\n            this._sendPacket(packet);\n\n            return this;\n          };\n          /**\n           * end - close connection\n           *\n           * @returns {MqttClient} this - for chaining\n           * @param {Boolean} force - do not wait for all in-flight messages to be acked\n           * @param {Object} opts - added to the disconnect packet\n           * @param {Function} cb - called when the client has been closed\n           *\n           * @api public\n           */\n\n\n          MqttClient.prototype.end = function (force, opts, cb) {\n            var that = this;\n            debug('end :: (%s)', this.options.clientId);\n\n            if (force == null || typeof force !== 'boolean') {\n              cb = opts || nop;\n              opts = force;\n              force = false;\n\n              if (typeof opts !== 'object') {\n                cb = opts;\n                opts = null;\n\n                if (typeof cb !== 'function') {\n                  cb = nop;\n                }\n              }\n            }\n\n            if (typeof opts !== 'object') {\n              cb = opts;\n              opts = null;\n            }\n\n            debug('end :: cb? %s', !!cb);\n            cb = cb || nop;\n\n            function closeStores() {\n              debug('end :: closeStores: closing incoming and outgoing stores');\n              that.disconnected = true;\n              that.incomingStore.close(function (e1) {\n                that.outgoingStore.close(function (e2) {\n                  debug('end :: closeStores: emitting end');\n                  that.emit('end');\n\n                  if (cb) {\n                    let err = e1 || e2;\n                    debug('end :: closeStores: invoking callback with args');\n                    cb(err);\n                  }\n                });\n              });\n\n              if (that._deferredReconnect) {\n                that._deferredReconnect();\n              }\n            }\n\n            function finish() {\n              // defer closesStores of an I/O cycle,\n              // just to make sure things are\n              // ok for websockets\n              debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force);\n\n              that._cleanUp(force, () => {\n                debug('end :: finish :: calling process.nextTick on closeStores'); // var boundProcess = nextTick.bind(null, closeStores)\n\n                nextTick(closeStores.bind(that));\n              }, opts);\n            }\n\n            if (this.disconnecting) {\n              cb();\n              return this;\n            }\n\n            this._clearReconnect();\n\n            this.disconnecting = true;\n\n            if (!force && Object.keys(this.outgoing).length > 0) {\n              // wait 10ms, just to be sure we received all of it\n              debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId);\n              this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n            } else {\n              debug('end :: (%s) :: immediately calling finish', that.options.clientId);\n              finish();\n            }\n\n            return this;\n          };\n          /**\n           * removeOutgoingMessage - remove a message in outgoing store\n           * the outgoing callback will be called withe Error('Message removed') if the message is removed\n           *\n           * @param {Number} messageId - messageId to remove message\n           * @returns {MqttClient} this - for chaining\n           * @api public\n           *\n           * @example client.removeOutgoingMessage(client.getLastMessageId());\n           */\n\n\n          MqttClient.prototype.removeOutgoingMessage = function (messageId) {\n            var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n            delete this.outgoing[messageId];\n            this.outgoingStore.del({\n              messageId: messageId\n            }, function () {\n              cb(new Error('Message removed'));\n            });\n            return this;\n          };\n          /**\n           * reconnect - connect again using the same options as connect()\n           *\n           * @param {Object} [opts] - optional reconnect options, includes:\n           *    {Store} incomingStore - a store for the incoming packets\n           *    {Store} outgoingStore - a store for the outgoing packets\n           *    if opts is not given, current stores are used\n           * @returns {MqttClient} this - for chaining\n           *\n           * @api public\n           */\n\n\n          MqttClient.prototype.reconnect = function (opts) {\n            debug('client reconnect');\n            var that = this;\n\n            var f = function () {\n              if (opts) {\n                that.options.incomingStore = opts.incomingStore;\n                that.options.outgoingStore = opts.outgoingStore;\n              } else {\n                that.options.incomingStore = null;\n                that.options.outgoingStore = null;\n              }\n\n              that.incomingStore = that.options.incomingStore || new Store();\n              that.outgoingStore = that.options.outgoingStore || new Store();\n              that.disconnecting = false;\n              that.disconnected = false;\n              that._deferredReconnect = null;\n\n              that._reconnect();\n            };\n\n            if (this.disconnecting && !this.disconnected) {\n              this._deferredReconnect = f;\n            } else {\n              f();\n            }\n\n            return this;\n          };\n          /**\n           * _reconnect - implement reconnection\n           * @api privateish\n           */\n\n\n          MqttClient.prototype._reconnect = function () {\n            debug('_reconnect: emitting reconnect to client');\n            this.emit('reconnect');\n\n            if (this.connected) {\n              this.end(() => {\n                this._setupStream();\n              });\n              debug('client already connected. disconnecting first.');\n            } else {\n              debug('_reconnect: calling _setupStream');\n\n              this._setupStream();\n            }\n          };\n          /**\n           * _setupReconnect - setup reconnect timer\n           */\n\n\n          MqttClient.prototype._setupReconnect = function () {\n            var that = this;\n\n            if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n              if (!this.reconnecting) {\n                debug('_setupReconnect :: emit `offline` state');\n                this.emit('offline');\n                debug('_setupReconnect :: set `reconnecting` to `true`');\n                this.reconnecting = true;\n              }\n\n              debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod);\n              that.reconnectTimer = setInterval(function () {\n                debug('reconnectTimer :: reconnect triggered!');\n\n                that._reconnect();\n              }, that.options.reconnectPeriod);\n            } else {\n              debug('_setupReconnect :: doing nothing...');\n            }\n          };\n          /**\n           * _clearReconnect - clear the reconnect timer\n           */\n\n\n          MqttClient.prototype._clearReconnect = function () {\n            debug('_clearReconnect : clearing reconnect timer');\n\n            if (this.reconnectTimer) {\n              clearInterval(this.reconnectTimer);\n              this.reconnectTimer = null;\n            }\n          };\n          /**\n           * _cleanUp - clean up on connection end\n           * @api private\n           */\n\n\n          MqttClient.prototype._cleanUp = function (forced, done) {\n            var opts = arguments[2];\n\n            if (done) {\n              debug('_cleanUp :: done callback provided for on stream close');\n              this.stream.on('close', done);\n            }\n\n            debug('_cleanUp :: forced? %s', forced);\n\n            if (forced) {\n              if (this.options.reconnectPeriod === 0 && this.options.clean) {\n                flush(this.outgoing);\n              }\n\n              debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n              this.stream.destroy();\n            } else {\n              var packet = xtend({\n                cmd: 'disconnect'\n              }, opts);\n              debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n\n              this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n            }\n\n            if (!this.disconnecting) {\n              debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n\n              this._clearReconnect();\n\n              this._setupReconnect();\n            }\n\n            if (this.pingTimer !== null) {\n              debug('_cleanUp :: clearing pingTimer');\n              this.pingTimer.clear();\n              this.pingTimer = null;\n            }\n\n            if (done && !this.connected) {\n              debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n              this.stream.removeListener('close', done);\n              done();\n            }\n          };\n          /**\n           * _sendPacket - send or queue a packet\n           * @param {Object} packet - packet options\n           * @param {Function} cb - callback when the packet is sent\n           * @param {Function} cbStorePut - called when message is put into outgoingStore\n           * @api private\n           */\n\n\n          MqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n            debug('_sendPacket :: (%s) ::  start', this.options.clientId);\n            cbStorePut = cbStorePut || nop;\n\n            if (!this.connected) {\n              debug('_sendPacket :: client not connected. Storing packet offline.');\n\n              this._storePacket(packet, cb, cbStorePut);\n\n              return;\n            } // When sending a packet, reschedule the ping timer\n\n\n            this._shiftPingInterval();\n\n            switch (packet.cmd) {\n              case 'publish':\n                break;\n\n              case 'pubrel':\n                storeAndSend(this, packet, cb, cbStorePut);\n                return;\n\n              default:\n                sendPacket(this, packet, cb);\n                return;\n            }\n\n            switch (packet.qos) {\n              case 2:\n              case 1:\n                storeAndSend(this, packet, cb, cbStorePut);\n                break;\n\n              /**\n               * no need of case here since it will be caught by default\n               * and jshint comply that before default it must be a break\n               * anyway it will result in -1 evaluation\n               */\n\n              case 0:\n              /* falls through */\n\n              default:\n                sendPacket(this, packet, cb);\n                break;\n            }\n\n            debug('_sendPacket :: (%s) ::  end', this.options.clientId);\n          };\n          /**\n           * _storePacket - queue a packet\n           * @param {Object} packet - packet options\n           * @param {Function} cb - callback when the packet is sent\n           * @param {Function} cbStorePut - called when message is put into outgoingStore\n           * @api private\n           */\n\n\n          MqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n            debug('_storePacket :: packet: %o', packet);\n            debug('_storePacket :: cb? %s', !!cb);\n            cbStorePut = cbStorePut || nop; // check that the packet is not a qos of 0, or that the command is not a publish\n\n            if ((packet.qos || 0) === 0 && this.queueQoSZero || packet.cmd !== 'publish') {\n              this.queue.push({\n                packet: packet,\n                cb: cb\n              });\n            } else if (packet.qos > 0) {\n              cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null;\n              this.outgoingStore.put(packet, function (err) {\n                if (err) {\n                  return cb && cb(err);\n                }\n\n                cbStorePut();\n              });\n            } else if (cb) {\n              cb(new Error('No connection to broker'));\n            }\n          };\n          /**\n           * _setupPingTimer - setup the ping timer\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._setupPingTimer = function () {\n            debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n            var that = this;\n\n            if (!this.pingTimer && this.options.keepalive) {\n              this.pingResp = true;\n              this.pingTimer = reInterval(function () {\n                that._checkPing();\n              }, this.options.keepalive * 1000);\n            }\n          };\n          /**\n           * _shiftPingInterval - reschedule the ping interval\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._shiftPingInterval = function () {\n            if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n              this.pingTimer.reschedule(this.options.keepalive * 1000);\n            }\n          };\n          /**\n           * _checkPing - check if a pingresp has come back, and ping the server again\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._checkPing = function () {\n            debug('_checkPing :: checking ping...');\n\n            if (this.pingResp) {\n              debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n              this.pingResp = false;\n\n              this._sendPacket({\n                cmd: 'pingreq'\n              });\n            } else {\n              // do a forced cleanup since socket will be in bad shape\n              debug('_checkPing :: calling _cleanUp with force true');\n\n              this._cleanUp(true);\n            }\n          };\n          /**\n           * _handlePingresp - handle a pingresp\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._handlePingresp = function () {\n            this.pingResp = true;\n          };\n          /**\n           * _handleConnack\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n\n          MqttClient.prototype._handleConnack = function (packet) {\n            debug('_handleConnack');\n            var options = this.options;\n            var version = options.protocolVersion;\n            var rc = version === 5 ? packet.reasonCode : packet.returnCode;\n            clearTimeout(this.connackTimer);\n\n            if (packet.properties) {\n              if (packet.properties.topicAliasMaximum) {\n                if (!options.properties) {\n                  options.properties = {};\n                }\n\n                options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum;\n              }\n\n              if (packet.properties.serverKeepAlive && options.keepalive) {\n                options.keepalive = packet.properties.serverKeepAlive;\n\n                this._shiftPingInterval();\n              }\n\n              if (packet.properties.maximumPacketSize) {\n                if (!options.properties) {\n                  options.properties = {};\n                }\n\n                options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n              }\n            }\n\n            if (rc === 0) {\n              this.reconnecting = false;\n\n              this._onConnect(packet);\n            } else if (rc > 0) {\n              var err = new Error('Connection refused: ' + errors[rc]);\n              err.code = rc;\n              this.emit('error', err);\n            }\n          };\n          /**\n           * _handlePublish\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n          /*\n          those late 2 case should be rewrite to comply with coding style:\n          \n          case 1:\n          case 0:\n            // do not wait sending a puback\n            // no callback passed\n            if (1 === qos) {\n              this._sendPacket({\n                cmd: 'puback',\n                messageId: messageId\n              });\n            }\n            // emit the message event for both qos 1 and 0\n            this.emit('message', topic, message, packet);\n            this.handleMessage(packet, done);\n            break;\n          default:\n            // do nothing but every switch mus have a default\n            // log or throw an error about unknown qos\n            break;\n          \n          for now i just suppressed the warnings\n          */\n\n\n          MqttClient.prototype._handlePublish = function (packet, done) {\n            debug('_handlePublish: packet %o', packet);\n            done = typeof done !== 'undefined' ? done : nop;\n            var topic = packet.topic.toString();\n            var message = packet.payload;\n            var qos = packet.qos;\n            var messageId = packet.messageId;\n            var that = this;\n            var options = this.options;\n            var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n            debug('_handlePublish: qos %d', qos);\n\n            switch (qos) {\n              case 2:\n                {\n                  options.customHandleAcks(topic, message, packet, function (error, code) {\n                    if (!(error instanceof Error)) {\n                      code = error;\n                      error = null;\n                    }\n\n                    if (error) {\n                      return that.emit('error', error);\n                    }\n\n                    if (validReasonCodes.indexOf(code) === -1) {\n                      return that.emit('error', new Error('Wrong reason code for pubrec'));\n                    }\n\n                    if (code) {\n                      that._sendPacket({\n                        cmd: 'pubrec',\n                        messageId: messageId,\n                        reasonCode: code\n                      }, done);\n                    } else {\n                      that.incomingStore.put(packet, function () {\n                        that._sendPacket({\n                          cmd: 'pubrec',\n                          messageId: messageId\n                        }, done);\n                      });\n                    }\n                  });\n                  break;\n                }\n\n              case 1:\n                {\n                  // emit the message event\n                  options.customHandleAcks(topic, message, packet, function (error, code) {\n                    if (!(error instanceof Error)) {\n                      code = error;\n                      error = null;\n                    }\n\n                    if (error) {\n                      return that.emit('error', error);\n                    }\n\n                    if (validReasonCodes.indexOf(code) === -1) {\n                      return that.emit('error', new Error('Wrong reason code for puback'));\n                    }\n\n                    if (!code) {\n                      that.emit('message', topic, message, packet);\n                    }\n\n                    that.handleMessage(packet, function (err) {\n                      if (err) {\n                        return done && done(err);\n                      }\n\n                      that._sendPacket({\n                        cmd: 'puback',\n                        messageId: messageId,\n                        reasonCode: code\n                      }, done);\n                    });\n                  });\n                  break;\n                }\n\n              case 0:\n                // emit the message event\n                this.emit('message', topic, message, packet);\n                this.handleMessage(packet, done);\n                break;\n\n              default:\n                // do nothing\n                debug('_handlePublish: unknown QoS. Doing nothing.'); // log or throw an error about unknown qos\n\n                break;\n            }\n          };\n          /**\n           * Handle messages with backpressure support, one at a time.\n           * Override at will.\n           *\n           * @param Packet packet the packet\n           * @param Function callback call when finished\n           * @api public\n           */\n\n\n          MqttClient.prototype.handleMessage = function (packet, callback) {\n            callback();\n          };\n          /**\n           * _handleAck\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n\n          MqttClient.prototype._handleAck = function (packet) {\n            /* eslint no-fallthrough: \"off\" */\n            var messageId = packet.messageId;\n            var type = packet.cmd;\n            var response = null;\n            var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n            var that = this;\n            var err;\n\n            if (!cb) {\n              debug('_handleAck :: Server sent an ack in error. Ignoring.'); // Server sent an ack in error, ignore it.\n\n              return;\n            } // Process\n\n\n            debug('_handleAck :: packet type', type);\n\n            switch (type) {\n              case 'pubcomp': // same thing as puback for QoS 2\n\n              case 'puback':\n                var pubackRC = packet.reasonCode; // Callback - we're done\n\n                if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n                  err = new Error('Publish error: ' + errors[pubackRC]);\n                  err.code = pubackRC;\n                  cb(err, packet);\n                }\n\n                delete this.outgoing[messageId];\n                this.outgoingStore.del(packet, cb);\n                break;\n\n              case 'pubrec':\n                response = {\n                  cmd: 'pubrel',\n                  qos: 2,\n                  messageId: messageId\n                };\n                var pubrecRC = packet.reasonCode;\n\n                if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n                  err = new Error('Publish error: ' + errors[pubrecRC]);\n                  err.code = pubrecRC;\n                  cb(err, packet);\n                } else {\n                  this._sendPacket(response);\n                }\n\n                break;\n\n              case 'suback':\n                delete this.outgoing[messageId];\n\n                for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n                  if ((packet.granted[grantedI] & 0x80) !== 0) {\n                    // suback with Failure status\n                    var topics = this.messageIdToTopic[messageId];\n\n                    if (topics) {\n                      topics.forEach(function (topic) {\n                        delete that._resubscribeTopics[topic];\n                      });\n                    }\n                  }\n                }\n\n                cb(null, packet);\n                break;\n\n              case 'unsuback':\n                delete this.outgoing[messageId];\n                cb(null);\n                break;\n\n              default:\n                that.emit('error', new Error('unrecognized packet type'));\n            }\n\n            if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n              this.emit('outgoingEmpty');\n            }\n          };\n          /**\n           * _handlePubrel\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n\n          MqttClient.prototype._handlePubrel = function (packet, callback) {\n            debug('handling pubrel packet');\n            callback = typeof callback !== 'undefined' ? callback : nop;\n            var messageId = packet.messageId;\n            var that = this;\n            var comp = {\n              cmd: 'pubcomp',\n              messageId: messageId\n            };\n            that.incomingStore.get(packet, function (err, pub) {\n              if (!err) {\n                that.emit('message', pub.topic, pub.payload, pub);\n                that.handleMessage(pub, function (err) {\n                  if (err) {\n                    return callback(err);\n                  }\n\n                  that.incomingStore.del(pub, nop);\n\n                  that._sendPacket(comp, callback);\n                });\n              } else {\n                that._sendPacket(comp, callback);\n              }\n            });\n          };\n          /**\n           * _handleDisconnect\n           *\n           * @param {Object} packet\n           * @api private\n           */\n\n\n          MqttClient.prototype._handleDisconnect = function (packet) {\n            this.emit('disconnect', packet);\n          };\n          /**\n           * _nextId\n           * @return unsigned int\n           */\n\n\n          MqttClient.prototype._nextId = function () {\n            // id becomes current state of this.nextId and increments afterwards\n            var id = this.nextId++; // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n\n            if (this.nextId === 65536) {\n              this.nextId = 1;\n            }\n\n            return id;\n          };\n          /**\n           * getLastMessageId\n           * @return unsigned int\n           */\n\n\n          MqttClient.prototype.getLastMessageId = function () {\n            return this.nextId === 1 ? 65535 : this.nextId - 1;\n          };\n          /**\n           * _resubscribe\n           * @api private\n           */\n\n\n          MqttClient.prototype._resubscribe = function (connack) {\n            debug('_resubscribe');\n\n            var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n\n            if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !connack.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n              if (this.options.resubscribe) {\n                if (this.options.protocolVersion === 5) {\n                  debug('_resubscribe: protocolVersion 5');\n\n                  for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n                    var resubscribeTopic = {};\n                    resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n                    resubscribeTopic.resubscribe = true;\n                    this.subscribe(resubscribeTopic, {\n                      properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n                    });\n                  }\n                } else {\n                  this._resubscribeTopics.resubscribe = true;\n                  this.subscribe(this._resubscribeTopics);\n                }\n              } else {\n                this._resubscribeTopics = {};\n              }\n            }\n\n            this._firstConnection = false;\n          };\n          /**\n           * _onConnect\n           *\n           * @api private\n           */\n\n\n          MqttClient.prototype._onConnect = function (packet) {\n            if (this.disconnected) {\n              this.emit('connect', packet);\n              return;\n            }\n\n            var that = this;\n\n            this._setupPingTimer();\n\n            this._resubscribe(packet);\n\n            this.connected = true;\n\n            function startStreamProcess() {\n              var outStore = that.outgoingStore.createStream();\n\n              function clearStoreProcessing() {\n                that._storeProcessing = false;\n                that._packetIdsDuringStoreProcessing = {};\n              }\n\n              that.once('close', remove);\n              outStore.on('error', function (err) {\n                clearStoreProcessing();\n                that.removeListener('close', remove);\n                that.emit('error', err);\n              });\n\n              function remove() {\n                outStore.destroy();\n                outStore = null;\n                clearStoreProcessing();\n              }\n\n              function storeDeliver() {\n                // edge case, we wrapped this twice\n                if (!outStore) {\n                  return;\n                }\n\n                that._storeProcessing = true;\n                var packet = outStore.read(1);\n                var cb;\n\n                if (!packet) {\n                  // read when data is available in the future\n                  outStore.once('readable', storeDeliver);\n                  return;\n                } // Skip already processed store packets\n\n\n                if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n                  storeDeliver();\n                  return;\n                } // Avoid unnecessary stream read operations when disconnected\n\n\n                if (!that.disconnecting && !that.reconnectTimer) {\n                  cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n                  that.outgoing[packet.messageId] = {\n                    volatile: false,\n                    cb: function (err, status) {\n                      // Ensure that the original callback passed in to publish gets invoked\n                      if (cb) {\n                        cb(err, status);\n                      }\n\n                      storeDeliver();\n                    }\n                  };\n                  that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n\n                  that._sendPacket(packet);\n                } else if (outStore.destroy) {\n                  outStore.destroy();\n                }\n              }\n\n              outStore.on('end', function () {\n                var allProcessed = true;\n\n                for (var id in that._packetIdsDuringStoreProcessing) {\n                  if (!that._packetIdsDuringStoreProcessing[id]) {\n                    allProcessed = false;\n                    break;\n                  }\n                }\n\n                if (allProcessed) {\n                  clearStoreProcessing();\n                  that.removeListener('close', remove);\n                  that.emit('connect', packet);\n                } else {\n                  startStreamProcess();\n                }\n              });\n              storeDeliver();\n            } // start flowing\n\n\n            startStreamProcess();\n          };\n\n          module.exports = MqttClient;\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./store\": 13,\n      \"./validations\": 14,\n      \"_process\": 69,\n      \"debug\": 19,\n      \"events\": 4,\n      \"inherits\": 34,\n      \"mqtt-packet\": 38,\n      \"readable-stream\": 60,\n      \"reinterval\": 61,\n      \"xtend\": 68\n    }],\n    8: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          'use strict';\n\n          var Transform = require('readable-stream').Transform;\n\n          var duplexify = require('duplexify');\n          /* global FileReader */\n\n\n          var my;\n          var proxy;\n          var stream;\n          var isInitialized = false;\n\n          function buildProxy() {\n            var proxy = new Transform();\n\n            proxy._write = function (chunk, encoding, next) {\n              my.sendSocketMessage({\n                data: chunk.buffer,\n                success: function () {\n                  next();\n                },\n                fail: function () {\n                  next(new Error());\n                }\n              });\n            };\n\n            proxy._flush = function socketEnd(done) {\n              my.closeSocket({\n                success: function () {\n                  done();\n                }\n              });\n            };\n\n            return proxy;\n          }\n\n          function setDefaultOpts(opts) {\n            if (!opts.hostname) {\n              opts.hostname = 'localhost';\n            }\n\n            if (!opts.path) {\n              opts.path = '/';\n            }\n\n            if (!opts.wsOptions) {\n              opts.wsOptions = {};\n            }\n          }\n\n          function buildUrl(opts, client) {\n            var protocol = opts.protocol === 'alis' ? 'wss' : 'ws';\n            var url = protocol + '://' + opts.hostname + opts.path;\n\n            if (opts.port && opts.port !== 80 && opts.port !== 443) {\n              url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n            }\n\n            if (typeof opts.transformWsUrl === 'function') {\n              url = opts.transformWsUrl(url, opts, client);\n            }\n\n            return url;\n          }\n\n          function bindEventHandler() {\n            if (isInitialized) return;\n            isInitialized = true;\n            my.onSocketOpen(function () {\n              stream.setReadable(proxy);\n              stream.setWritable(proxy);\n              stream.emit('connect');\n            });\n            my.onSocketMessage(function (res) {\n              if (typeof res.data === 'string') {\n                var buffer = Buffer.from(res.data, 'base64');\n                proxy.push(buffer);\n              } else {\n                var reader = new FileReader();\n                reader.addEventListener('load', function () {\n                  var data = reader.result;\n                  if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n                  proxy.push(data);\n                });\n                reader.readAsArrayBuffer(res.data);\n              }\n            });\n            my.onSocketClose(function () {\n              stream.end();\n              stream.destroy();\n            });\n            my.onSocketError(function (res) {\n              stream.destroy(res);\n            });\n          }\n\n          function buildStream(client, opts) {\n            opts.hostname = opts.hostname || opts.host;\n\n            if (!opts.hostname) {\n              throw new Error('Could not determine host. Specify host manually.');\n            }\n\n            var websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n            setDefaultOpts(opts);\n            var url = buildUrl(opts, client);\n            my = opts.my;\n            my.connectSocket({\n              url: url,\n              protocols: websocketSubProtocol\n            });\n            proxy = buildProxy();\n            stream = duplexify.obj();\n            bindEventHandler();\n            return stream;\n          }\n\n          module.exports = buildStream;\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"buffer\": 3,\n      \"duplexify\": 21,\n      \"readable-stream\": 60\n    }],\n    9: [function (require, module, exports) {\n      'use strict';\n\n      var net = require('net');\n\n      var debug = require('debug')('mqttjs:tcp');\n      /*\n        variables port and host can be removed since\n        you have all required information in opts object\n      */\n\n\n      function streamBuilder(client, opts) {\n        var port, host;\n        opts.port = opts.port || 1883;\n        opts.hostname = opts.hostname || opts.host || 'localhost';\n        port = opts.port;\n        host = opts.hostname;\n        debug('port %d and host %s', port, host);\n        return net.createConnection(port, host);\n      }\n\n      module.exports = streamBuilder;\n    }, {\n      \"debug\": 19,\n      \"net\": 2\n    }],\n    10: [function (require, module, exports) {\n      'use strict';\n\n      var tls = require('tls');\n\n      var debug = require('debug')('mqttjs:tls');\n\n      function buildBuilder(mqttClient, opts) {\n        var connection;\n        opts.port = opts.port || 8883;\n        opts.host = opts.hostname || opts.host || 'localhost';\n        opts.servername = opts.host;\n        opts.rejectUnauthorized = opts.rejectUnauthorized !== false;\n        delete opts.path;\n        debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized);\n        connection = tls.connect(opts);\n        /* eslint no-use-before-define: [2, \"nofunc\"] */\n\n        connection.on('secureConnect', function () {\n          if (opts.rejectUnauthorized && !connection.authorized) {\n            connection.emit('error', new Error('TLS not authorized'));\n          } else {\n            connection.removeListener('error', handleTLSerrors);\n          }\n        });\n\n        function handleTLSerrors(err) {\n          // How can I get verify this error is a tls error?\n          if (opts.rejectUnauthorized) {\n            mqttClient.emit('error', err);\n          } // close this connection to match the behaviour of net\n          // otherwise all we get is an error from the connection\n          // and close event doesn't fire. This is a work around\n          // to enable the reconnect code to work the same as with\n          // net.createConnection\n\n\n          connection.end();\n        }\n\n        connection.on('error', handleTLSerrors);\n        return connection;\n      }\n\n      module.exports = buildBuilder;\n    }, {\n      \"debug\": 19,\n      \"tls\": 2\n    }],\n    11: [function (require, module, exports) {\n      (function (process, Buffer) {\n        (function () {\n          'use strict';\n\n          const WS = require('ws');\n\n          const debug = require('debug')('mqttjs:ws');\n\n          const duplexify = require('duplexify');\n\n          const Transform = require('readable-stream').Transform;\n\n          let WSS_OPTIONS = ['rejectUnauthorized', 'ca', 'cert', 'key', 'pfx', 'passphrase']; // eslint-disable-next-line camelcase\n\n          const IS_BROWSER = typeof process !== 'undefined' && process.title === 'browser' || typeof __webpack_require__ === 'function';\n\n          function buildUrl(opts, client) {\n            let url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n\n            if (typeof opts.transformWsUrl === 'function') {\n              url = opts.transformWsUrl(url, opts, client);\n            }\n\n            return url;\n          }\n\n          function setDefaultOpts(opts) {\n            let options = opts;\n\n            if (!opts.hostname) {\n              options.hostname = 'localhost';\n            }\n\n            if (!opts.port) {\n              if (opts.protocol === 'wss') {\n                options.port = 443;\n              } else {\n                options.port = 80;\n              }\n            }\n\n            if (!opts.path) {\n              options.path = '/';\n            }\n\n            if (!opts.wsOptions) {\n              options.wsOptions = {};\n            }\n\n            if (!IS_BROWSER && opts.protocol === 'wss') {\n              // Add cert/key/ca etc options\n              WSS_OPTIONS.forEach(function (prop) {\n                if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {\n                  options.wsOptions[prop] = opts[prop];\n                }\n              });\n            }\n\n            return options;\n          }\n\n          function setDefaultBrowserOpts(opts) {\n            let options = setDefaultOpts(opts);\n\n            if (!options.hostname) {\n              options.hostname = options.host;\n            }\n\n            if (!options.hostname) {\n              // Throwing an error in a Web Worker if no `hostname` is given, because we\n              // can not determine the `hostname` automatically.  If connecting to\n              // localhost, please supply the `hostname` as an argument.\n              if (typeof document === 'undefined') {\n                throw new Error('Could not determine host. Specify host manually.');\n              }\n\n              const parsed = new URL(document.URL);\n              options.hostname = parsed.hostname;\n\n              if (!options.port) {\n                options.port = parsed.port;\n              }\n            } // objectMode should be defined for logic\n\n\n            if (options.objectMode === undefined) {\n              options.objectMode = !(options.binary === true || options.binary === undefined);\n            }\n\n            return options;\n          }\n\n          function createWebSocket(client, url, opts) {\n            debug('createWebSocket');\n            debug('protocol: ' + opts.protocolId + ' ' + opts.protocolVersion);\n            const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n            debug('creating new Websocket for url: ' + url + ' and protocol: ' + websocketSubProtocol);\n            let socket = new WS(url, [websocketSubProtocol], opts.wsOptions);\n            return socket;\n          }\n\n          function createBrowserWebSocket(client, opts) {\n            const websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n            let url = buildUrl(opts, client);\n            /* global WebSocket */\n\n            let socket = new WebSocket(url, [websocketSubProtocol]);\n            socket.binaryType = 'arraybuffer';\n            return socket;\n          }\n\n          function streamBuilder(client, opts) {\n            debug('streamBuilder');\n            let options = setDefaultOpts(opts);\n            const url = buildUrl(options, client);\n            let socket = createWebSocket(client, url, options);\n            let webSocketStream = WS.createWebSocketStream(socket, options.wsOptions);\n            webSocketStream.url = url;\n            return webSocketStream;\n          }\n\n          function browserStreamBuilder(client, opts) {\n            debug('browserStreamBuilder');\n            let stream;\n            let options = setDefaultBrowserOpts(opts); // sets the maximum socket buffer size before throttling\n\n            const bufferSize = options.browserBufferSize || 1024 * 512;\n            const bufferTimeout = opts.browserBufferTimeout || 1000;\n            const coerceToBuffer = !opts.objectMode;\n            let socket = createBrowserWebSocket(client, opts);\n            let proxy = buildProxy(opts, socketWriteBrowser, socketEndBrowser);\n\n            if (!opts.objectMode) {\n              proxy._writev = writev;\n            }\n\n            proxy.on('close', () => {\n              socket.close();\n            });\n            const eventListenerSupport = typeof socket.addEventListener === 'undefined'; // was already open when passed in\n\n            if (socket.readyState === socket.OPEN) {\n              stream = proxy;\n            } else {\n              stream = stream = duplexify(undefined, undefined, opts);\n\n              if (!opts.objectMode) {\n                stream._writev = writev;\n              }\n\n              if (eventListenerSupport) {\n                socket.addEventListener('open', onopen);\n              } else {\n                socket.onopen = onopen;\n              }\n            }\n\n            stream.socket = socket;\n\n            if (eventListenerSupport) {\n              socket.addEventListener('close', onclose);\n              socket.addEventListener('error', onerror);\n              socket.addEventListener('message', onmessage);\n            } else {\n              socket.onclose = onclose;\n              socket.onerror = onerror;\n              socket.onmessage = onmessage;\n            } // methods for browserStreamBuilder\n\n\n            function buildProxy(options, socketWrite, socketEnd) {\n              let proxy = new Transform({\n                objectModeMode: options.objectMode\n              });\n              proxy._write = socketWrite;\n              proxy._flush = socketEnd;\n              return proxy;\n            }\n\n            function onopen() {\n              stream.setReadable(proxy);\n              stream.setWritable(proxy);\n              stream.emit('connect');\n            }\n\n            function onclose() {\n              stream.end();\n              stream.destroy();\n            }\n\n            function onerror(err) {\n              stream.destroy(err);\n            }\n\n            function onmessage(event) {\n              let data = event.data;\n              if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n              proxy.push(data);\n            } // this is to be enabled only if objectMode is false\n\n\n            function writev(chunks, cb) {\n              const buffers = new Array(chunks.length);\n\n              for (let i = 0; i < chunks.length; i++) {\n                if (typeof chunks[i].chunk === 'string') {\n                  buffers[i] = Buffer.from(chunks[i], 'utf8');\n                } else {\n                  buffers[i] = chunks[i].chunk;\n                }\n              }\n\n              this._write(Buffer.concat(buffers), 'binary', cb);\n            }\n\n            function socketWriteBrowser(chunk, enc, next) {\n              if (socket.bufferedAmount > bufferSize) {\n                // throttle data until buffered amount is reduced.\n                setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);\n              }\n\n              if (coerceToBuffer && typeof chunk === 'string') {\n                chunk = Buffer.from(chunk, 'utf8');\n              }\n\n              try {\n                socket.send(chunk);\n              } catch (err) {\n                return next(err);\n              }\n\n              next();\n            }\n\n            function socketEndBrowser(done) {\n              socket.close();\n              done();\n            } // end methods for browserStreamBuilder\n\n\n            return stream;\n          }\n\n          if (IS_BROWSER) {\n            module.exports = browserStreamBuilder;\n          } else {\n            module.exports = streamBuilder;\n          }\n        }).call(this);\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, {\n      \"_process\": 69,\n      \"buffer\": 3,\n      \"debug\": 19,\n      \"duplexify\": 21,\n      \"readable-stream\": 60,\n      \"ws\": 67\n    }],\n    12: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          'use strict';\n\n          var Transform = require('readable-stream').Transform;\n\n          var duplexify = require('duplexify');\n          /* global wx */\n\n\n          var socketTask;\n          var proxy;\n          var stream;\n\n          function buildProxy() {\n            var proxy = new Transform();\n\n            proxy._write = function (chunk, encoding, next) {\n              socketTask.send({\n                data: chunk.buffer,\n                success: function () {\n                  next();\n                },\n                fail: function (errMsg) {\n                  next(new Error(errMsg));\n                }\n              });\n            };\n\n            proxy._flush = function socketEnd(done) {\n              socketTask.close({\n                success: function () {\n                  done();\n                }\n              });\n            };\n\n            return proxy;\n          }\n\n          function setDefaultOpts(opts) {\n            if (!opts.hostname) {\n              opts.hostname = 'localhost';\n            }\n\n            if (!opts.path) {\n              opts.path = '/';\n            }\n\n            if (!opts.wsOptions) {\n              opts.wsOptions = {};\n            }\n          }\n\n          function buildUrl(opts, client) {\n            var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws';\n            var url = protocol + '://' + opts.hostname + opts.path;\n\n            if (opts.port && opts.port !== 80 && opts.port !== 443) {\n              url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n            }\n\n            if (typeof opts.transformWsUrl === 'function') {\n              url = opts.transformWsUrl(url, opts, client);\n            }\n\n            return url;\n          }\n\n          function bindEventHandler() {\n            socketTask.onOpen(function () {\n              stream.setReadable(proxy);\n              stream.setWritable(proxy);\n              stream.emit('connect');\n            });\n            socketTask.onMessage(function (res) {\n              var data = res.data;\n              if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n              proxy.push(data);\n            });\n            socketTask.onClose(function () {\n              stream.end();\n              stream.destroy();\n            });\n            socketTask.onError(function (res) {\n              stream.destroy(new Error(res.errMsg));\n            });\n          }\n\n          function buildStream(client, opts) {\n            opts.hostname = opts.hostname || opts.host;\n\n            if (!opts.hostname) {\n              throw new Error('Could not determine host. Specify host manually.');\n            }\n\n            var websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n            setDefaultOpts(opts);\n            var url = buildUrl(opts, client);\n            socketTask = wx.connectSocket({\n              url: url,\n              protocols: [websocketSubProtocol]\n            });\n            proxy = buildProxy();\n            stream = duplexify.obj();\n\n            stream._destroy = function (err, cb) {\n              socketTask.close({\n                success: function () {\n                  cb && cb(err);\n                }\n              });\n            };\n\n            var destroyRef = stream.destroy;\n\n            stream.destroy = function () {\n              stream.destroy = destroyRef;\n              var self = this;\n              setTimeout(function () {\n                socketTask.close({\n                  fail: function () {\n                    self._destroy(new Error());\n                  }\n                });\n              }, 0);\n            }.bind(stream);\n\n            bindEventHandler();\n            return stream;\n          }\n\n          module.exports = buildStream;\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"buffer\": 3,\n      \"duplexify\": 21,\n      \"readable-stream\": 60\n    }],\n    13: [function (require, module, exports) {\n      'use strict';\n      /**\n       * Module dependencies\n       */\n\n      var xtend = require('xtend');\n\n      var Readable = require('readable-stream').Readable;\n\n      var streamsOpts = {\n        objectMode: true\n      };\n      var defaultStoreOptions = {\n        clean: true\n      };\n      /**\n       * In-memory implementation of the message store\n       * This can actually be saved into files.\n       *\n       * @param {Object} [options] - store options\n       */\n\n      function Store(options) {\n        if (!(this instanceof Store)) {\n          return new Store(options);\n        }\n\n        this.options = options || {}; // Defaults\n\n        this.options = xtend(defaultStoreOptions, options);\n        this._inflights = new Map();\n      }\n      /**\n       * Adds a packet to the store, a packet is\n       * anything that has a messageId property.\n       *\n       */\n\n\n      Store.prototype.put = function (packet, cb) {\n        this._inflights.set(packet.messageId, packet);\n\n        if (cb) {\n          cb();\n        }\n\n        return this;\n      };\n      /**\n       * Creates a stream with all the packets in the store\n       *\n       */\n\n\n      Store.prototype.createStream = function () {\n        var stream = new Readable(streamsOpts);\n        var destroyed = false;\n        var values = [];\n        var i = 0;\n\n        this._inflights.forEach(function (value, key) {\n          values.push(value);\n        });\n\n        stream._read = function () {\n          if (!destroyed && i < values.length) {\n            this.push(values[i++]);\n          } else {\n            this.push(null);\n          }\n        };\n\n        stream.destroy = function () {\n          if (destroyed) {\n            return;\n          }\n\n          var self = this;\n          destroyed = true;\n          setTimeout(function () {\n            self.emit('close');\n          }, 0);\n        };\n\n        return stream;\n      };\n      /**\n       * deletes a packet from the store.\n       */\n\n\n      Store.prototype.del = function (packet, cb) {\n        packet = this._inflights.get(packet.messageId);\n\n        if (packet) {\n          this._inflights.delete(packet.messageId);\n\n          cb(null, packet);\n        } else if (cb) {\n          cb(new Error('missing packet'));\n        }\n\n        return this;\n      };\n      /**\n       * get a packet from the store.\n       */\n\n\n      Store.prototype.get = function (packet, cb) {\n        packet = this._inflights.get(packet.messageId);\n\n        if (packet) {\n          cb(null, packet);\n        } else if (cb) {\n          cb(new Error('missing packet'));\n        }\n\n        return this;\n      };\n      /**\n       * Close the store\n       */\n\n\n      Store.prototype.close = function (cb) {\n        if (this.options.clean) {\n          this._inflights = null;\n        }\n\n        if (cb) {\n          cb();\n        }\n      };\n\n      module.exports = Store;\n    }, {\n      \"readable-stream\": 60,\n      \"xtend\": 68\n    }],\n    14: [function (require, module, exports) {\n      'use strict';\n      /**\n       * Validate a topic to see if it's valid or not.\n       * A topic is valid if it follow below rules:\n       * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'\n       * - Rule #2: Part `#` must be located at the end of the mailbox\n       *\n       * @param {String} topic - A topic\n       * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.\n       */\n\n      function validateTopic(topic) {\n        var parts = topic.split('/');\n\n        for (var i = 0; i < parts.length; i++) {\n          if (parts[i] === '+') {\n            continue;\n          }\n\n          if (parts[i] === '#') {\n            // for Rule #2\n            return i === parts.length - 1;\n          }\n\n          if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n      /**\n       * Validate an array of topics to see if any of them is valid or not\n        * @param {Array} topics - Array of topics\n       * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one\n       */\n\n\n      function validateTopics(topics) {\n        if (topics.length === 0) {\n          return 'empty_topic_list';\n        }\n\n        for (var i = 0; i < topics.length; i++) {\n          if (!validateTopic(topics[i])) {\n            return topics[i];\n          }\n        }\n\n        return null;\n      }\n\n      module.exports = {\n        validateTopics: validateTopics\n      };\n    }, {}],\n    15: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var MqttClient = require('../client');\n\n          var Store = require('../store');\n\n          var url = require('url');\n\n          var xtend = require('xtend');\n\n          var debug = require('debug')('mqttjs');\n\n          var protocols = {}; // eslint-disable-next-line camelcase\n\n          if (typeof process !== 'undefined' && process.title !== 'browser' || typeof __webpack_require__ !== 'function') {\n            protocols.mqtt = require('./tcp');\n            protocols.tcp = require('./tcp');\n            protocols.ssl = require('./tls');\n            protocols.tls = require('./tls');\n            protocols.mqtts = require('./tls');\n          } else {\n            protocols.wx = require('./wx');\n            protocols.wxs = require('./wx');\n            protocols.ali = require('./ali');\n            protocols.alis = require('./ali');\n          }\n\n          protocols.ws = require('./ws');\n          protocols.wss = require('./ws');\n          /**\n           * Parse the auth attribute and merge username and password in the options object.\n           *\n           * @param {Object} [opts] option object\n           */\n\n          function parseAuthOptions(opts) {\n            var matches;\n\n            if (opts.auth) {\n              matches = opts.auth.match(/^(.+):(.+)$/);\n\n              if (matches) {\n                opts.username = matches[1];\n                opts.password = matches[2];\n              } else {\n                opts.username = opts.auth;\n              }\n            }\n          }\n          /**\n           * connect - connect to an MQTT broker.\n           *\n           * @param {String} [brokerUrl] - url of the broker, optional\n           * @param {Object} opts - see MqttClient#constructor\n           */\n\n\n          function connect(brokerUrl, opts) {\n            debug('connecting to an MQTT broker...');\n\n            if (typeof brokerUrl === 'object' && !opts) {\n              opts = brokerUrl;\n              brokerUrl = null;\n            }\n\n            opts = opts || {};\n\n            if (brokerUrl) {\n              var parsed = url.parse(brokerUrl, true);\n\n              if (parsed.port != null) {\n                parsed.port = Number(parsed.port);\n              }\n\n              opts = xtend(parsed, opts);\n\n              if (opts.protocol === null) {\n                throw new Error('Missing protocol');\n              }\n\n              opts.protocol = opts.protocol.replace(/:$/, '');\n            } // merge in the auth options if supplied\n\n\n            parseAuthOptions(opts); // support clientId passed in the query string of the url\n\n            if (opts.query && typeof opts.query.clientId === 'string') {\n              opts.clientId = opts.query.clientId;\n            }\n\n            if (opts.cert && opts.key) {\n              if (opts.protocol) {\n                if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n                  switch (opts.protocol) {\n                    case 'mqtt':\n                      opts.protocol = 'mqtts';\n                      break;\n\n                    case 'ws':\n                      opts.protocol = 'wss';\n                      break;\n\n                    case 'wx':\n                      opts.protocol = 'wxs';\n                      break;\n\n                    case 'ali':\n                      opts.protocol = 'alis';\n                      break;\n\n                    default:\n                      throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!');\n                  }\n                }\n              } else {\n                // A cert and key was provided, however no protocol was specified, so we will throw an error.\n                throw new Error('Missing secure protocol key');\n              }\n            }\n\n            if (!protocols[opts.protocol]) {\n              var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;\n              opts.protocol = ['mqtt', 'mqtts', 'ws', 'wss', 'wx', 'wxs', 'ali', 'alis'].filter(function (key, index) {\n                if (isSecure && index % 2 === 0) {\n                  // Skip insecure protocols when requesting a secure one.\n                  return false;\n                }\n\n                return typeof protocols[key] === 'function';\n              })[0];\n            }\n\n            if (opts.clean === false && !opts.clientId) {\n              throw new Error('Missing clientId for unclean clients');\n            }\n\n            if (opts.protocol) {\n              opts.defaultProtocol = opts.protocol;\n            }\n\n            function wrapper(client) {\n              if (opts.servers) {\n                if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n                  client._reconnectCount = 0;\n                }\n\n                opts.host = opts.servers[client._reconnectCount].host;\n                opts.port = opts.servers[client._reconnectCount].port;\n                opts.protocol = !opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol;\n                opts.hostname = opts.host;\n                client._reconnectCount++;\n              }\n\n              debug('calling streambuilder for', opts.protocol);\n              return protocols[opts.protocol](client, opts);\n            }\n\n            var client = new MqttClient(wrapper, opts);\n            client.on('error', function () {\n              /* Automatically set up client error handling */\n            });\n            return client;\n          }\n\n          module.exports = connect;\n          module.exports.connect = connect;\n          module.exports.MqttClient = MqttClient;\n          module.exports.Store = Store;\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"../client\": 7,\n      \"../store\": 13,\n      \"./ali\": 8,\n      \"./tcp\": 9,\n      \"./tls\": 10,\n      \"./ws\": 11,\n      \"./wx\": 12,\n      \"_process\": 69,\n      \"debug\": 19,\n      \"url\": 75,\n      \"xtend\": 68\n    }],\n    16: [function (require, module, exports) {\n      'use strict';\n\n      const {\n        Buffer\n      } = require('buffer');\n\n      const symbol = Symbol.for('BufferList');\n\n      function BufferList(buf) {\n        if (!(this instanceof BufferList)) {\n          return new BufferList(buf);\n        }\n\n        BufferList._init.call(this, buf);\n      }\n\n      BufferList._init = function _init(buf) {\n        Object.defineProperty(this, symbol, {\n          value: true\n        });\n        this._bufs = [];\n        this.length = 0;\n\n        if (buf) {\n          this.append(buf);\n        }\n      };\n\n      BufferList.prototype._new = function _new(buf) {\n        return new BufferList(buf);\n      };\n\n      BufferList.prototype._offset = function _offset(offset) {\n        if (offset === 0) {\n          return [0, 0];\n        }\n\n        let tot = 0;\n\n        for (let i = 0; i < this._bufs.length; i++) {\n          const _t = tot + this._bufs[i].length;\n\n          if (offset < _t || i === this._bufs.length - 1) {\n            return [i, offset - tot];\n          }\n\n          tot = _t;\n        }\n      };\n\n      BufferList.prototype._reverseOffset = function (blOffset) {\n        const bufferId = blOffset[0];\n        let offset = blOffset[1];\n\n        for (let i = 0; i < bufferId; i++) {\n          offset += this._bufs[i].length;\n        }\n\n        return offset;\n      };\n\n      BufferList.prototype.get = function get(index) {\n        if (index > this.length || index < 0) {\n          return undefined;\n        }\n\n        const offset = this._offset(index);\n\n        return this._bufs[offset[0]][offset[1]];\n      };\n\n      BufferList.prototype.slice = function slice(start, end) {\n        if (typeof start === 'number' && start < 0) {\n          start += this.length;\n        }\n\n        if (typeof end === 'number' && end < 0) {\n          end += this.length;\n        }\n\n        return this.copy(null, 0, start, end);\n      };\n\n      BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {\n        if (typeof srcStart !== 'number' || srcStart < 0) {\n          srcStart = 0;\n        }\n\n        if (typeof srcEnd !== 'number' || srcEnd > this.length) {\n          srcEnd = this.length;\n        }\n\n        if (srcStart >= this.length) {\n          return dst || Buffer.alloc(0);\n        }\n\n        if (srcEnd <= 0) {\n          return dst || Buffer.alloc(0);\n        }\n\n        const copy = !!dst;\n\n        const off = this._offset(srcStart);\n\n        const len = srcEnd - srcStart;\n        let bytes = len;\n        let bufoff = copy && dstStart || 0;\n        let start = off[1]; // copy/slice everything\n\n        if (srcStart === 0 && srcEnd === this.length) {\n          if (!copy) {\n            // slice, but full concat if multiple buffers\n            return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);\n          } // copy, need to copy individual buffers\n\n\n          for (let i = 0; i < this._bufs.length; i++) {\n            this._bufs[i].copy(dst, bufoff);\n\n            bufoff += this._bufs[i].length;\n          }\n\n          return dst;\n        } // easy, cheap case where it's a subset of one of the buffers\n\n\n        if (bytes <= this._bufs[off[0]].length - start) {\n          return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);\n        }\n\n        if (!copy) {\n          // a slice, we need something to copy in to\n          dst = Buffer.allocUnsafe(len);\n        }\n\n        for (let i = off[0]; i < this._bufs.length; i++) {\n          const l = this._bufs[i].length - start;\n\n          if (bytes > l) {\n            this._bufs[i].copy(dst, bufoff, start);\n\n            bufoff += l;\n          } else {\n            this._bufs[i].copy(dst, bufoff, start, start + bytes);\n\n            bufoff += l;\n            break;\n          }\n\n          bytes -= l;\n\n          if (start) {\n            start = 0;\n          }\n        } // safeguard so that we don't return uninitialized memory\n\n\n        if (dst.length > bufoff) return dst.slice(0, bufoff);\n        return dst;\n      };\n\n      BufferList.prototype.shallowSlice = function shallowSlice(start, end) {\n        start = start || 0;\n        end = typeof end !== 'number' ? this.length : end;\n\n        if (start < 0) {\n          start += this.length;\n        }\n\n        if (end < 0) {\n          end += this.length;\n        }\n\n        if (start === end) {\n          return this._new();\n        }\n\n        const startOffset = this._offset(start);\n\n        const endOffset = this._offset(end);\n\n        const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);\n\n        if (endOffset[1] === 0) {\n          buffers.pop();\n        } else {\n          buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);\n        }\n\n        if (startOffset[1] !== 0) {\n          buffers[0] = buffers[0].slice(startOffset[1]);\n        }\n\n        return this._new(buffers);\n      };\n\n      BufferList.prototype.toString = function toString(encoding, start, end) {\n        return this.slice(start, end).toString(encoding);\n      };\n\n      BufferList.prototype.consume = function consume(bytes) {\n        // first, normalize the argument, in accordance with how Buffer does it\n        bytes = Math.trunc(bytes); // do nothing if not a positive number\n\n        if (Number.isNaN(bytes) || bytes <= 0) return this;\n\n        while (this._bufs.length) {\n          if (bytes >= this._bufs[0].length) {\n            bytes -= this._bufs[0].length;\n            this.length -= this._bufs[0].length;\n\n            this._bufs.shift();\n          } else {\n            this._bufs[0] = this._bufs[0].slice(bytes);\n            this.length -= bytes;\n            break;\n          }\n        }\n\n        return this;\n      };\n\n      BufferList.prototype.duplicate = function duplicate() {\n        const copy = this._new();\n\n        for (let i = 0; i < this._bufs.length; i++) {\n          copy.append(this._bufs[i]);\n        }\n\n        return copy;\n      };\n\n      BufferList.prototype.append = function append(buf) {\n        if (buf == null) {\n          return this;\n        }\n\n        if (buf.buffer) {\n          // append a view of the underlying ArrayBuffer\n          this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));\n        } else if (Array.isArray(buf)) {\n          for (let i = 0; i < buf.length; i++) {\n            this.append(buf[i]);\n          }\n        } else if (this._isBufferList(buf)) {\n          // unwrap argument into individual BufferLists\n          for (let i = 0; i < buf._bufs.length; i++) {\n            this.append(buf._bufs[i]);\n          }\n        } else {\n          // coerce number arguments to strings, since Buffer(number) does\n          // uninitialized memory allocation\n          if (typeof buf === 'number') {\n            buf = buf.toString();\n          }\n\n          this._appendBuffer(Buffer.from(buf));\n        }\n\n        return this;\n      };\n\n      BufferList.prototype._appendBuffer = function appendBuffer(buf) {\n        this._bufs.push(buf);\n\n        this.length += buf.length;\n      };\n\n      BufferList.prototype.indexOf = function (search, offset, encoding) {\n        if (encoding === undefined && typeof offset === 'string') {\n          encoding = offset;\n          offset = undefined;\n        }\n\n        if (typeof search === 'function' || Array.isArray(search)) {\n          throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.');\n        } else if (typeof search === 'number') {\n          search = Buffer.from([search]);\n        } else if (typeof search === 'string') {\n          search = Buffer.from(search, encoding);\n        } else if (this._isBufferList(search)) {\n          search = search.slice();\n        } else if (Array.isArray(search.buffer)) {\n          search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);\n        } else if (!Buffer.isBuffer(search)) {\n          search = Buffer.from(search);\n        }\n\n        offset = Number(offset || 0);\n\n        if (isNaN(offset)) {\n          offset = 0;\n        }\n\n        if (offset < 0) {\n          offset = this.length + offset;\n        }\n\n        if (offset < 0) {\n          offset = 0;\n        }\n\n        if (search.length === 0) {\n          return offset > this.length ? this.length : offset;\n        }\n\n        const blOffset = this._offset(offset);\n\n        let blIndex = blOffset[0]; // index of which internal buffer we're working on\n\n        let buffOffset = blOffset[1]; // offset of the internal buffer we're working on\n        // scan over each buffer\n\n        for (; blIndex < this._bufs.length; blIndex++) {\n          const buff = this._bufs[blIndex];\n\n          while (buffOffset < buff.length) {\n            const availableWindow = buff.length - buffOffset;\n\n            if (availableWindow >= search.length) {\n              const nativeSearchResult = buff.indexOf(search, buffOffset);\n\n              if (nativeSearchResult !== -1) {\n                return this._reverseOffset([blIndex, nativeSearchResult]);\n              }\n\n              buffOffset = buff.length - search.length + 1; // end of native search window\n            } else {\n              const revOffset = this._reverseOffset([blIndex, buffOffset]);\n\n              if (this._match(revOffset, search)) {\n                return revOffset;\n              }\n\n              buffOffset++;\n            }\n          }\n\n          buffOffset = 0;\n        }\n\n        return -1;\n      };\n\n      BufferList.prototype._match = function (offset, search) {\n        if (this.length - offset < search.length) {\n          return false;\n        }\n\n        for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {\n          if (this.get(offset + searchOffset) !== search[searchOffset]) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      (function () {\n        const methods = {\n          readDoubleBE: 8,\n          readDoubleLE: 8,\n          readFloatBE: 4,\n          readFloatLE: 4,\n          readInt32BE: 4,\n          readInt32LE: 4,\n          readUInt32BE: 4,\n          readUInt32LE: 4,\n          readInt16BE: 2,\n          readInt16LE: 2,\n          readUInt16BE: 2,\n          readUInt16LE: 2,\n          readInt8: 1,\n          readUInt8: 1,\n          readIntBE: null,\n          readIntLE: null,\n          readUIntBE: null,\n          readUIntLE: null\n        };\n\n        for (const m in methods) {\n          (function (m) {\n            if (methods[m] === null) {\n              BufferList.prototype[m] = function (offset, byteLength) {\n                return this.slice(offset, offset + byteLength)[m](0, byteLength);\n              };\n            } else {\n              BufferList.prototype[m] = function (offset = 0) {\n                return this.slice(offset, offset + methods[m])[m](0);\n              };\n            }\n          })(m);\n        }\n      })(); // Used internally by the class and also as an indicator of this object being\n      // a `BufferList`. It's not possible to use `instanceof BufferList` in a browser\n      // environment because there could be multiple different copies of the\n      // BufferList class and some `BufferList`s might be `BufferList`s.\n\n\n      BufferList.prototype._isBufferList = function _isBufferList(b) {\n        return b instanceof BufferList || BufferList.isBufferList(b);\n      };\n\n      BufferList.isBufferList = function isBufferList(b) {\n        return b != null && b[symbol];\n      };\n\n      module.exports = BufferList;\n    }, {\n      \"buffer\": 3\n    }],\n    17: [function (require, module, exports) {\n      'use strict';\n\n      const DuplexStream = require('readable-stream').Duplex;\n\n      const inherits = require('inherits');\n\n      const BufferList = require('./BufferList');\n\n      function BufferListStream(callback) {\n        if (!(this instanceof BufferListStream)) {\n          return new BufferListStream(callback);\n        }\n\n        if (typeof callback === 'function') {\n          this._callback = callback;\n\n          const piper = function piper(err) {\n            if (this._callback) {\n              this._callback(err);\n\n              this._callback = null;\n            }\n          }.bind(this);\n\n          this.on('pipe', function onPipe(src) {\n            src.on('error', piper);\n          });\n          this.on('unpipe', function onUnpipe(src) {\n            src.removeListener('error', piper);\n          });\n          callback = null;\n        }\n\n        BufferList._init.call(this, callback);\n\n        DuplexStream.call(this);\n      }\n\n      inherits(BufferListStream, DuplexStream);\n      Object.assign(BufferListStream.prototype, BufferList.prototype);\n\n      BufferListStream.prototype._new = function _new(callback) {\n        return new BufferListStream(callback);\n      };\n\n      BufferListStream.prototype._write = function _write(buf, encoding, callback) {\n        this._appendBuffer(buf);\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n      };\n\n      BufferListStream.prototype._read = function _read(size) {\n        if (!this.length) {\n          return this.push(null);\n        }\n\n        size = Math.min(size, this.length);\n        this.push(this.slice(0, size));\n        this.consume(size);\n      };\n\n      BufferListStream.prototype.end = function end(chunk) {\n        DuplexStream.prototype.end.call(this, chunk);\n\n        if (this._callback) {\n          this._callback(null, this.slice());\n\n          this._callback = null;\n        }\n      };\n\n      BufferListStream.prototype._destroy = function _destroy(err, cb) {\n        this._bufs.length = 0;\n        this.length = 0;\n        cb(err);\n      };\n\n      BufferListStream.prototype._isBufferList = function _isBufferList(b) {\n        return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);\n      };\n\n      BufferListStream.isBufferList = BufferList.isBufferList;\n      module.exports = BufferListStream;\n      module.exports.BufferListStream = BufferListStream;\n      module.exports.BufferList = BufferList;\n    }, {\n      \"./BufferList\": 16,\n      \"inherits\": 34,\n      \"readable-stream\": 60\n    }],\n    18: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // NOTE: These type checking functions intentionally don't use `instanceof`\n          // because it is fragile and can be easily faked with `Object.create()`.\n          function isArray(arg) {\n            if (Array.isArray) {\n              return Array.isArray(arg);\n            }\n\n            return objectToString(arg) === '[object Array]';\n          }\n\n          exports.isArray = isArray;\n\n          function isBoolean(arg) {\n            return typeof arg === 'boolean';\n          }\n\n          exports.isBoolean = isBoolean;\n\n          function isNull(arg) {\n            return arg === null;\n          }\n\n          exports.isNull = isNull;\n\n          function isNullOrUndefined(arg) {\n            return arg == null;\n          }\n\n          exports.isNullOrUndefined = isNullOrUndefined;\n\n          function isNumber(arg) {\n            return typeof arg === 'number';\n          }\n\n          exports.isNumber = isNumber;\n\n          function isString(arg) {\n            return typeof arg === 'string';\n          }\n\n          exports.isString = isString;\n\n          function isSymbol(arg) {\n            return typeof arg === 'symbol';\n          }\n\n          exports.isSymbol = isSymbol;\n\n          function isUndefined(arg) {\n            return arg === void 0;\n          }\n\n          exports.isUndefined = isUndefined;\n\n          function isRegExp(re) {\n            return objectToString(re) === '[object RegExp]';\n          }\n\n          exports.isRegExp = isRegExp;\n\n          function isObject(arg) {\n            return typeof arg === 'object' && arg !== null;\n          }\n\n          exports.isObject = isObject;\n\n          function isDate(d) {\n            return objectToString(d) === '[object Date]';\n          }\n\n          exports.isDate = isDate;\n\n          function isError(e) {\n            return objectToString(e) === '[object Error]' || e instanceof Error;\n          }\n\n          exports.isError = isError;\n\n          function isFunction(arg) {\n            return typeof arg === 'function';\n          }\n\n          exports.isFunction = isFunction;\n\n          function isPrimitive(arg) {\n            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol\n            typeof arg === 'undefined';\n          }\n\n          exports.isPrimitive = isPrimitive;\n          exports.isBuffer = Buffer.isBuffer;\n\n          function objectToString(o) {\n            return Object.prototype.toString.call(o);\n          }\n        }).call(this);\n      }).call(this, {\n        \"isBuffer\": require(\"../../../../is-buffer/index.js\")\n      });\n    }, {\n      \"../../../../is-buffer/index.js\": 6\n    }],\n    19: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          /* eslint-env browser */\n\n          /**\n           * This is the web browser implementation of `debug()`.\n           */\n          exports.formatArgs = formatArgs;\n          exports.save = save;\n          exports.load = load;\n          exports.useColors = useColors;\n          exports.storage = localstorage();\n\n          exports.destroy = (() => {\n            let warned = false;\n            return () => {\n              if (!warned) {\n                warned = true;\n                console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n              }\n            };\n          })();\n          /**\n           * Colors.\n           */\n\n\n          exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n          /**\n           * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n           * and the Firebug extension (any Firefox version) are known\n           * to support \"%c\" CSS customizations.\n           *\n           * TODO: add a `localStorage` variable to explicitly enable/disable colors\n           */\n          // eslint-disable-next-line complexity\n\n          function useColors() {\n            // NB: In an Electron preload script, document will be defined but not fully\n            // initialized. Since we know we're in Chrome, we'll just detect this case\n            // explicitly\n            if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n              return true;\n            } // Internet Explorer and Edge do not support colors.\n\n\n            if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n              return false;\n            } // Is webkit? http://stackoverflow.com/a/16459606/376773\n            // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n            return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n          }\n          /**\n           * Colorize log arguments if enabled.\n           *\n           * @api public\n           */\n\n\n          function formatArgs(args) {\n            args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n            if (!this.useColors) {\n              return;\n            }\n\n            const c = 'color: ' + this.color;\n            args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n            // arguments passed either before or after the %c, so we need to\n            // figure out the correct index to insert the CSS into\n\n            let index = 0;\n            let lastC = 0;\n            args[0].replace(/%[a-zA-Z%]/g, match => {\n              if (match === '%%') {\n                return;\n              }\n\n              index++;\n\n              if (match === '%c') {\n                // We only are interested in the *last* %c\n                // (the user may have provided their own)\n                lastC = index;\n              }\n            });\n            args.splice(lastC, 0, c);\n          }\n          /**\n           * Invokes `console.debug()` when available.\n           * No-op when `console.debug` is not a \"function\".\n           * If `console.debug` is not available, falls back\n           * to `console.log`.\n           *\n           * @api public\n           */\n\n\n          exports.log = console.debug || console.log || (() => {});\n          /**\n           * Save `namespaces`.\n           *\n           * @param {String} namespaces\n           * @api private\n           */\n\n\n          function save(namespaces) {\n            try {\n              if (namespaces) {\n                exports.storage.setItem('debug', namespaces);\n              } else {\n                exports.storage.removeItem('debug');\n              }\n            } catch (error) {// Swallow\n              // XXX (@Qix-) should we be logging these?\n            }\n          }\n          /**\n           * Load `namespaces`.\n           *\n           * @return {String} returns the previously persisted debug modes\n           * @api private\n           */\n\n\n          function load() {\n            let r;\n\n            try {\n              r = exports.storage.getItem('debug');\n            } catch (error) {// Swallow\n              // XXX (@Qix-) should we be logging these?\n            } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n            if (!r && typeof process !== 'undefined' && 'env' in process) {\n              r = process.env.DEBUG;\n            }\n\n            return r;\n          }\n          /**\n           * Localstorage attempts to return the localstorage.\n           *\n           * This is necessary because safari throws\n           * when a user disables cookies/localstorage\n           * and you attempt to access it.\n           *\n           * @return {LocalStorage}\n           * @api private\n           */\n\n\n          function localstorage() {\n            try {\n              // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n              // The Browser also has localStorage in the global context.\n              return localStorage;\n            } catch (error) {// Swallow\n              // XXX (@Qix-) should we be logging these?\n            }\n          }\n\n          module.exports = require('./common')(exports);\n          const {\n            formatters\n          } = module.exports;\n          /**\n           * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n           */\n\n          formatters.j = function (v) {\n            try {\n              return JSON.stringify(v);\n            } catch (error) {\n              return '[UnexpectedJSONParseError]: ' + error.message;\n            }\n          };\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"./common\": 20,\n      \"_process\": 69\n    }],\n    20: [function (require, module, exports) {\n      /**\n       * This is the common logic for both the Node.js and web browser\n       * implementations of `debug()`.\n       */\n      function setup(env) {\n        createDebug.debug = createDebug;\n        createDebug.default = createDebug;\n        createDebug.coerce = coerce;\n        createDebug.disable = disable;\n        createDebug.enable = enable;\n        createDebug.enabled = enabled;\n        createDebug.humanize = require('ms');\n        createDebug.destroy = destroy;\n        Object.keys(env).forEach(key => {\n          createDebug[key] = env[key];\n        });\n        /**\n        * The currently active debug mode names, and names to skip.\n        */\n\n        createDebug.names = [];\n        createDebug.skips = [];\n        /**\n        * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n        *\n        * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n        */\n\n        createDebug.formatters = {};\n        /**\n        * Selects a color for a debug namespace\n        * @param {String} namespace The namespace string for the for the debug instance to be colored\n        * @return {Number|String} An ANSI color code for the given namespace\n        * @api private\n        */\n\n        function selectColor(namespace) {\n          let hash = 0;\n\n          for (let i = 0; i < namespace.length; i++) {\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n          }\n\n          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n        }\n\n        createDebug.selectColor = selectColor;\n        /**\n        * Create a debugger with the given `namespace`.\n        *\n        * @param {String} namespace\n        * @return {Function}\n        * @api public\n        */\n\n        function createDebug(namespace) {\n          let prevTime;\n          let enableOverride = null;\n\n          function debug(...args) {\n            // Disabled?\n            if (!debug.enabled) {\n              return;\n            }\n\n            const self = debug; // Set `diff` timestamp\n\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n\n            if (typeof args[0] !== 'string') {\n              // Anything else let's inspect with %O\n              args.unshift('%O');\n            } // Apply any `formatters` transformations\n\n\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n              // If we encounter an escaped % then don't increase the array index\n              if (match === '%%') {\n                return '%';\n              }\n\n              index++;\n              const formatter = createDebug.formatters[format];\n\n              if (typeof formatter === 'function') {\n                const val = args[index];\n                match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n                args.splice(index, 1);\n                index--;\n              }\n\n              return match;\n            }); // Apply env-specific formatting (colors, etc.)\n\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n          }\n\n          debug.namespace = namespace;\n          debug.useColors = createDebug.useColors();\n          debug.color = createDebug.selectColor(namespace);\n          debug.extend = extend;\n          debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n          Object.defineProperty(debug, 'enabled', {\n            enumerable: true,\n            configurable: false,\n            get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n            set: v => {\n              enableOverride = v;\n            }\n          }); // Env-specific initialization logic for debug instances\n\n          if (typeof createDebug.init === 'function') {\n            createDebug.init(debug);\n          }\n\n          return debug;\n        }\n\n        function extend(namespace, delimiter) {\n          const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n          newDebug.log = this.log;\n          return newDebug;\n        }\n        /**\n        * Enables a debug mode by namespaces. This can include modes\n        * separated by a colon and wildcards.\n        *\n        * @param {String} namespaces\n        * @api public\n        */\n\n\n        function enable(namespaces) {\n          createDebug.save(namespaces);\n          createDebug.names = [];\n          createDebug.skips = [];\n          let i;\n          const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n          const len = split.length;\n\n          for (i = 0; i < len; i++) {\n            if (!split[i]) {\n              // ignore empty strings\n              continue;\n            }\n\n            namespaces = split[i].replace(/\\*/g, '.*?');\n\n            if (namespaces[0] === '-') {\n              createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n            } else {\n              createDebug.names.push(new RegExp('^' + namespaces + '$'));\n            }\n          }\n        }\n        /**\n        * Disable debug output.\n        *\n        * @return {String} namespaces\n        * @api public\n        */\n\n\n        function disable() {\n          const namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)].join(',');\n          createDebug.enable('');\n          return namespaces;\n        }\n        /**\n        * Returns true if the given mode name is enabled, false otherwise.\n        *\n        * @param {String} name\n        * @return {Boolean}\n        * @api public\n        */\n\n\n        function enabled(name) {\n          if (name[name.length - 1] === '*') {\n            return true;\n          }\n\n          let i;\n          let len;\n\n          for (i = 0, len = createDebug.skips.length; i < len; i++) {\n            if (createDebug.skips[i].test(name)) {\n              return false;\n            }\n          }\n\n          for (i = 0, len = createDebug.names.length; i < len; i++) {\n            if (createDebug.names[i].test(name)) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n        /**\n        * Convert regexp to namespace\n        *\n        * @param {RegExp} regxep\n        * @return {String} namespace\n        * @api private\n        */\n\n\n        function toNamespace(regexp) {\n          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n        }\n        /**\n        * Coerce `val`.\n        *\n        * @param {Mixed} val\n        * @return {Mixed}\n        * @api private\n        */\n\n\n        function coerce(val) {\n          if (val instanceof Error) {\n            return val.stack || val.message;\n          }\n\n          return val;\n        }\n        /**\n        * XXX DO NOT USE. This is a temporary stub function.\n        * XXX It WILL be removed in the next major release.\n        */\n\n\n        function destroy() {\n          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n        }\n\n        createDebug.enable(createDebug.load());\n        return createDebug;\n      }\n\n      module.exports = setup;\n    }, {\n      \"ms\": 43\n    }],\n    21: [function (require, module, exports) {\n      (function (process, Buffer) {\n        (function () {\n          var stream = require('readable-stream');\n\n          var eos = require('end-of-stream');\n\n          var inherits = require('inherits');\n\n          var shift = require('stream-shift');\n\n          var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);\n\n          var onuncork = function (self, fn) {\n            if (self._corked) self.once('uncork', fn);else fn();\n          };\n\n          var autoDestroy = function (self, err) {\n            if (self._autoDestroy) self.destroy(err);\n          };\n\n          var destroyer = function (self, end) {\n            return function (err) {\n              if (err) autoDestroy(self, err.message === 'premature close' ? null : err);else if (end && !self._ended) self.end();\n            };\n          };\n\n          var end = function (ws, fn) {\n            if (!ws) return fn();\n            if (ws._writableState && ws._writableState.finished) return fn();\n            if (ws._writableState) return ws.end(fn);\n            ws.end();\n            fn();\n          };\n\n          var toStreams2 = function (rs) {\n            return new stream.Readable({\n              objectMode: true,\n              highWaterMark: 16\n            }).wrap(rs);\n          };\n\n          var Duplexify = function (writable, readable, opts) {\n            if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts);\n            stream.Duplex.call(this, opts);\n            this._writable = null;\n            this._readable = null;\n            this._readable2 = null;\n            this._autoDestroy = !opts || opts.autoDestroy !== false;\n            this._forwardDestroy = !opts || opts.destroy !== false;\n            this._forwardEnd = !opts || opts.end !== false;\n            this._corked = 1; // start corked\n\n            this._ondrain = null;\n            this._drained = false;\n            this._forwarding = false;\n            this._unwrite = null;\n            this._unread = null;\n            this._ended = false;\n            this.destroyed = false;\n            if (writable) this.setWritable(writable);\n            if (readable) this.setReadable(readable);\n          };\n\n          inherits(Duplexify, stream.Duplex);\n\n          Duplexify.obj = function (writable, readable, opts) {\n            if (!opts) opts = {};\n            opts.objectMode = true;\n            opts.highWaterMark = 16;\n            return new Duplexify(writable, readable, opts);\n          };\n\n          Duplexify.prototype.cork = function () {\n            if (++this._corked === 1) this.emit('cork');\n          };\n\n          Duplexify.prototype.uncork = function () {\n            if (this._corked && --this._corked === 0) this.emit('uncork');\n          };\n\n          Duplexify.prototype.setWritable = function (writable) {\n            if (this._unwrite) this._unwrite();\n\n            if (this.destroyed) {\n              if (writable && writable.destroy) writable.destroy();\n              return;\n            }\n\n            if (writable === null || writable === false) {\n              this.end();\n              return;\n            }\n\n            var self = this;\n            var unend = eos(writable, {\n              writable: true,\n              readable: false\n            }, destroyer(this, this._forwardEnd));\n\n            var ondrain = function () {\n              var ondrain = self._ondrain;\n              self._ondrain = null;\n              if (ondrain) ondrain();\n            };\n\n            var clear = function () {\n              self._writable.removeListener('drain', ondrain);\n\n              unend();\n            };\n\n            if (this._unwrite) process.nextTick(ondrain); // force a drain on stream reset to avoid livelocks\n\n            this._writable = writable;\n\n            this._writable.on('drain', ondrain);\n\n            this._unwrite = clear;\n            this.uncork(); // always uncork setWritable\n          };\n\n          Duplexify.prototype.setReadable = function (readable) {\n            if (this._unread) this._unread();\n\n            if (this.destroyed) {\n              if (readable && readable.destroy) readable.destroy();\n              return;\n            }\n\n            if (readable === null || readable === false) {\n              this.push(null);\n              this.resume();\n              return;\n            }\n\n            var self = this;\n            var unend = eos(readable, {\n              writable: false,\n              readable: true\n            }, destroyer(this));\n\n            var onreadable = function () {\n              self._forward();\n            };\n\n            var onend = function () {\n              self.push(null);\n            };\n\n            var clear = function () {\n              self._readable2.removeListener('readable', onreadable);\n\n              self._readable2.removeListener('end', onend);\n\n              unend();\n            };\n\n            this._drained = true;\n            this._readable = readable;\n            this._readable2 = readable._readableState ? readable : toStreams2(readable);\n\n            this._readable2.on('readable', onreadable);\n\n            this._readable2.on('end', onend);\n\n            this._unread = clear;\n\n            this._forward();\n          };\n\n          Duplexify.prototype._read = function () {\n            this._drained = true;\n\n            this._forward();\n          };\n\n          Duplexify.prototype._forward = function () {\n            if (this._forwarding || !this._readable2 || !this._drained) return;\n            this._forwarding = true;\n            var data;\n\n            while (this._drained && (data = shift(this._readable2)) !== null) {\n              if (this.destroyed) continue;\n              this._drained = this.push(data);\n            }\n\n            this._forwarding = false;\n          };\n\n          Duplexify.prototype.destroy = function (err) {\n            if (this.destroyed) return;\n            this.destroyed = true;\n            var self = this;\n            process.nextTick(function () {\n              self._destroy(err);\n            });\n          };\n\n          Duplexify.prototype._destroy = function (err) {\n            if (err) {\n              var ondrain = this._ondrain;\n              this._ondrain = null;\n              if (ondrain) ondrain(err);else this.emit('error', err);\n            }\n\n            if (this._forwardDestroy) {\n              if (this._readable && this._readable.destroy) this._readable.destroy();\n              if (this._writable && this._writable.destroy) this._writable.destroy();\n            }\n\n            this.emit('close');\n          };\n\n          Duplexify.prototype._write = function (data, enc, cb) {\n            if (this.destroyed) return cb();\n            if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb));\n            if (data === SIGNAL_FLUSH) return this._finish(cb);\n            if (!this._writable) return cb();\n            if (this._writable.write(data) === false) this._ondrain = cb;else cb();\n          };\n\n          Duplexify.prototype._finish = function (cb) {\n            var self = this;\n            this.emit('preend');\n            onuncork(this, function () {\n              end(self._forwardEnd && self._writable, function () {\n                // haxx to not emit prefinish twice\n                if (self._writableState.prefinished === false) self._writableState.prefinished = true;\n                self.emit('prefinish');\n                onuncork(self, cb);\n              });\n            });\n          };\n\n          Duplexify.prototype.end = function (data, enc, cb) {\n            if (typeof data === 'function') return this.end(null, null, data);\n            if (typeof enc === 'function') return this.end(data, null, enc);\n            this._ended = true;\n            if (data) this.write(data);\n            if (!this._writableState.ending) this.write(SIGNAL_FLUSH);\n            return stream.Writable.prototype.end.call(this, cb);\n          };\n\n          module.exports = Duplexify;\n        }).call(this);\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, {\n      \"_process\": 69,\n      \"buffer\": 3,\n      \"end-of-stream\": 33,\n      \"inherits\": 34,\n      \"readable-stream\": 30,\n      \"stream-shift\": 63\n    }],\n    22: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a duplex stream is just a stream that is both readable and writable.\n      // Since JS doesn't have multiple prototypal inheritance, this class\n      // prototypally inherits from Readable, and then parasitically from\n      // Writable.\n      'use strict';\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n      /*<replacement>*/\n\n\n      var objectKeys = Object.keys || function (obj) {\n        var keys = [];\n\n        for (var key in obj) {\n          keys.push(key);\n        }\n\n        return keys;\n      };\n      /*</replacement>*/\n\n\n      module.exports = Duplex;\n      /*<replacement>*/\n\n      var util = Object.create(require('core-util-is'));\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      var Readable = require('./_stream_readable');\n\n      var Writable = require('./_stream_writable');\n\n      util.inherits(Duplex, Readable);\n      {\n        // avoid scope creep, the keys array can then be collected\n        var keys = objectKeys(Writable.prototype);\n\n        for (var v = 0; v < keys.length; v++) {\n          var method = keys[v];\n          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n        }\n      }\n\n      function Duplex(options) {\n        if (!(this instanceof Duplex)) return new Duplex(options);\n        Readable.call(this, options);\n        Writable.call(this, options);\n        if (options && options.readable === false) this.readable = false;\n        if (options && options.writable === false) this.writable = false;\n        this.allowHalfOpen = true;\n        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n        this.once('end', onend);\n      }\n\n      Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n        // making it explicit this property is not enumerable\n        // because otherwise some prototype manipulation in\n        // userland will fail\n        enumerable: false,\n        get: function () {\n          return this._writableState.highWaterMark;\n        }\n      }); // the no-half-open enforcer\n\n      function onend() {\n        // if we allow half-open state, or if the writable side ended,\n        // then we're ok.\n        if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.\n        // But allow more writes to happen in this tick.\n\n        pna.nextTick(onEndNT, this);\n      }\n\n      function onEndNT(self) {\n        self.end();\n      }\n\n      Object.defineProperty(Duplex.prototype, 'destroyed', {\n        get: function () {\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return false;\n          }\n\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set: function (value) {\n          // we ignore the value if the stream\n          // has not been initialized yet\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return;\n          } // backward compatibility, the user is explicitly\n          // managing destroyed\n\n\n          this._readableState.destroyed = value;\n          this._writableState.destroyed = value;\n        }\n      });\n\n      Duplex.prototype._destroy = function (err, cb) {\n        this.push(null);\n        this.end();\n        pna.nextTick(cb, err);\n      };\n    }, {\n      \"./_stream_readable\": 24,\n      \"./_stream_writable\": 26,\n      \"core-util-is\": 18,\n      \"inherits\": 34,\n      \"process-nextick-args\": 45\n    }],\n    23: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a passthrough stream.\n      // basically just the most minimal sort of Transform stream.\n      // Every written chunk gets output as-is.\n      'use strict';\n\n      module.exports = PassThrough;\n\n      var Transform = require('./_stream_transform');\n      /*<replacement>*/\n\n\n      var util = Object.create(require('core-util-is'));\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(PassThrough, Transform);\n\n      function PassThrough(options) {\n        if (!(this instanceof PassThrough)) return new PassThrough(options);\n        Transform.call(this, options);\n      }\n\n      PassThrough.prototype._transform = function (chunk, encoding, cb) {\n        cb(null, chunk);\n      };\n    }, {\n      \"./_stream_transform\": 25,\n      \"core-util-is\": 18,\n      \"inherits\": 34\n    }],\n    24: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          'use strict';\n          /*<replacement>*/\n\n          var pna = require('process-nextick-args');\n          /*</replacement>*/\n\n\n          module.exports = Readable;\n          /*<replacement>*/\n\n          var isArray = require('isarray');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Duplex;\n          /*</replacement>*/\n\n          Readable.ReadableState = ReadableState;\n          /*<replacement>*/\n\n          var EE = require('events').EventEmitter;\n\n          var EElistenerCount = function (emitter, type) {\n            return emitter.listeners(type).length;\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Stream = require('./internal/streams/stream');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Buffer = require('safe-buffer').Buffer;\n\n          var OurUint8Array = global.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var util = Object.create(require('core-util-is'));\n          util.inherits = require('inherits');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var debugUtil = require('util');\n\n          var debug = void 0;\n\n          if (debugUtil && debugUtil.debuglog) {\n            debug = debugUtil.debuglog('stream');\n          } else {\n            debug = function () {};\n          }\n          /*</replacement>*/\n\n\n          var BufferList = require('./internal/streams/BufferList');\n\n          var destroyImpl = require('./internal/streams/destroy');\n\n          var StringDecoder;\n          util.inherits(Readable, Stream);\n          var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\n          function prependListener(emitter, event, fn) {\n            // Sadly this is not cacheable as some libraries bundle their own\n            // event emitter implementation with them.\n            if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n            // userland ones.  NEVER DO THIS. This is here only because this code needs\n            // to continue to work with older versions of Node.js that do not include\n            // the prependListener() method. The goal is to eventually remove this hack.\n\n            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n          }\n\n          function ReadableState(options, stream) {\n            Duplex = Duplex || require('./_stream_duplex');\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream.\n            // These options can be provided separately as readableXXX and writableXXX.\n\n            var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n            // make all the buffer merging and length checks go away\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n            // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n            var hwm = options.highWaterMark;\n            var readableHwm = options.readableHighWaterMark;\n            var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n            if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.\n\n            this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the\n            // linked list can remove elements from the beginning faster than\n            // array.shift()\n\n            this.buffer = new BufferList();\n            this.length = 0;\n            this.pipes = null;\n            this.pipesCount = 0;\n            this.flowing = null;\n            this.ended = false;\n            this.endEmitted = false;\n            this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n            // immediately, or on a later tick.  We set this to true at first, because\n            // any actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first read call.\n\n            this.sync = true; // whenever we return null, then we set a flag to say\n            // that we're awaiting a 'readable' event emission.\n\n            this.needReadable = false;\n            this.emittedReadable = false;\n            this.readableListening = false;\n            this.resumeScheduled = false; // has it been destroyed\n\n            this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n            this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n            this.readingMore = false;\n            this.decoder = null;\n            this.encoding = null;\n\n            if (options.encoding) {\n              if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n              this.decoder = new StringDecoder(options.encoding);\n              this.encoding = options.encoding;\n            }\n          }\n\n          function Readable(options) {\n            Duplex = Duplex || require('./_stream_duplex');\n            if (!(this instanceof Readable)) return new Readable(options);\n            this._readableState = new ReadableState(options, this); // legacy\n\n            this.readable = true;\n\n            if (options) {\n              if (typeof options.read === 'function') this._read = options.read;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n            }\n\n            Stream.call(this);\n          }\n\n          Object.defineProperty(Readable.prototype, 'destroyed', {\n            get: function () {\n              if (this._readableState === undefined) {\n                return false;\n              }\n\n              return this._readableState.destroyed;\n            },\n            set: function (value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._readableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._readableState.destroyed = value;\n            }\n          });\n          Readable.prototype.destroy = destroyImpl.destroy;\n          Readable.prototype._undestroy = destroyImpl.undestroy;\n\n          Readable.prototype._destroy = function (err, cb) {\n            this.push(null);\n            cb(err);\n          }; // Manually shove something into the read() buffer.\n          // This returns true if the highWaterMark has not been hit yet,\n          // similar to how Writable.write() returns true if you should\n          // write() some more.\n\n\n          Readable.prototype.push = function (chunk, encoding) {\n            var state = this._readableState;\n            var skipChunkCheck;\n\n            if (!state.objectMode) {\n              if (typeof chunk === 'string') {\n                encoding = encoding || state.defaultEncoding;\n\n                if (encoding !== state.encoding) {\n                  chunk = Buffer.from(chunk, encoding);\n                  encoding = '';\n                }\n\n                skipChunkCheck = true;\n              }\n            } else {\n              skipChunkCheck = true;\n            }\n\n            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n          }; // Unshift should *always* be something directly out of read()\n\n\n          Readable.prototype.unshift = function (chunk) {\n            return readableAddChunk(this, chunk, null, true, false);\n          };\n\n          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n            var state = stream._readableState;\n\n            if (chunk === null) {\n              state.reading = false;\n              onEofChunk(stream, state);\n            } else {\n              var er;\n              if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n              if (er) {\n                stream.emit('error', er);\n              } else if (state.objectMode || chunk && chunk.length > 0) {\n                if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                  chunk = _uint8ArrayToBuffer(chunk);\n                }\n\n                if (addToFront) {\n                  if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n                } else if (state.ended) {\n                  stream.emit('error', new Error('stream.push() after EOF'));\n                } else {\n                  state.reading = false;\n\n                  if (state.decoder && !encoding) {\n                    chunk = state.decoder.write(chunk);\n                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n                  } else {\n                    addChunk(stream, state, chunk, false);\n                  }\n                }\n              } else if (!addToFront) {\n                state.reading = false;\n              }\n            }\n\n            return needMoreData(state);\n          }\n\n          function addChunk(stream, state, chunk, addToFront) {\n            if (state.flowing && state.length === 0 && !state.sync) {\n              stream.emit('data', chunk);\n              stream.read(0);\n            } else {\n              // update the buffer info.\n              state.length += state.objectMode ? 1 : chunk.length;\n              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n              if (state.needReadable) emitReadable(stream);\n            }\n\n            maybeReadMore(stream, state);\n          }\n\n          function chunkInvalid(state, chunk) {\n            var er;\n\n            if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n              er = new TypeError('Invalid non-string/buffer chunk');\n            }\n\n            return er;\n          } // if it's past the high water mark, we can push in some more.\n          // Also, if we have no data yet, we can stand some\n          // more bytes.  This is to work around cases where hwm=0,\n          // such as the repl.  Also, if the push() triggered a\n          // readable event, and the user called read(largeNumber) such that\n          // needReadable was set, then we ought to push more, so that another\n          // 'readable' event will be triggered.\n\n\n          function needMoreData(state) {\n            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n          }\n\n          Readable.prototype.isPaused = function () {\n            return this._readableState.flowing === false;\n          }; // backwards compatibility.\n\n\n          Readable.prototype.setEncoding = function (enc) {\n            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n            this._readableState.decoder = new StringDecoder(enc);\n            this._readableState.encoding = enc;\n            return this;\n          }; // Don't raise the hwm > 8MB\n\n\n          var MAX_HWM = 0x800000;\n\n          function computeNewHighWaterMark(n) {\n            if (n >= MAX_HWM) {\n              n = MAX_HWM;\n            } else {\n              // Get the next highest power of 2 to prevent increasing hwm excessively in\n              // tiny amounts\n              n--;\n              n |= n >>> 1;\n              n |= n >>> 2;\n              n |= n >>> 4;\n              n |= n >>> 8;\n              n |= n >>> 16;\n              n++;\n            }\n\n            return n;\n          } // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function howMuchToRead(n, state) {\n            if (n <= 0 || state.length === 0 && state.ended) return 0;\n            if (state.objectMode) return 1;\n\n            if (n !== n) {\n              // Only flow one buffer at a time\n              if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n            } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n            if (n <= state.length) return n; // Don't have enough\n\n            if (!state.ended) {\n              state.needReadable = true;\n              return 0;\n            }\n\n            return state.length;\n          } // you can override either this method, or the async _read(n) below.\n\n\n          Readable.prototype.read = function (n) {\n            debug('read', n);\n            n = parseInt(n, 10);\n            var state = this._readableState;\n            var nOrig = n;\n            if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n            // already have a bunch of data in the buffer, then just trigger\n            // the 'readable' event and move on.\n\n            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n              debug('read: emitReadable', state.length, state.ended);\n              if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n              return null;\n            }\n\n            n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n            if (n === 0 && state.ended) {\n              if (state.length === 0) endReadable(this);\n              return null;\n            } // All the actual chunk generation logic needs to be\n            // *below* the call to _read.  The reason is that in certain\n            // synthetic stream cases, such as passthrough streams, _read\n            // may be a completely synchronous operation which may change\n            // the state of the read buffer, providing enough data when\n            // before there was *not* enough.\n            //\n            // So, the steps are:\n            // 1. Figure out what the state of things will be after we do\n            // a read from the buffer.\n            //\n            // 2. If that resulting state will trigger a _read, then call _read.\n            // Note that this may be asynchronous, or synchronous.  Yes, it is\n            // deeply ugly to write APIs this way, but that still doesn't mean\n            // that the Readable class should behave improperly, as streams are\n            // designed to be sync/async agnostic.\n            // Take note if the _read call is sync or async (ie, if the read call\n            // has returned yet), so that we know whether or not it's safe to emit\n            // 'readable' etc.\n            //\n            // 3. Actually pull the requested chunks out of the buffer and return.\n            // if we need a readable event, then we need to do some reading.\n\n\n            var doRead = state.needReadable;\n            debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n            if (state.length === 0 || state.length - n < state.highWaterMark) {\n              doRead = true;\n              debug('length less than watermark', doRead);\n            } // however, if we've ended, then there's no point, and if we're already\n            // reading, then it's unnecessary.\n\n\n            if (state.ended || state.reading) {\n              doRead = false;\n              debug('reading or ended', doRead);\n            } else if (doRead) {\n              debug('do read');\n              state.reading = true;\n              state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n              if (state.length === 0) state.needReadable = true; // call internal read method\n\n              this._read(state.highWaterMark);\n\n              state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n              // and we need to re-evaluate how much data we can return to the user.\n\n              if (!state.reading) n = howMuchToRead(nOrig, state);\n            }\n\n            var ret;\n            if (n > 0) ret = fromList(n, state);else ret = null;\n\n            if (ret === null) {\n              state.needReadable = true;\n              n = 0;\n            } else {\n              state.length -= n;\n            }\n\n            if (state.length === 0) {\n              // If we have nothing in the buffer, then we want to know\n              // as soon as we *do* get something into the buffer.\n              if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n              if (nOrig !== n && state.ended) endReadable(this);\n            }\n\n            if (ret !== null) this.emit('data', ret);\n            return ret;\n          };\n\n          function onEofChunk(stream, state) {\n            if (state.ended) return;\n\n            if (state.decoder) {\n              var chunk = state.decoder.end();\n\n              if (chunk && chunk.length) {\n                state.buffer.push(chunk);\n                state.length += state.objectMode ? 1 : chunk.length;\n              }\n            }\n\n            state.ended = true; // emit 'readable' now to make sure it gets picked up.\n\n            emitReadable(stream);\n          } // Don't emit readable right away in sync mode, because this can trigger\n          // another read() call => stack overflow.  This way, it might trigger\n          // a nextTick recursion warning, but that's not so bad.\n\n\n          function emitReadable(stream) {\n            var state = stream._readableState;\n            state.needReadable = false;\n\n            if (!state.emittedReadable) {\n              debug('emitReadable', state.flowing);\n              state.emittedReadable = true;\n              if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n            }\n          }\n\n          function emitReadable_(stream) {\n            debug('emit readable');\n            stream.emit('readable');\n            flow(stream);\n          } // at this point, the user has presumably seen the 'readable' event,\n          // and called read() to consume some data.  that may have triggered\n          // in turn another _read(n) call, in which case reading = true if\n          // it's in progress.\n          // However, if we're not ended, or reading, and the length < hwm,\n          // then go ahead and try to read some more preemptively.\n\n\n          function maybeReadMore(stream, state) {\n            if (!state.readingMore) {\n              state.readingMore = true;\n              pna.nextTick(maybeReadMore_, stream, state);\n            }\n          }\n\n          function maybeReadMore_(stream, state) {\n            var len = state.length;\n\n            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n              debug('maybeReadMore read 0');\n              stream.read(0);\n              if (len === state.length) // didn't get any data, stop spinning.\n                break;else len = state.length;\n            }\n\n            state.readingMore = false;\n          } // abstract method.  to be overridden in specific implementation classes.\n          // call cb(er, data) where data is <= n in length.\n          // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n          // arbitrary, and perhaps not very meaningful.\n\n\n          Readable.prototype._read = function (n) {\n            this.emit('error', new Error('_read() is not implemented'));\n          };\n\n          Readable.prototype.pipe = function (dest, pipeOpts) {\n            var src = this;\n            var state = this._readableState;\n\n            switch (state.pipesCount) {\n              case 0:\n                state.pipes = dest;\n                break;\n\n              case 1:\n                state.pipes = [state.pipes, dest];\n                break;\n\n              default:\n                state.pipes.push(dest);\n                break;\n            }\n\n            state.pipesCount += 1;\n            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n            var endFn = doEnd ? onend : unpipe;\n            if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n            dest.on('unpipe', onunpipe);\n\n            function onunpipe(readable, unpipeInfo) {\n              debug('onunpipe');\n\n              if (readable === src) {\n                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                  unpipeInfo.hasUnpiped = true;\n                  cleanup();\n                }\n              }\n            }\n\n            function onend() {\n              debug('onend');\n              dest.end();\n            } // when the dest drains, it reduces the awaitDrain counter\n            // on the source.  This would be more elegant with a .once()\n            // handler in flow(), but adding and removing repeatedly is\n            // too slow.\n\n\n            var ondrain = pipeOnDrain(src);\n            dest.on('drain', ondrain);\n            var cleanedUp = false;\n\n            function cleanup() {\n              debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n              dest.removeListener('close', onclose);\n              dest.removeListener('finish', onfinish);\n              dest.removeListener('drain', ondrain);\n              dest.removeListener('error', onerror);\n              dest.removeListener('unpipe', onunpipe);\n              src.removeListener('end', onend);\n              src.removeListener('end', unpipe);\n              src.removeListener('data', ondata);\n              cleanedUp = true; // if the reader is waiting for a drain event from this\n              // specific writer, then it would cause it to never start\n              // flowing again.\n              // So, if this is awaiting a drain, then we just call it now.\n              // If we don't know, then assume that we are waiting for one.\n\n              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n            } // If the user pushes more data while we're writing to dest then we'll end up\n            // in ondata again. However, we only want to increase awaitDrain once because\n            // dest will only emit one 'drain' event for the multiple writes.\n            // => Introduce a guard on increasing awaitDrain.\n\n\n            var increasedAwaitDrain = false;\n            src.on('data', ondata);\n\n            function ondata(chunk) {\n              debug('ondata');\n              increasedAwaitDrain = false;\n              var ret = dest.write(chunk);\n\n              if (false === ret && !increasedAwaitDrain) {\n                // If the user unpiped during `dest.write()`, it is possible\n                // to get stuck in a permanently paused state if that write\n                // also returned false.\n                // => Check whether `dest` is still a piping destination.\n                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n                  debug('false write response, pause', src._readableState.awaitDrain);\n                  src._readableState.awaitDrain++;\n                  increasedAwaitDrain = true;\n                }\n\n                src.pause();\n              }\n            } // if the dest has an error, then stop piping into it.\n            // however, don't suppress the throwing behavior for this.\n\n\n            function onerror(er) {\n              debug('onerror', er);\n              unpipe();\n              dest.removeListener('error', onerror);\n              if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n            } // Make sure our error handler is attached before userland ones.\n\n\n            prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n            function onclose() {\n              dest.removeListener('finish', onfinish);\n              unpipe();\n            }\n\n            dest.once('close', onclose);\n\n            function onfinish() {\n              debug('onfinish');\n              dest.removeListener('close', onclose);\n              unpipe();\n            }\n\n            dest.once('finish', onfinish);\n\n            function unpipe() {\n              debug('unpipe');\n              src.unpipe(dest);\n            } // tell the dest that it's being piped to\n\n\n            dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n            if (!state.flowing) {\n              debug('pipe resume');\n              src.resume();\n            }\n\n            return dest;\n          };\n\n          function pipeOnDrain(src) {\n            return function () {\n              var state = src._readableState;\n              debug('pipeOnDrain', state.awaitDrain);\n              if (state.awaitDrain) state.awaitDrain--;\n\n              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n                state.flowing = true;\n                flow(src);\n              }\n            };\n          }\n\n          Readable.prototype.unpipe = function (dest) {\n            var state = this._readableState;\n            var unpipeInfo = {\n              hasUnpiped: false\n            }; // if we're not piping anywhere, then do nothing.\n\n            if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n            if (state.pipesCount === 1) {\n              // passed in one, but it's not the right one.\n              if (dest && dest !== state.pipes) return this;\n              if (!dest) dest = state.pipes; // got a match.\n\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n              if (dest) dest.emit('unpipe', this, unpipeInfo);\n              return this;\n            } // slow case. multiple pipe destinations.\n\n\n            if (!dest) {\n              // remove all.\n              var dests = state.pipes;\n              var len = state.pipesCount;\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n\n              for (var i = 0; i < len; i++) {\n                dests[i].emit('unpipe', this, unpipeInfo);\n              }\n\n              return this;\n            } // try to find the right one.\n\n\n            var index = indexOf(state.pipes, dest);\n            if (index === -1) return this;\n            state.pipes.splice(index, 1);\n            state.pipesCount -= 1;\n            if (state.pipesCount === 1) state.pipes = state.pipes[0];\n            dest.emit('unpipe', this, unpipeInfo);\n            return this;\n          }; // set up data events if they are asked for\n          // Ensure readable listeners eventually get something\n\n\n          Readable.prototype.on = function (ev, fn) {\n            var res = Stream.prototype.on.call(this, ev, fn);\n\n            if (ev === 'data') {\n              // Start flowing on next tick if stream isn't explicitly paused\n              if (this._readableState.flowing !== false) this.resume();\n            } else if (ev === 'readable') {\n              var state = this._readableState;\n\n              if (!state.endEmitted && !state.readableListening) {\n                state.readableListening = state.needReadable = true;\n                state.emittedReadable = false;\n\n                if (!state.reading) {\n                  pna.nextTick(nReadingNextTick, this);\n                } else if (state.length) {\n                  emitReadable(this);\n                }\n              }\n            }\n\n            return res;\n          };\n\n          Readable.prototype.addListener = Readable.prototype.on;\n\n          function nReadingNextTick(self) {\n            debug('readable nexttick read 0');\n            self.read(0);\n          } // pause() and resume() are remnants of the legacy readable stream API\n          // If the user uses them, then switch into old mode.\n\n\n          Readable.prototype.resume = function () {\n            var state = this._readableState;\n\n            if (!state.flowing) {\n              debug('resume');\n              state.flowing = true;\n              resume(this, state);\n            }\n\n            return this;\n          };\n\n          function resume(stream, state) {\n            if (!state.resumeScheduled) {\n              state.resumeScheduled = true;\n              pna.nextTick(resume_, stream, state);\n            }\n          }\n\n          function resume_(stream, state) {\n            if (!state.reading) {\n              debug('resume read 0');\n              stream.read(0);\n            }\n\n            state.resumeScheduled = false;\n            state.awaitDrain = 0;\n            stream.emit('resume');\n            flow(stream);\n            if (state.flowing && !state.reading) stream.read(0);\n          }\n\n          Readable.prototype.pause = function () {\n            debug('call pause flowing=%j', this._readableState.flowing);\n\n            if (false !== this._readableState.flowing) {\n              debug('pause');\n              this._readableState.flowing = false;\n              this.emit('pause');\n            }\n\n            return this;\n          };\n\n          function flow(stream) {\n            var state = stream._readableState;\n            debug('flow', state.flowing);\n\n            while (state.flowing && stream.read() !== null) {}\n          } // wrap an old-style stream as the async data source.\n          // This is *not* part of the readable stream interface.\n          // It is an ugly unfortunate mess of history.\n\n\n          Readable.prototype.wrap = function (stream) {\n            var _this = this;\n\n            var state = this._readableState;\n            var paused = false;\n            stream.on('end', function () {\n              debug('wrapped end');\n\n              if (state.decoder && !state.ended) {\n                var chunk = state.decoder.end();\n                if (chunk && chunk.length) _this.push(chunk);\n              }\n\n              _this.push(null);\n            });\n            stream.on('data', function (chunk) {\n              debug('wrapped data');\n              if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n              if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n              var ret = _this.push(chunk);\n\n              if (!ret) {\n                paused = true;\n                stream.pause();\n              }\n            }); // proxy all the other methods.\n            // important when wrapping filters and duplexes.\n\n            for (var i in stream) {\n              if (this[i] === undefined && typeof stream[i] === 'function') {\n                this[i] = function (method) {\n                  return function () {\n                    return stream[method].apply(stream, arguments);\n                  };\n                }(i);\n              }\n            } // proxy certain important events.\n\n\n            for (var n = 0; n < kProxyEvents.length; n++) {\n              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n            } // when we try to consume some more bytes, simply unpause the\n            // underlying stream.\n\n\n            this._read = function (n) {\n              debug('wrapped _read', n);\n\n              if (paused) {\n                paused = false;\n                stream.resume();\n              }\n            };\n\n            return this;\n          };\n\n          Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function () {\n              return this._readableState.highWaterMark;\n            }\n          }); // exposed for testing purposes only.\n\n          Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.\n          // Length is the combined lengths of all the buffers in the list.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n          function fromList(n, state) {\n            // nothing buffered\n            if (state.length === 0) return null;\n            var ret;\n            if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n              // read it all, truncate the list\n              if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n              state.buffer.clear();\n            } else {\n              // read part of list\n              ret = fromListPartial(n, state.buffer, state.decoder);\n            }\n            return ret;\n          } // Extracts only enough buffered data to satisfy the amount requested.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function fromListPartial(n, list, hasStrings) {\n            var ret;\n\n            if (n < list.head.data.length) {\n              // slice is the same for buffers and strings\n              ret = list.head.data.slice(0, n);\n              list.head.data = list.head.data.slice(n);\n            } else if (n === list.head.data.length) {\n              // first chunk is a perfect match\n              ret = list.shift();\n            } else {\n              // result spans more than one buffer\n              ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n            }\n\n            return ret;\n          } // Copies a specified amount of characters from the list of buffered data\n          // chunks.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function copyFromBufferString(n, list) {\n            var p = list.head;\n            var c = 1;\n            var ret = p.data;\n            n -= ret.length;\n\n            while (p = p.next) {\n              var str = p.data;\n              var nb = n > str.length ? str.length : n;\n              if (nb === str.length) ret += str;else ret += str.slice(0, n);\n              n -= nb;\n\n              if (n === 0) {\n                if (nb === str.length) {\n                  ++c;\n                  if (p.next) list.head = p.next;else list.head = list.tail = null;\n                } else {\n                  list.head = p;\n                  p.data = str.slice(nb);\n                }\n\n                break;\n              }\n\n              ++c;\n            }\n\n            list.length -= c;\n            return ret;\n          } // Copies a specified amount of bytes from the list of buffered data chunks.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function copyFromBuffer(n, list) {\n            var ret = Buffer.allocUnsafe(n);\n            var p = list.head;\n            var c = 1;\n            p.data.copy(ret);\n            n -= p.data.length;\n\n            while (p = p.next) {\n              var buf = p.data;\n              var nb = n > buf.length ? buf.length : n;\n              buf.copy(ret, ret.length - n, 0, nb);\n              n -= nb;\n\n              if (n === 0) {\n                if (nb === buf.length) {\n                  ++c;\n                  if (p.next) list.head = p.next;else list.head = list.tail = null;\n                } else {\n                  list.head = p;\n                  p.data = buf.slice(nb);\n                }\n\n                break;\n              }\n\n              ++c;\n            }\n\n            list.length -= c;\n            return ret;\n          }\n\n          function endReadable(stream) {\n            var state = stream._readableState; // If we get here before consuming all the bytes, then that is a\n            // bug in node.  Should never happen.\n\n            if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n            if (!state.endEmitted) {\n              state.ended = true;\n              pna.nextTick(endReadableNT, state, stream);\n            }\n          }\n\n          function endReadableNT(state, stream) {\n            // Check that we didn't get one last unshift.\n            if (!state.endEmitted && state.length === 0) {\n              state.endEmitted = true;\n              stream.readable = false;\n              stream.emit('end');\n            }\n          }\n\n          function indexOf(xs, x) {\n            for (var i = 0, l = xs.length; i < l; i++) {\n              if (xs[i] === x) return i;\n            }\n\n            return -1;\n          }\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./_stream_duplex\": 22,\n      \"./internal/streams/BufferList\": 27,\n      \"./internal/streams/destroy\": 28,\n      \"./internal/streams/stream\": 29,\n      \"_process\": 69,\n      \"core-util-is\": 18,\n      \"events\": 4,\n      \"inherits\": 34,\n      \"isarray\": 35,\n      \"process-nextick-args\": 45,\n      \"safe-buffer\": 31,\n      \"string_decoder/\": 32,\n      \"util\": 2\n    }],\n    25: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a transform stream is a readable/writable stream where you do\n      // something with the data.  Sometimes it's called a \"filter\",\n      // but that's not a great name for it, since that implies a thing where\n      // some bits pass through, and others are simply ignored.  (That would\n      // be a valid example of a transform, of course.)\n      //\n      // While the output is causally related to the input, it's not a\n      // necessarily symmetric or synchronous transformation.  For example,\n      // a zlib stream might take multiple plain-text writes(), and then\n      // emit a single compressed chunk some time in the future.\n      //\n      // Here's how this works:\n      //\n      // The Transform stream has all the aspects of the readable and writable\n      // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n      // internally, and returns false if there's a lot of pending writes\n      // buffered up.  When you call read(), that calls _read(n) until\n      // there's enough pending readable data buffered up.\n      //\n      // In a transform stream, the written data is placed in a buffer.  When\n      // _read(n) is called, it transforms the queued up data, calling the\n      // buffered _write cb's as it consumes chunks.  If consuming a single\n      // written chunk would result in multiple output chunks, then the first\n      // outputted bit calls the readcb, and subsequent chunks just go into\n      // the read buffer, and will cause it to emit 'readable' if necessary.\n      //\n      // This way, back-pressure is actually determined by the reading side,\n      // since _read has to be called to start processing a new chunk.  However,\n      // a pathological inflate type of transform can cause excessive buffering\n      // here.  For example, imagine a stream where every byte of input is\n      // interpreted as an integer from 0-255, and then results in that many\n      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n      // 1kb of data being output.  In this case, you could write a very small\n      // amount of input, and end up with a very large amount of output.  In\n      // such a pathological inflating mechanism, there'd be no way to tell\n      // the system to stop doing the transform.  A single 4MB write could\n      // cause the system to run out of memory.\n      //\n      // However, even in such a pathological case, only a single written chunk\n      // would be consumed, and then the rest would wait (un-transformed) until\n      // the results of the previous transformed chunk were consumed.\n      'use strict';\n\n      module.exports = Transform;\n\n      var Duplex = require('./_stream_duplex');\n      /*<replacement>*/\n\n\n      var util = Object.create(require('core-util-is'));\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(Transform, Duplex);\n\n      function afterTransform(er, data) {\n        var ts = this._transformState;\n        ts.transforming = false;\n        var cb = ts.writecb;\n\n        if (!cb) {\n          return this.emit('error', new Error('write callback called multiple times'));\n        }\n\n        ts.writechunk = null;\n        ts.writecb = null;\n        if (data != null) // single equals check for both `null` and `undefined`\n          this.push(data);\n        cb(er);\n        var rs = this._readableState;\n        rs.reading = false;\n\n        if (rs.needReadable || rs.length < rs.highWaterMark) {\n          this._read(rs.highWaterMark);\n        }\n      }\n\n      function Transform(options) {\n        if (!(this instanceof Transform)) return new Transform(options);\n        Duplex.call(this, options);\n        this._transformState = {\n          afterTransform: afterTransform.bind(this),\n          needTransform: false,\n          transforming: false,\n          writecb: null,\n          writechunk: null,\n          writeencoding: null\n        }; // start out asking for a readable event once data is transformed.\n\n        this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n        // that Readable wants before the first _read call, so unset the\n        // sync guard flag.\n\n        this._readableState.sync = false;\n\n        if (options) {\n          if (typeof options.transform === 'function') this._transform = options.transform;\n          if (typeof options.flush === 'function') this._flush = options.flush;\n        } // When the writable side finishes, then flush out anything remaining.\n\n\n        this.on('prefinish', prefinish);\n      }\n\n      function prefinish() {\n        var _this = this;\n\n        if (typeof this._flush === 'function') {\n          this._flush(function (er, data) {\n            done(_this, er, data);\n          });\n        } else {\n          done(this, null, null);\n        }\n      }\n\n      Transform.prototype.push = function (chunk, encoding) {\n        this._transformState.needTransform = false;\n        return Duplex.prototype.push.call(this, chunk, encoding);\n      }; // This is the part where you do stuff!\n      // override this function in implementation classes.\n      // 'chunk' is an input chunk.\n      //\n      // Call `push(newChunk)` to pass along transformed output\n      // to the readable side.  You may call 'push' zero or more times.\n      //\n      // Call `cb(err)` when you are done with this chunk.  If you pass\n      // an error, then that'll put the hurt on the whole operation.  If you\n      // never call cb(), then you'll never get another chunk.\n\n\n      Transform.prototype._transform = function (chunk, encoding, cb) {\n        throw new Error('_transform() is not implemented');\n      };\n\n      Transform.prototype._write = function (chunk, encoding, cb) {\n        var ts = this._transformState;\n        ts.writecb = cb;\n        ts.writechunk = chunk;\n        ts.writeencoding = encoding;\n\n        if (!ts.transforming) {\n          var rs = this._readableState;\n          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n        }\n      }; // Doesn't matter what the args are here.\n      // _transform does all the work.\n      // That we got here means that the readable side wants more data.\n\n\n      Transform.prototype._read = function (n) {\n        var ts = this._transformState;\n\n        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n          ts.transforming = true;\n\n          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n        } else {\n          // mark that we need a transform, so that any data that comes in\n          // will get processed, now that we've asked for it.\n          ts.needTransform = true;\n        }\n      };\n\n      Transform.prototype._destroy = function (err, cb) {\n        var _this2 = this;\n\n        Duplex.prototype._destroy.call(this, err, function (err2) {\n          cb(err2);\n\n          _this2.emit('close');\n        });\n      };\n\n      function done(stream, er, data) {\n        if (er) return stream.emit('error', er);\n        if (data != null) // single equals check for both `null` and `undefined`\n          stream.push(data); // if there's nothing in the write buffer, then that means\n        // that nothing more will ever be provided\n\n        if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n        if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n        return stream.push(null);\n      }\n    }, {\n      \"./_stream_duplex\": 22,\n      \"core-util-is\": 18,\n      \"inherits\": 34\n    }],\n    26: [function (require, module, exports) {\n      (function (process, global, setImmediate) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // A bit simpler than readable streams.\n          // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n          // the drain event emission and buffering.\n          'use strict';\n          /*<replacement>*/\n\n          var pna = require('process-nextick-args');\n          /*</replacement>*/\n\n\n          module.exports = Writable;\n          /* <replacement> */\n\n          function WriteReq(chunk, encoding, cb) {\n            this.chunk = chunk;\n            this.encoding = encoding;\n            this.callback = cb;\n            this.next = null;\n          } // It seems a linked list but it is not\n          // there will be only 2 of these for each stream\n\n\n          function CorkedRequest(state) {\n            var _this = this;\n\n            this.next = null;\n            this.entry = null;\n\n            this.finish = function () {\n              onCorkedFinish(_this, state);\n            };\n          }\n          /* </replacement> */\n\n          /*<replacement>*/\n\n\n          var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var Duplex;\n          /*</replacement>*/\n\n          Writable.WritableState = WritableState;\n          /*<replacement>*/\n\n          var util = Object.create(require('core-util-is'));\n          util.inherits = require('inherits');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var internalUtil = {\n            deprecate: require('util-deprecate')\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var Stream = require('./internal/streams/stream');\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Buffer = require('safe-buffer').Buffer;\n\n          var OurUint8Array = global.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n          /*</replacement>*/\n\n\n          var destroyImpl = require('./internal/streams/destroy');\n\n          util.inherits(Writable, Stream);\n\n          function nop() {}\n\n          function WritableState(options, stream) {\n            Duplex = Duplex || require('./_stream_duplex');\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream.\n            // These options can be provided separately as readableXXX and writableXXX.\n\n            var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n            // contains buffers or objects.\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n            // Note: 0 is a valid value, means that we always return false if\n            // the entire buffer is not flushed immediately on write()\n\n            var hwm = options.highWaterMark;\n            var writableHwm = options.writableHighWaterMark;\n            var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n            if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.\n\n            this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called\n\n            this.finalCalled = false; // drain event flag.\n\n            this.needDrain = false; // at the start of calling end()\n\n            this.ending = false; // when end() has been called, and returned\n\n            this.ended = false; // when 'finish' is emitted\n\n            this.finished = false; // has it been destroyed\n\n            this.destroyed = false; // should we decode strings into buffers before passing to _write?\n            // this is here so that some node-core streams can optimize string\n            // handling at a lower level.\n\n            var noDecode = options.decodeStrings === false;\n            this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n            // of how much we're waiting to get pushed to some underlying\n            // socket or file.\n\n            this.length = 0; // a flag to see when we're in the middle of a write.\n\n            this.writing = false; // when true all writes will be buffered until .uncork() call\n\n            this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n            // or on a later tick.  We set this to true at first, because any\n            // actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first write call.\n\n            this.sync = true; // a flag to know if we're processing previously buffered items, which\n            // may call the _write() callback in the same tick, so that we don't\n            // end up in an overlapped onwrite situation.\n\n            this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n            this.onwrite = function (er) {\n              onwrite(stream, er);\n            }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n            this.writecb = null; // the amount that is being written when _write is called.\n\n            this.writelen = 0;\n            this.bufferedRequest = null;\n            this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n            // this must be 0 before 'finish' can be emitted\n\n            this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n            // This is relevant for synchronous Transform streams\n\n            this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n            this.errorEmitted = false; // count buffered requests\n\n            this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n            // one allocated and free to use, and we maintain at most two\n\n            this.corkedRequestsFree = new CorkedRequest(this);\n          }\n\n          WritableState.prototype.getBuffer = function getBuffer() {\n            var current = this.bufferedRequest;\n            var out = [];\n\n            while (current) {\n              out.push(current);\n              current = current.next;\n            }\n\n            return out;\n          };\n\n          (function () {\n            try {\n              Object.defineProperty(WritableState.prototype, 'buffer', {\n                get: internalUtil.deprecate(function () {\n                  return this.getBuffer();\n                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n              });\n            } catch (_) {}\n          })(); // Test _writableState for inheritance to account for Duplex streams,\n          // whose prototype chain only points to Readable.\n\n\n          var realHasInstance;\n\n          if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n            realHasInstance = Function.prototype[Symbol.hasInstance];\n            Object.defineProperty(Writable, Symbol.hasInstance, {\n              value: function (object) {\n                if (realHasInstance.call(this, object)) return true;\n                if (this !== Writable) return false;\n                return object && object._writableState instanceof WritableState;\n              }\n            });\n          } else {\n            realHasInstance = function (object) {\n              return object instanceof this;\n            };\n          }\n\n          function Writable(options) {\n            Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n            // `realHasInstance` is necessary because using plain `instanceof`\n            // would return false, as no `_writableState` property is attached.\n            // Trying to use the custom `instanceof` for Writable here will also break the\n            // Node.js LazyTransform implementation, which has a non-trivial getter for\n            // `_writableState` that would lead to infinite recursion.\n\n            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n              return new Writable(options);\n            }\n\n            this._writableState = new WritableState(options, this); // legacy.\n\n            this.writable = true;\n\n            if (options) {\n              if (typeof options.write === 'function') this._write = options.write;\n              if (typeof options.writev === 'function') this._writev = options.writev;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n              if (typeof options.final === 'function') this._final = options.final;\n            }\n\n            Stream.call(this);\n          } // Otherwise people can pipe Writable streams, which is just wrong.\n\n\n          Writable.prototype.pipe = function () {\n            this.emit('error', new Error('Cannot pipe, not readable'));\n          };\n\n          function writeAfterEnd(stream, cb) {\n            var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb\n\n            stream.emit('error', er);\n            pna.nextTick(cb, er);\n          } // Checks that a user-supplied chunk is valid, especially for the particular\n          // mode the stream is in. Currently this means that `null` is never accepted\n          // and undefined/non-string values are only allowed in object mode.\n\n\n          function validChunk(stream, state, chunk, cb) {\n            var valid = true;\n            var er = false;\n\n            if (chunk === null) {\n              er = new TypeError('May not write null values to stream');\n            } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n              er = new TypeError('Invalid non-string/buffer chunk');\n            }\n\n            if (er) {\n              stream.emit('error', er);\n              pna.nextTick(cb, er);\n              valid = false;\n            }\n\n            return valid;\n          }\n\n          Writable.prototype.write = function (chunk, encoding, cb) {\n            var state = this._writableState;\n            var ret = false;\n\n            var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n            if (isBuf && !Buffer.isBuffer(chunk)) {\n              chunk = _uint8ArrayToBuffer(chunk);\n            }\n\n            if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n            if (typeof cb !== 'function') cb = nop;\n            if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n              state.pendingcb++;\n              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n            }\n            return ret;\n          };\n\n          Writable.prototype.cork = function () {\n            var state = this._writableState;\n            state.corked++;\n          };\n\n          Writable.prototype.uncork = function () {\n            var state = this._writableState;\n\n            if (state.corked) {\n              state.corked--;\n              if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n            }\n          };\n\n          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n            // node::ParseEncoding() requires lower case.\n            if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n            if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n            this._writableState.defaultEncoding = encoding;\n            return this;\n          };\n\n          function decodeChunk(state, chunk, encoding) {\n            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, encoding);\n            }\n\n            return chunk;\n          }\n\n          Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function () {\n              return this._writableState.highWaterMark;\n            }\n          }); // if we're already writing something, then just put this\n          // in the queue, and wait our turn.  Otherwise, call _write\n          // If we return false, then we need a drain event, so set that flag.\n\n          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n            if (!isBuf) {\n              var newChunk = decodeChunk(state, chunk, encoding);\n\n              if (chunk !== newChunk) {\n                isBuf = true;\n                encoding = 'buffer';\n                chunk = newChunk;\n              }\n            }\n\n            var len = state.objectMode ? 1 : chunk.length;\n            state.length += len;\n            var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n            if (!ret) state.needDrain = true;\n\n            if (state.writing || state.corked) {\n              var last = state.lastBufferedRequest;\n              state.lastBufferedRequest = {\n                chunk: chunk,\n                encoding: encoding,\n                isBuf: isBuf,\n                callback: cb,\n                next: null\n              };\n\n              if (last) {\n                last.next = state.lastBufferedRequest;\n              } else {\n                state.bufferedRequest = state.lastBufferedRequest;\n              }\n\n              state.bufferedRequestCount += 1;\n            } else {\n              doWrite(stream, state, false, len, chunk, encoding, cb);\n            }\n\n            return ret;\n          }\n\n          function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n            state.writelen = len;\n            state.writecb = cb;\n            state.writing = true;\n            state.sync = true;\n            if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n            state.sync = false;\n          }\n\n          function onwriteError(stream, state, sync, er, cb) {\n            --state.pendingcb;\n\n            if (sync) {\n              // defer the callback if we are being called synchronously\n              // to avoid piling up things on the stack\n              pna.nextTick(cb, er); // this can emit finish, and it will always happen\n              // after error\n\n              pna.nextTick(finishMaybe, stream, state);\n              stream._writableState.errorEmitted = true;\n              stream.emit('error', er);\n            } else {\n              // the caller expect this to happen before if\n              // it is async\n              cb(er);\n              stream._writableState.errorEmitted = true;\n              stream.emit('error', er); // this can emit finish, but finish must\n              // always follow error\n\n              finishMaybe(stream, state);\n            }\n          }\n\n          function onwriteStateUpdate(state) {\n            state.writing = false;\n            state.writecb = null;\n            state.length -= state.writelen;\n            state.writelen = 0;\n          }\n\n          function onwrite(stream, er) {\n            var state = stream._writableState;\n            var sync = state.sync;\n            var cb = state.writecb;\n            onwriteStateUpdate(state);\n            if (er) onwriteError(stream, state, sync, er, cb);else {\n              // Check if we're actually ready to finish, but don't emit yet\n              var finished = needFinish(state);\n\n              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n                clearBuffer(stream, state);\n              }\n\n              if (sync) {\n                /*<replacement>*/\n                asyncWrite(afterWrite, stream, state, finished, cb);\n                /*</replacement>*/\n              } else {\n                afterWrite(stream, state, finished, cb);\n              }\n            }\n          }\n\n          function afterWrite(stream, state, finished, cb) {\n            if (!finished) onwriteDrain(stream, state);\n            state.pendingcb--;\n            cb();\n            finishMaybe(stream, state);\n          } // Must force callback to be called on nextTick, so that we don't\n          // emit 'drain' before the write() consumer gets the 'false' return\n          // value, and has a chance to attach a 'drain' listener.\n\n\n          function onwriteDrain(stream, state) {\n            if (state.length === 0 && state.needDrain) {\n              state.needDrain = false;\n              stream.emit('drain');\n            }\n          } // if there's something in the buffer waiting, then process it\n\n\n          function clearBuffer(stream, state) {\n            state.bufferProcessing = true;\n            var entry = state.bufferedRequest;\n\n            if (stream._writev && entry && entry.next) {\n              // Fast case, write everything using _writev()\n              var l = state.bufferedRequestCount;\n              var buffer = new Array(l);\n              var holder = state.corkedRequestsFree;\n              holder.entry = entry;\n              var count = 0;\n              var allBuffers = true;\n\n              while (entry) {\n                buffer[count] = entry;\n                if (!entry.isBuf) allBuffers = false;\n                entry = entry.next;\n                count += 1;\n              }\n\n              buffer.allBuffers = allBuffers;\n              doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n              // as the hot path ends with doWrite\n\n              state.pendingcb++;\n              state.lastBufferedRequest = null;\n\n              if (holder.next) {\n                state.corkedRequestsFree = holder.next;\n                holder.next = null;\n              } else {\n                state.corkedRequestsFree = new CorkedRequest(state);\n              }\n\n              state.bufferedRequestCount = 0;\n            } else {\n              // Slow case, write chunks one-by-one\n              while (entry) {\n                var chunk = entry.chunk;\n                var encoding = entry.encoding;\n                var cb = entry.callback;\n                var len = state.objectMode ? 1 : chunk.length;\n                doWrite(stream, state, false, len, chunk, encoding, cb);\n                entry = entry.next;\n                state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n                // it means that we need to wait until it does.\n                // also, that means that the chunk and cb are currently\n                // being processed, so move the buffer counter past them.\n\n                if (state.writing) {\n                  break;\n                }\n              }\n\n              if (entry === null) state.lastBufferedRequest = null;\n            }\n\n            state.bufferedRequest = entry;\n            state.bufferProcessing = false;\n          }\n\n          Writable.prototype._write = function (chunk, encoding, cb) {\n            cb(new Error('_write() is not implemented'));\n          };\n\n          Writable.prototype._writev = null;\n\n          Writable.prototype.end = function (chunk, encoding, cb) {\n            var state = this._writableState;\n\n            if (typeof chunk === 'function') {\n              cb = chunk;\n              chunk = null;\n              encoding = null;\n            } else if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n            if (state.corked) {\n              state.corked = 1;\n              this.uncork();\n            } // ignore unnecessary end() calls.\n\n\n            if (!state.ending && !state.finished) endWritable(this, state, cb);\n          };\n\n          function needFinish(state) {\n            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n          }\n\n          function callFinal(stream, state) {\n            stream._final(function (err) {\n              state.pendingcb--;\n\n              if (err) {\n                stream.emit('error', err);\n              }\n\n              state.prefinished = true;\n              stream.emit('prefinish');\n              finishMaybe(stream, state);\n            });\n          }\n\n          function prefinish(stream, state) {\n            if (!state.prefinished && !state.finalCalled) {\n              if (typeof stream._final === 'function') {\n                state.pendingcb++;\n                state.finalCalled = true;\n                pna.nextTick(callFinal, stream, state);\n              } else {\n                state.prefinished = true;\n                stream.emit('prefinish');\n              }\n            }\n          }\n\n          function finishMaybe(stream, state) {\n            var need = needFinish(state);\n\n            if (need) {\n              prefinish(stream, state);\n\n              if (state.pendingcb === 0) {\n                state.finished = true;\n                stream.emit('finish');\n              }\n            }\n\n            return need;\n          }\n\n          function endWritable(stream, state, cb) {\n            state.ending = true;\n            finishMaybe(stream, state);\n\n            if (cb) {\n              if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n            }\n\n            state.ended = true;\n            stream.writable = false;\n          }\n\n          function onCorkedFinish(corkReq, state, err) {\n            var entry = corkReq.entry;\n            corkReq.entry = null;\n\n            while (entry) {\n              var cb = entry.callback;\n              state.pendingcb--;\n              cb(err);\n              entry = entry.next;\n            }\n\n            if (state.corkedRequestsFree) {\n              state.corkedRequestsFree.next = corkReq;\n            } else {\n              state.corkedRequestsFree = corkReq;\n            }\n          }\n\n          Object.defineProperty(Writable.prototype, 'destroyed', {\n            get: function () {\n              if (this._writableState === undefined) {\n                return false;\n              }\n\n              return this._writableState.destroyed;\n            },\n            set: function (value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._writableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._writableState.destroyed = value;\n            }\n          });\n          Writable.prototype.destroy = destroyImpl.destroy;\n          Writable.prototype._undestroy = destroyImpl.undestroy;\n\n          Writable.prototype._destroy = function (err, cb) {\n            this.end();\n            cb(err);\n          };\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"timers\").setImmediate);\n    }, {\n      \"./_stream_duplex\": 22,\n      \"./internal/streams/destroy\": 28,\n      \"./internal/streams/stream\": 29,\n      \"_process\": 69,\n      \"core-util-is\": 18,\n      \"inherits\": 34,\n      \"process-nextick-args\": 45,\n      \"safe-buffer\": 31,\n      \"timers\": 74,\n      \"util-deprecate\": 65\n    }],\n    27: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var Buffer = require('safe-buffer').Buffer;\n\n      var util = require('util');\n\n      function copyBuffer(src, target, offset) {\n        src.copy(target, offset);\n      }\n\n      module.exports = function () {\n        function BufferList() {\n          _classCallCheck(this, BufferList);\n\n          this.head = null;\n          this.tail = null;\n          this.length = 0;\n        }\n\n        BufferList.prototype.push = function push(v) {\n          var entry = {\n            data: v,\n            next: null\n          };\n          if (this.length > 0) this.tail.next = entry;else this.head = entry;\n          this.tail = entry;\n          ++this.length;\n        };\n\n        BufferList.prototype.unshift = function unshift(v) {\n          var entry = {\n            data: v,\n            next: this.head\n          };\n          if (this.length === 0) this.tail = entry;\n          this.head = entry;\n          ++this.length;\n        };\n\n        BufferList.prototype.shift = function shift() {\n          if (this.length === 0) return;\n          var ret = this.head.data;\n          if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n          --this.length;\n          return ret;\n        };\n\n        BufferList.prototype.clear = function clear() {\n          this.head = this.tail = null;\n          this.length = 0;\n        };\n\n        BufferList.prototype.join = function join(s) {\n          if (this.length === 0) return '';\n          var p = this.head;\n          var ret = '' + p.data;\n\n          while (p = p.next) {\n            ret += s + p.data;\n          }\n\n          return ret;\n        };\n\n        BufferList.prototype.concat = function concat(n) {\n          if (this.length === 0) return Buffer.alloc(0);\n          if (this.length === 1) return this.head.data;\n          var ret = Buffer.allocUnsafe(n >>> 0);\n          var p = this.head;\n          var i = 0;\n\n          while (p) {\n            copyBuffer(p.data, ret, i);\n            i += p.data.length;\n            p = p.next;\n          }\n\n          return ret;\n        };\n\n        return BufferList;\n      }();\n\n      if (util && util.inspect && util.inspect.custom) {\n        module.exports.prototype[util.inspect.custom] = function () {\n          var obj = util.inspect({\n            length: this.length\n          });\n          return this.constructor.name + ' ' + obj;\n        };\n      }\n    }, {\n      \"safe-buffer\": 31,\n      \"util\": 2\n    }],\n    28: [function (require, module, exports) {\n      'use strict';\n      /*<replacement>*/\n\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n      // undocumented cb() API, needed for core, not for public API\n\n\n      function destroy(err, cb) {\n        var _this = this;\n\n        var readableDestroyed = this._readableState && this._readableState.destroyed;\n        var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n        if (readableDestroyed || writableDestroyed) {\n          if (cb) {\n            cb(err);\n          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n            pna.nextTick(emitErrorNT, this, err);\n          }\n\n          return this;\n        } // we set destroyed to true before firing error callbacks in order\n        // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n        if (this._readableState) {\n          this._readableState.destroyed = true;\n        } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n        if (this._writableState) {\n          this._writableState.destroyed = true;\n        }\n\n        this._destroy(err || null, function (err) {\n          if (!cb && err) {\n            pna.nextTick(emitErrorNT, _this, err);\n\n            if (_this._writableState) {\n              _this._writableState.errorEmitted = true;\n            }\n          } else if (cb) {\n            cb(err);\n          }\n        });\n\n        return this;\n      }\n\n      function undestroy() {\n        if (this._readableState) {\n          this._readableState.destroyed = false;\n          this._readableState.reading = false;\n          this._readableState.ended = false;\n          this._readableState.endEmitted = false;\n        }\n\n        if (this._writableState) {\n          this._writableState.destroyed = false;\n          this._writableState.ended = false;\n          this._writableState.ending = false;\n          this._writableState.finished = false;\n          this._writableState.errorEmitted = false;\n        }\n      }\n\n      function emitErrorNT(self, err) {\n        self.emit('error', err);\n      }\n\n      module.exports = {\n        destroy: destroy,\n        undestroy: undestroy\n      };\n    }, {\n      \"process-nextick-args\": 45\n    }],\n    29: [function (require, module, exports) {\n      module.exports = require('events').EventEmitter;\n    }, {\n      \"events\": 4\n    }],\n    30: [function (require, module, exports) {\n      exports = module.exports = require('./lib/_stream_readable.js');\n      exports.Stream = exports;\n      exports.Readable = exports;\n      exports.Writable = require('./lib/_stream_writable.js');\n      exports.Duplex = require('./lib/_stream_duplex.js');\n      exports.Transform = require('./lib/_stream_transform.js');\n      exports.PassThrough = require('./lib/_stream_passthrough.js');\n    }, {\n      \"./lib/_stream_duplex.js\": 22,\n      \"./lib/_stream_passthrough.js\": 23,\n      \"./lib/_stream_readable.js\": 24,\n      \"./lib/_stream_transform.js\": 25,\n      \"./lib/_stream_writable.js\": 26\n    }],\n    31: [function (require, module, exports) {\n      /* eslint-disable node/no-deprecated-api */\n      var buffer = require('buffer');\n\n      var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\n      function copyProps(src, dst) {\n        for (var key in src) {\n          dst[key] = src[key];\n        }\n      }\n\n      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n        module.exports = buffer;\n      } else {\n        // Copy properties from require('buffer')\n        copyProps(buffer, exports);\n        exports.Buffer = SafeBuffer;\n      }\n\n      function SafeBuffer(arg, encodingOrOffset, length) {\n        return Buffer(arg, encodingOrOffset, length);\n      } // Copy static methods from Buffer\n\n\n      copyProps(Buffer, SafeBuffer);\n\n      SafeBuffer.from = function (arg, encodingOrOffset, length) {\n        if (typeof arg === 'number') {\n          throw new TypeError('Argument must not be a number');\n        }\n\n        return Buffer(arg, encodingOrOffset, length);\n      };\n\n      SafeBuffer.alloc = function (size, fill, encoding) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        var buf = Buffer(size);\n\n        if (fill !== undefined) {\n          if (typeof encoding === 'string') {\n            buf.fill(fill, encoding);\n          } else {\n            buf.fill(fill);\n          }\n        } else {\n          buf.fill(0);\n        }\n\n        return buf;\n      };\n\n      SafeBuffer.allocUnsafe = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        return Buffer(size);\n      };\n\n      SafeBuffer.allocUnsafeSlow = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        return buffer.SlowBuffer(size);\n      };\n    }, {\n      \"buffer\": 3\n    }],\n    32: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict';\n      /*<replacement>*/\n\n      var Buffer = require('safe-buffer').Buffer;\n      /*</replacement>*/\n\n\n      var isEncoding = Buffer.isEncoding || function (encoding) {\n        encoding = '' + encoding;\n\n        switch (encoding && encoding.toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'binary':\n          case 'base64':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n          case 'raw':\n            return true;\n\n          default:\n            return false;\n        }\n      };\n\n      function _normalizeEncoding(enc) {\n        if (!enc) return 'utf8';\n        var retried;\n\n        while (true) {\n          switch (enc) {\n            case 'utf8':\n            case 'utf-8':\n              return 'utf8';\n\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return 'utf16le';\n\n            case 'latin1':\n            case 'binary':\n              return 'latin1';\n\n            case 'base64':\n            case 'ascii':\n            case 'hex':\n              return enc;\n\n            default:\n              if (retried) return; // undefined\n\n              enc = ('' + enc).toLowerCase();\n              retried = true;\n          }\n        }\n      }\n\n      ; // Do not cache `Buffer.isEncoding` when checking encoding names as some\n      // modules monkey-patch it to support additional encodings\n\n      function normalizeEncoding(enc) {\n        var nenc = _normalizeEncoding(enc);\n\n        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n        return nenc || enc;\n      } // StringDecoder provides an interface for efficiently splitting a series of\n      // buffers into a series of JS strings without breaking apart multi-byte\n      // characters.\n\n\n      exports.StringDecoder = StringDecoder;\n\n      function StringDecoder(encoding) {\n        this.encoding = normalizeEncoding(encoding);\n        var nb;\n\n        switch (this.encoding) {\n          case 'utf16le':\n            this.text = utf16Text;\n            this.end = utf16End;\n            nb = 4;\n            break;\n\n          case 'utf8':\n            this.fillLast = utf8FillLast;\n            nb = 4;\n            break;\n\n          case 'base64':\n            this.text = base64Text;\n            this.end = base64End;\n            nb = 3;\n            break;\n\n          default:\n            this.write = simpleWrite;\n            this.end = simpleEnd;\n            return;\n        }\n\n        this.lastNeed = 0;\n        this.lastTotal = 0;\n        this.lastChar = Buffer.allocUnsafe(nb);\n      }\n\n      StringDecoder.prototype.write = function (buf) {\n        if (buf.length === 0) return '';\n        var r;\n        var i;\n\n        if (this.lastNeed) {\n          r = this.fillLast(buf);\n          if (r === undefined) return '';\n          i = this.lastNeed;\n          this.lastNeed = 0;\n        } else {\n          i = 0;\n        }\n\n        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n        return r || '';\n      };\n\n      StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer\n\n      StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n\n      StringDecoder.prototype.fillLast = function (buf) {\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n\n        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n        this.lastNeed -= buf.length;\n      }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n      // continuation byte. If an invalid byte is detected, -2 is returned.\n\n\n      function utf8CheckByte(byte) {\n        if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n        return byte >> 6 === 0x02 ? -1 : -2;\n      } // Checks at most 3 bytes at the end of a Buffer in order to detect an\n      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n      // needed to complete the UTF-8 character (if applicable) are returned.\n\n\n      function utf8CheckIncomplete(self, buf, i) {\n        var j = buf.length - 1;\n        if (j < i) return 0;\n        var nb = utf8CheckByte(buf[j]);\n\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 1;\n          return nb;\n        }\n\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 2;\n          return nb;\n        }\n\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n\n        if (nb >= 0) {\n          if (nb > 0) {\n            if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n          }\n\n          return nb;\n        }\n\n        return 0;\n      } // Validates as many continuation bytes for a multi-byte UTF-8 character as\n      // needed or are available. If we see a non-continuation byte where we expect\n      // one, we \"replace\" the validated continuation bytes we've seen so far with\n      // a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n      // behavior. The continuation byte check is included three times in the case\n      // where all of the continuation bytes for a character exist in the same buffer.\n      // It is also done this way as a slight performance increase instead of using a\n      // loop.\n\n\n      function utf8CheckExtraBytes(self, buf, p) {\n        if ((buf[0] & 0xC0) !== 0x80) {\n          self.lastNeed = 0;\n          return '\\ufffd';\n        }\n\n        if (self.lastNeed > 1 && buf.length > 1) {\n          if ((buf[1] & 0xC0) !== 0x80) {\n            self.lastNeed = 1;\n            return '\\ufffd';\n          }\n\n          if (self.lastNeed > 2 && buf.length > 2) {\n            if ((buf[2] & 0xC0) !== 0x80) {\n              self.lastNeed = 2;\n              return '\\ufffd';\n            }\n          }\n        }\n      } // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n\n\n      function utf8FillLast(buf) {\n        var p = this.lastTotal - this.lastNeed;\n        var r = utf8CheckExtraBytes(this, buf, p);\n        if (r !== undefined) return r;\n\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, p, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n\n        buf.copy(this.lastChar, p, 0, buf.length);\n        this.lastNeed -= buf.length;\n      } // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n      // partial character, the character's bytes are buffered until the required\n      // number of bytes are available.\n\n\n      function utf8Text(buf, i) {\n        var total = utf8CheckIncomplete(this, buf, i);\n        if (!this.lastNeed) return buf.toString('utf8', i);\n        this.lastTotal = total;\n        var end = buf.length - (total - this.lastNeed);\n        buf.copy(this.lastChar, 0, end);\n        return buf.toString('utf8', i, end);\n      } // For UTF-8, a replacement character is added when ending on a partial\n      // character.\n\n\n      function utf8End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + '\\ufffd';\n        return r;\n      } // UTF-16LE typically needs two bytes per character, but even if we have an even\n      // number of bytes available, we need to check if we end on a leading/high\n      // surrogate. In that case, we need to wait for the next two bytes in order to\n      // decode the last character properly.\n\n\n      function utf16Text(buf, i) {\n        if ((buf.length - i) % 2 === 0) {\n          var r = buf.toString('utf16le', i);\n\n          if (r) {\n            var c = r.charCodeAt(r.length - 1);\n\n            if (c >= 0xD800 && c <= 0xDBFF) {\n              this.lastNeed = 2;\n              this.lastTotal = 4;\n              this.lastChar[0] = buf[buf.length - 2];\n              this.lastChar[1] = buf[buf.length - 1];\n              return r.slice(0, -1);\n            }\n          }\n\n          return r;\n        }\n\n        this.lastNeed = 1;\n        this.lastTotal = 2;\n        this.lastChar[0] = buf[buf.length - 1];\n        return buf.toString('utf16le', i, buf.length - 1);\n      } // For UTF-16LE we do not explicitly append special replacement characters if we\n      // end on a partial character, we simply let v8 handle that.\n\n\n      function utf16End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n\n        if (this.lastNeed) {\n          var end = this.lastTotal - this.lastNeed;\n          return r + this.lastChar.toString('utf16le', 0, end);\n        }\n\n        return r;\n      }\n\n      function base64Text(buf, i) {\n        var n = (buf.length - i) % 3;\n        if (n === 0) return buf.toString('base64', i);\n        this.lastNeed = 3 - n;\n        this.lastTotal = 3;\n\n        if (n === 1) {\n          this.lastChar[0] = buf[buf.length - 1];\n        } else {\n          this.lastChar[0] = buf[buf.length - 2];\n          this.lastChar[1] = buf[buf.length - 1];\n        }\n\n        return buf.toString('base64', i, buf.length - n);\n      }\n\n      function base64End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n        return r;\n      } // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n\n\n      function simpleWrite(buf) {\n        return buf.toString(this.encoding);\n      }\n\n      function simpleEnd(buf) {\n        return buf && buf.length ? this.write(buf) : '';\n      }\n    }, {\n      \"safe-buffer\": 31\n    }],\n    33: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          var once = require('once');\n\n          var noop = function () {};\n\n          var isRequest = function (stream) {\n            return stream.setHeader && typeof stream.abort === 'function';\n          };\n\n          var isChildProcess = function (stream) {\n            return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;\n          };\n\n          var eos = function (stream, opts, callback) {\n            if (typeof opts === 'function') return eos(stream, null, opts);\n            if (!opts) opts = {};\n            callback = once(callback || noop);\n            var ws = stream._writableState;\n            var rs = stream._readableState;\n            var readable = opts.readable || opts.readable !== false && stream.readable;\n            var writable = opts.writable || opts.writable !== false && stream.writable;\n            var cancelled = false;\n\n            var onlegacyfinish = function () {\n              if (!stream.writable) onfinish();\n            };\n\n            var onfinish = function () {\n              writable = false;\n              if (!readable) callback.call(stream);\n            };\n\n            var onend = function () {\n              readable = false;\n              if (!writable) callback.call(stream);\n            };\n\n            var onexit = function (exitCode) {\n              callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n            };\n\n            var onerror = function (err) {\n              callback.call(stream, err);\n            };\n\n            var onclose = function () {\n              process.nextTick(onclosenexttick);\n            };\n\n            var onclosenexttick = function () {\n              if (cancelled) return;\n              if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error('premature close'));\n              if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error('premature close'));\n            };\n\n            var onrequest = function () {\n              stream.req.on('finish', onfinish);\n            };\n\n            if (isRequest(stream)) {\n              stream.on('complete', onfinish);\n              stream.on('abort', onclose);\n              if (stream.req) onrequest();else stream.on('request', onrequest);\n            } else if (writable && !ws) {\n              // legacy streams\n              stream.on('end', onlegacyfinish);\n              stream.on('close', onlegacyfinish);\n            }\n\n            if (isChildProcess(stream)) stream.on('exit', onexit);\n            stream.on('end', onend);\n            stream.on('finish', onfinish);\n            if (opts.error !== false) stream.on('error', onerror);\n            stream.on('close', onclose);\n            return function () {\n              cancelled = true;\n              stream.removeListener('complete', onfinish);\n              stream.removeListener('abort', onclose);\n              stream.removeListener('request', onrequest);\n              if (stream.req) stream.req.removeListener('finish', onfinish);\n              stream.removeListener('end', onlegacyfinish);\n              stream.removeListener('close', onlegacyfinish);\n              stream.removeListener('finish', onfinish);\n              stream.removeListener('exit', onexit);\n              stream.removeListener('end', onend);\n              stream.removeListener('error', onerror);\n              stream.removeListener('close', onclose);\n            };\n          };\n\n          module.exports = eos;\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"_process\": 69,\n      \"once\": 44\n    }],\n    34: [function (require, module, exports) {\n      if (typeof Object.create === 'function') {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n          if (superCtor) {\n            ctor.super_ = superCtor;\n            ctor.prototype = Object.create(superCtor.prototype, {\n              constructor: {\n                value: ctor,\n                enumerable: false,\n                writable: true,\n                configurable: true\n              }\n            });\n          }\n        };\n      } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n          if (superCtor) {\n            ctor.super_ = superCtor;\n\n            var TempCtor = function () {};\n\n            TempCtor.prototype = superCtor.prototype;\n            ctor.prototype = new TempCtor();\n            ctor.prototype.constructor = ctor;\n          }\n        };\n      }\n    }, {}],\n    35: [function (require, module, exports) {\n      var toString = {}.toString;\n\n      module.exports = Array.isArray || function (arr) {\n        return toString.call(arr) == '[object Array]';\n      };\n    }, {}],\n    36: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          /* Protocol - protocol constants */\n          const protocol = module.exports;\n          /* Command code => mnemonic */\n\n          protocol.types = {\n            0: 'reserved',\n            1: 'connect',\n            2: 'connack',\n            3: 'publish',\n            4: 'puback',\n            5: 'pubrec',\n            6: 'pubrel',\n            7: 'pubcomp',\n            8: 'subscribe',\n            9: 'suback',\n            10: 'unsubscribe',\n            11: 'unsuback',\n            12: 'pingreq',\n            13: 'pingresp',\n            14: 'disconnect',\n            15: 'auth'\n          };\n          /* Mnemonic => Command code */\n\n          protocol.codes = {};\n\n          for (const k in protocol.types) {\n            const v = protocol.types[k];\n            protocol.codes[v] = k;\n          }\n          /* Header */\n\n\n          protocol.CMD_SHIFT = 4;\n          protocol.CMD_MASK = 0xF0;\n          protocol.DUP_MASK = 0x08;\n          protocol.QOS_MASK = 0x03;\n          protocol.QOS_SHIFT = 1;\n          protocol.RETAIN_MASK = 0x01;\n          /* Length */\n\n          protocol.VARBYTEINT_MASK = 0x7F;\n          protocol.VARBYTEINT_FIN_MASK = 0x80;\n          protocol.VARBYTEINT_MAX = 268435455;\n          /* Connack */\n\n          protocol.SESSIONPRESENT_MASK = 0x01;\n          protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK]);\n          protocol.CONNACK_HEADER = Buffer.from([protocol.codes.connack << protocol.CMD_SHIFT]);\n          /* Connect */\n\n          protocol.USERNAME_MASK = 0x80;\n          protocol.PASSWORD_MASK = 0x40;\n          protocol.WILL_RETAIN_MASK = 0x20;\n          protocol.WILL_QOS_MASK = 0x18;\n          protocol.WILL_QOS_SHIFT = 3;\n          protocol.WILL_FLAG_MASK = 0x04;\n          protocol.CLEAN_SESSION_MASK = 0x02;\n          protocol.CONNECT_HEADER = Buffer.from([protocol.codes.connect << protocol.CMD_SHIFT]);\n          /* Properties */\n\n          protocol.properties = {\n            sessionExpiryInterval: 17,\n            willDelayInterval: 24,\n            receiveMaximum: 33,\n            maximumPacketSize: 39,\n            topicAliasMaximum: 34,\n            requestResponseInformation: 25,\n            requestProblemInformation: 23,\n            userProperties: 38,\n            authenticationMethod: 21,\n            authenticationData: 22,\n            payloadFormatIndicator: 1,\n            messageExpiryInterval: 2,\n            contentType: 3,\n            responseTopic: 8,\n            correlationData: 9,\n            maximumQoS: 36,\n            retainAvailable: 37,\n            assignedClientIdentifier: 18,\n            reasonString: 31,\n            wildcardSubscriptionAvailable: 40,\n            subscriptionIdentifiersAvailable: 41,\n            sharedSubscriptionAvailable: 42,\n            serverKeepAlive: 19,\n            responseInformation: 26,\n            serverReference: 28,\n            topicAlias: 35,\n            subscriptionIdentifier: 11\n          };\n          protocol.propertiesCodes = {};\n\n          for (const prop in protocol.properties) {\n            const id = protocol.properties[prop];\n            protocol.propertiesCodes[id] = prop;\n          }\n\n          protocol.propertiesTypes = {\n            sessionExpiryInterval: 'int32',\n            willDelayInterval: 'int32',\n            receiveMaximum: 'int16',\n            maximumPacketSize: 'int32',\n            topicAliasMaximum: 'int16',\n            requestResponseInformation: 'byte',\n            requestProblemInformation: 'byte',\n            userProperties: 'pair',\n            authenticationMethod: 'string',\n            authenticationData: 'binary',\n            payloadFormatIndicator: 'byte',\n            messageExpiryInterval: 'int32',\n            contentType: 'string',\n            responseTopic: 'string',\n            correlationData: 'binary',\n            maximumQoS: 'int8',\n            retainAvailable: 'byte',\n            assignedClientIdentifier: 'string',\n            reasonString: 'string',\n            wildcardSubscriptionAvailable: 'byte',\n            subscriptionIdentifiersAvailable: 'byte',\n            sharedSubscriptionAvailable: 'byte',\n            serverKeepAlive: 'int16',\n            responseInformation: 'string',\n            serverReference: 'string',\n            topicAlias: 'int16',\n            subscriptionIdentifier: 'var'\n          };\n\n          function genHeader(type) {\n            return [0, 1, 2].map(qos => {\n              return [0, 1].map(dup => {\n                return [0, 1].map(retain => {\n                  const buf = Buffer.alloc(1);\n                  buf.writeUInt8(protocol.codes[type] << protocol.CMD_SHIFT | (dup ? protocol.DUP_MASK : 0) | qos << protocol.QOS_SHIFT | retain, 0, true);\n                  return buf;\n                });\n              });\n            });\n          }\n          /* Publish */\n\n\n          protocol.PUBLISH_HEADER = genHeader('publish');\n          /* Subscribe */\n\n          protocol.SUBSCRIBE_HEADER = genHeader('subscribe');\n          protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03;\n          protocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01;\n          protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;\n          protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01;\n          protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;\n          protocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03;\n          protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;\n          protocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20];\n          protocol.SUBSCRIBE_OPTIONS_NL = 0x04;\n          protocol.SUBSCRIBE_OPTIONS_RAP = 0x08;\n          protocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02];\n          /* Unsubscribe */\n\n          protocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe');\n          /* Confirmations */\n\n          protocol.ACKS = {\n            unsuback: genHeader('unsuback'),\n            puback: genHeader('puback'),\n            pubcomp: genHeader('pubcomp'),\n            pubrel: genHeader('pubrel'),\n            pubrec: genHeader('pubrec')\n          };\n          protocol.SUBACK_HEADER = Buffer.from([protocol.codes.suback << protocol.CMD_SHIFT]);\n          /* Protocol versions */\n\n          protocol.VERSION3 = Buffer.from([3]);\n          protocol.VERSION4 = Buffer.from([4]);\n          protocol.VERSION5 = Buffer.from([5]);\n          protocol.VERSION131 = Buffer.from([131]);\n          protocol.VERSION132 = Buffer.from([132]);\n          /* QoS */\n\n          protocol.QOS = [0, 1, 2].map(qos => {\n            return Buffer.from([qos]);\n          });\n          /* Empty packets */\n\n          protocol.EMPTY = {\n            pingreq: Buffer.from([protocol.codes.pingreq << 4, 0]),\n            pingresp: Buffer.from([protocol.codes.pingresp << 4, 0]),\n            disconnect: Buffer.from([protocol.codes.disconnect << 4, 0])\n          };\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"buffer\": 3\n    }],\n    37: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          const writeToStream = require('./writeToStream');\n\n          const EventEmitter = require('events');\n\n          function generate(packet, opts) {\n            const stream = new Accumulator();\n            writeToStream(packet, stream, opts);\n            return stream.concat();\n          }\n\n          class Accumulator extends EventEmitter {\n            constructor() {\n              super();\n              this._array = new Array(20);\n              this._i = 0;\n            }\n\n            write(chunk) {\n              this._array[this._i++] = chunk;\n              return true;\n            }\n\n            concat() {\n              let length = 0;\n              const lengths = new Array(this._array.length);\n              const list = this._array;\n              let pos = 0;\n              let i;\n\n              for (i = 0; i < list.length && list[i] !== undefined; i++) {\n                if (typeof list[i] !== 'string') lengths[i] = list[i].length;else lengths[i] = Buffer.byteLength(list[i]);\n                length += lengths[i];\n              }\n\n              const result = Buffer.allocUnsafe(length);\n\n              for (i = 0; i < list.length && list[i] !== undefined; i++) {\n                if (typeof list[i] !== 'string') {\n                  list[i].copy(result, pos);\n                  pos += lengths[i];\n                } else {\n                  result.write(list[i], pos);\n                  pos += lengths[i];\n                }\n              }\n\n              return result;\n            }\n\n          }\n\n          module.exports = generate;\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"./writeToStream\": 42,\n      \"buffer\": 3,\n      \"events\": 4\n    }],\n    38: [function (require, module, exports) {\n      exports.parser = require('./parser').parser;\n      exports.generate = require('./generate');\n      exports.writeToStream = require('./writeToStream');\n    }, {\n      \"./generate\": 37,\n      \"./parser\": 41,\n      \"./writeToStream\": 42\n    }],\n    39: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          const max = 65536;\n          const cache = {}; // in node 6 Buffer.subarray returns a Uint8Array instead of a Buffer\n          // later versions return a Buffer\n          // alternative is Buffer.slice but that creates a new buffer\n          // creating new buffers takes time\n          // SubOk is only false on node < 8\n\n          const SubOk = Buffer.isBuffer(Buffer.from([1, 2]).subarray(0, 1));\n\n          function generateBuffer(i) {\n            const buffer = Buffer.allocUnsafe(2);\n            buffer.writeUInt8(i >> 8, 0);\n            buffer.writeUInt8(i & 0x00FF, 0 + 1);\n            return buffer;\n          }\n\n          function generateCache() {\n            for (let i = 0; i < max; i++) {\n              cache[i] = generateBuffer(i);\n            }\n          }\n\n          function genBufVariableByteInt(num) {\n            const maxLength = 4; // max 4 bytes\n\n            let digit = 0;\n            let pos = 0;\n            const buffer = Buffer.allocUnsafe(maxLength);\n\n            do {\n              digit = num % 128 | 0;\n              num = num / 128 | 0;\n              if (num > 0) digit = digit | 0x80;\n              buffer.writeUInt8(digit, pos++);\n            } while (num > 0 && pos < maxLength);\n\n            if (num > 0) {\n              pos = 0;\n            }\n\n            return SubOk ? buffer.subarray(0, pos) : buffer.slice(0, pos);\n          }\n\n          function generate4ByteBuffer(num) {\n            const buffer = Buffer.allocUnsafe(4);\n            buffer.writeUInt32BE(num, 0);\n            return buffer;\n          }\n\n          module.exports = {\n            cache,\n            generateCache,\n            generateNumber: generateBuffer,\n            genBufVariableByteInt,\n            generate4ByteBuffer\n          };\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"buffer\": 3\n    }],\n    40: [function (require, module, exports) {\n      class Packet {\n        constructor() {\n          this.cmd = null;\n          this.retain = false;\n          this.qos = 0;\n          this.dup = false;\n          this.length = -1;\n          this.topic = null;\n          this.payload = null;\n        }\n\n      }\n\n      module.exports = Packet;\n    }, {}],\n    41: [function (require, module, exports) {\n      const bl = require('bl');\n\n      const EventEmitter = require('events');\n\n      const Packet = require('./packet');\n\n      const constants = require('./constants');\n\n      const debug = require('debug')('mqtt-packet:parser');\n\n      class Parser extends EventEmitter {\n        constructor() {\n          super();\n          this.parser = this.constructor.parser;\n        }\n\n        static parser(opt) {\n          if (!(this instanceof Parser)) return new Parser().parser(opt);\n          this.settings = opt || {};\n          this._states = ['_parseHeader', '_parseLength', '_parsePayload', '_newPacket'];\n\n          this._resetState();\n\n          return this;\n        }\n\n        _resetState() {\n          debug('_resetState: resetting packet, error, _list, and _stateCounter');\n          this.packet = new Packet();\n          this.error = null;\n          this._list = bl();\n          this._stateCounter = 0;\n        }\n\n        parse(buf) {\n          if (this.error) this._resetState();\n\n          this._list.append(buf);\n\n          debug('parse: current state: %s', this._states[this._stateCounter]);\n\n          while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {\n            this._stateCounter++;\n            debug('parse: state complete. _stateCounter is now: %d', this._stateCounter);\n            debug('parse: packet.length: %d, buffer list length: %d', this.packet.length, this._list.length);\n            if (this._stateCounter >= this._states.length) this._stateCounter = 0;\n          }\n\n          debug('parse: exited while loop. packet: %d, buffer list length: %d', this.packet.length, this._list.length);\n          return this._list.length;\n        }\n\n        _parseHeader() {\n          // There is at least one byte in the buffer\n          const zero = this._list.readUInt8(0);\n\n          this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT];\n          this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;\n          this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;\n          this.packet.dup = (zero & constants.DUP_MASK) !== 0;\n          debug('_parseHeader: packet: %o', this.packet);\n\n          this._list.consume(1);\n\n          return true;\n        }\n\n        _parseLength() {\n          // There is at least one byte in the list\n          const result = this._parseVarByteNum(true);\n\n          if (result) {\n            this.packet.length = result.value;\n\n            this._list.consume(result.bytes);\n          }\n\n          debug('_parseLength %d', result.value);\n          return !!result;\n        }\n\n        _parsePayload() {\n          debug('_parsePayload: payload %O', this._list);\n          let result = false; // Do we have a payload? Do we have enough data to complete the payload?\n          // PINGs have no payload\n\n          if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n            this._pos = 0;\n\n            switch (this.packet.cmd) {\n              case 'connect':\n                this._parseConnect();\n\n                break;\n\n              case 'connack':\n                this._parseConnack();\n\n                break;\n\n              case 'publish':\n                this._parsePublish();\n\n                break;\n\n              case 'puback':\n              case 'pubrec':\n              case 'pubrel':\n              case 'pubcomp':\n                this._parseConfirmation();\n\n                break;\n\n              case 'subscribe':\n                this._parseSubscribe();\n\n                break;\n\n              case 'suback':\n                this._parseSuback();\n\n                break;\n\n              case 'unsubscribe':\n                this._parseUnsubscribe();\n\n                break;\n\n              case 'unsuback':\n                this._parseUnsuback();\n\n                break;\n\n              case 'pingreq':\n              case 'pingresp':\n                // These are empty, nothing to do\n                break;\n\n              case 'disconnect':\n                this._parseDisconnect();\n\n                break;\n\n              case 'auth':\n                this._parseAuth();\n\n                break;\n\n              default:\n                this._emitError(new Error('Not supported'));\n\n            }\n\n            result = true;\n          }\n\n          debug('_parsePayload complete result: %s', result);\n          return result;\n        }\n\n        _parseConnect() {\n          debug('_parseConnect');\n          let topic; // Will topic\n\n          let payload; // Will payload\n\n          let password; // Password\n\n          let username; // Username\n\n          const flags = {};\n          const packet = this.packet; // Parse protocolId\n\n          const protocolId = this._parseString();\n\n          if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'));\n\n          if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n            return this._emitError(new Error('Invalid protocolId'));\n          }\n\n          packet.protocolId = protocolId; // Parse constants version number\n\n          if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'));\n          packet.protocolVersion = this._list.readUInt8(this._pos);\n\n          if (packet.protocolVersion >= 128) {\n            packet.bridgeMode = true;\n            packet.protocolVersion = packet.protocolVersion - 128;\n          }\n\n          if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n            return this._emitError(new Error('Invalid protocol version'));\n          }\n\n          this._pos++;\n\n          if (this._pos >= this._list.length) {\n            return this._emitError(new Error('Packet too short'));\n          } // Parse connect flags\n\n\n          flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;\n          flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;\n          flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;\n\n          if (flags.will) {\n            packet.will = {};\n            packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0;\n            packet.will.qos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;\n          }\n\n          packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;\n          this._pos++; // Parse keepalive\n\n          packet.keepalive = this._parseNum();\n          if (packet.keepalive === -1) return this._emitError(new Error('Packet too short')); // parse properties\n\n          if (packet.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          } // Parse clientId\n\n\n          const clientId = this._parseString();\n\n          if (clientId === null) return this._emitError(new Error('Packet too short'));\n          packet.clientId = clientId;\n          debug('_parseConnect: packet.clientId: %s', packet.clientId);\n\n          if (flags.will) {\n            if (packet.protocolVersion === 5) {\n              const willProperties = this._parseProperties();\n\n              if (Object.getOwnPropertyNames(willProperties).length) {\n                packet.will.properties = willProperties;\n              }\n            } // Parse will topic\n\n\n            topic = this._parseString();\n            if (topic === null) return this._emitError(new Error('Cannot parse will topic'));\n            packet.will.topic = topic;\n            debug('_parseConnect: packet.will.topic: %s', packet.will.topic); // Parse will payload\n\n            payload = this._parseBuffer();\n            if (payload === null) return this._emitError(new Error('Cannot parse will payload'));\n            packet.will.payload = payload;\n            debug('_parseConnect: packet.will.paylaod: %s', packet.will.payload);\n          } // Parse username\n\n\n          if (flags.username) {\n            username = this._parseString();\n            if (username === null) return this._emitError(new Error('Cannot parse username'));\n            packet.username = username;\n            debug('_parseConnect: packet.username: %s', packet.username);\n          } // Parse password\n\n\n          if (flags.password) {\n            password = this._parseBuffer();\n            if (password === null) return this._emitError(new Error('Cannot parse password'));\n            packet.password = password;\n          } // need for right parse auth packet and self set up\n\n\n          this.settings = packet;\n          debug('_parseConnect: complete');\n          return packet;\n        }\n\n        _parseConnack() {\n          debug('_parseConnack');\n          const packet = this.packet;\n          if (this._list.length < 1) return null;\n          packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK);\n\n          if (this.settings.protocolVersion === 5) {\n            if (this._list.length >= 2) {\n              packet.reasonCode = this._list.readUInt8(this._pos++);\n            } else {\n              packet.reasonCode = 0;\n            }\n          } else {\n            if (this._list.length < 2) return null;\n            packet.returnCode = this._list.readUInt8(this._pos++);\n          }\n\n          if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code')); // mqtt 5 properties\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          debug('_parseConnack: complete');\n        }\n\n        _parsePublish() {\n          debug('_parsePublish');\n          const packet = this.packet;\n          packet.topic = this._parseString();\n          if (packet.topic === null) return this._emitError(new Error('Cannot parse topic')); // Parse messageId\n\n          if (packet.qos > 0) if (!this._parseMessageId()) {\n            return;\n          } // Properties mqtt 5\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          packet.payload = this._list.slice(this._pos, packet.length);\n          debug('_parsePublish: payload from buffer list: %o', packet.payload);\n        }\n\n        _parseSubscribe() {\n          debug('_parseSubscribe');\n          const packet = this.packet;\n          let topic;\n          let options;\n          let qos;\n          let rh;\n          let rap;\n          let nl;\n          let subscription;\n\n          if (packet.qos !== 1) {\n            return this._emitError(new Error('Wrong subscribe header'));\n          }\n\n          packet.subscriptions = [];\n\n          if (!this._parseMessageId()) {\n            return;\n          } // Properties mqtt 5\n\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          while (this._pos < packet.length) {\n            // Parse topic\n            topic = this._parseString();\n            if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n            if (this._pos >= packet.length) return this._emitError(new Error('Malformed Subscribe Payload'));\n            options = this._parseByte();\n            qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;\n            nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;\n            rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;\n            rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;\n            subscription = {\n              topic,\n              qos\n            }; // mqtt 5 options\n\n            if (this.settings.protocolVersion === 5) {\n              subscription.nl = nl;\n              subscription.rap = rap;\n              subscription.rh = rh;\n            } else if (this.settings.bridgeMode) {\n              subscription.rh = 0;\n              subscription.rap = true;\n              subscription.nl = true;\n            } // Push pair to subscriptions\n\n\n            debug('_parseSubscribe: push subscription `%s` to subscription', subscription);\n            packet.subscriptions.push(subscription);\n          }\n        }\n\n        _parseSuback() {\n          debug('_parseSuback');\n          const packet = this.packet;\n          this.packet.granted = [];\n\n          if (!this._parseMessageId()) {\n            return;\n          } // Properties mqtt 5\n\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          } // Parse granted QoSes\n\n\n          while (this._pos < this.packet.length) {\n            this.packet.granted.push(this._list.readUInt8(this._pos++));\n          }\n        }\n\n        _parseUnsubscribe() {\n          debug('_parseUnsubscribe');\n          const packet = this.packet;\n          packet.unsubscriptions = []; // Parse messageId\n\n          if (!this._parseMessageId()) {\n            return;\n          } // Properties mqtt 5\n\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          while (this._pos < packet.length) {\n            // Parse topic\n            const topic = this._parseString();\n\n            if (topic === null) return this._emitError(new Error('Cannot parse topic')); // Push topic to unsubscriptions\n\n            debug('_parseUnsubscribe: push topic `%s` to unsubscriptions', topic);\n            packet.unsubscriptions.push(topic);\n          }\n        }\n\n        _parseUnsuback() {\n          debug('_parseUnsuback');\n          const packet = this.packet;\n          if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId')); // Properties mqtt 5\n\n          if (this.settings.protocolVersion === 5) {\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            } // Parse granted QoSes\n\n\n            packet.granted = [];\n\n            while (this._pos < this.packet.length) {\n              this.packet.granted.push(this._list.readUInt8(this._pos++));\n            }\n          }\n        } // parse packets like puback, pubrec, pubrel, pubcomp\n\n\n        _parseConfirmation() {\n          debug('_parseConfirmation: packet.cmd: `%s`', this.packet.cmd);\n          const packet = this.packet;\n\n          this._parseMessageId();\n\n          if (this.settings.protocolVersion === 5) {\n            if (packet.length > 2) {\n              // response code\n              packet.reasonCode = this._parseByte();\n              debug('_parseConfirmation: packet.reasonCode `%d`', packet.reasonCode);\n            } else {\n              packet.reasonCode = 0;\n            }\n\n            if (packet.length > 3) {\n              // properies mqtt 5\n              const properties = this._parseProperties();\n\n              if (Object.getOwnPropertyNames(properties).length) {\n                packet.properties = properties;\n              }\n            }\n          }\n\n          return true;\n        } // parse disconnect packet\n\n\n        _parseDisconnect() {\n          const packet = this.packet;\n          debug('_parseDisconnect');\n\n          if (this.settings.protocolVersion === 5) {\n            // response code\n            if (this._list.length > 0) {\n              packet.reasonCode = this._parseByte();\n            } else {\n              packet.reasonCode = 0;\n            } // properies mqtt 5\n\n\n            const properties = this._parseProperties();\n\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n\n          debug('_parseDisconnect result: true');\n          return true;\n        } // parse auth packet\n\n\n        _parseAuth() {\n          debug('_parseAuth');\n          const packet = this.packet;\n\n          if (this.settings.protocolVersion !== 5) {\n            return this._emitError(new Error('Not supported auth packet for this version MQTT'));\n          } // response code\n\n\n          packet.reasonCode = this._parseByte(); // properies mqtt 5\n\n          const properties = this._parseProperties();\n\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n\n          debug('_parseAuth: result: true');\n          return true;\n        }\n\n        _parseMessageId() {\n          const packet = this.packet;\n          packet.messageId = this._parseNum();\n\n          if (packet.messageId === null) {\n            this._emitError(new Error('Cannot parse messageId'));\n\n            return false;\n          }\n\n          debug('_parseMessageId: packet.messageId %d', packet.messageId);\n          return true;\n        }\n\n        _parseString(maybeBuffer) {\n          const length = this._parseNum();\n\n          const end = length + this._pos;\n          if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n          const result = this._list.toString('utf8', this._pos, end);\n\n          this._pos += length;\n          debug('_parseString: result: %s', result);\n          return result;\n        }\n\n        _parseStringPair() {\n          debug('_parseStringPair');\n          return {\n            name: this._parseString(),\n            value: this._parseString()\n          };\n        }\n\n        _parseBuffer() {\n          const length = this._parseNum();\n\n          const end = length + this._pos;\n          if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n\n          const result = this._list.slice(this._pos, end);\n\n          this._pos += length;\n          debug('_parseBuffer: result: %o', result);\n          return result;\n        }\n\n        _parseNum() {\n          if (this._list.length - this._pos < 2) return -1;\n\n          const result = this._list.readUInt16BE(this._pos);\n\n          this._pos += 2;\n          debug('_parseNum: result: %s', result);\n          return result;\n        }\n\n        _parse4ByteNum() {\n          if (this._list.length - this._pos < 4) return -1;\n\n          const result = this._list.readUInt32BE(this._pos);\n\n          this._pos += 4;\n          debug('_parse4ByteNum: result: %s', result);\n          return result;\n        }\n\n        _parseVarByteNum(fullInfoFlag) {\n          debug('_parseVarByteNum');\n          const maxBytes = 4;\n          let bytes = 0;\n          let mul = 1;\n          let value = 0;\n          let result = false;\n          let current;\n          const padding = this._pos ? this._pos : 0;\n\n          while (bytes < maxBytes && padding + bytes < this._list.length) {\n            current = this._list.readUInt8(padding + bytes++);\n            value += mul * (current & constants.VARBYTEINT_MASK);\n            mul *= 0x80;\n\n            if ((current & constants.VARBYTEINT_FIN_MASK) === 0) {\n              result = true;\n              break;\n            }\n\n            if (this._list.length <= bytes) {\n              break;\n            }\n          }\n\n          if (!result && bytes === maxBytes && this._list.length >= bytes) {\n            this._emitError(new Error('Invalid variable byte integer'));\n          }\n\n          if (padding) {\n            this._pos += bytes;\n          }\n\n          result = result ? fullInfoFlag ? {\n            bytes,\n            value\n          } : value : false;\n          debug('_parseVarByteNum: result: %o', result);\n          return result;\n        }\n\n        _parseByte() {\n          let result;\n\n          if (this._pos < this._list.length) {\n            result = this._list.readUInt8(this._pos);\n            this._pos++;\n          }\n\n          debug('_parseByte: result: %o', result);\n          return result;\n        }\n\n        _parseByType(type) {\n          debug('_parseByType: type: %s', type);\n\n          switch (type) {\n            case 'byte':\n              {\n                return this._parseByte() !== 0;\n              }\n\n            case 'int8':\n              {\n                return this._parseByte();\n              }\n\n            case 'int16':\n              {\n                return this._parseNum();\n              }\n\n            case 'int32':\n              {\n                return this._parse4ByteNum();\n              }\n\n            case 'var':\n              {\n                return this._parseVarByteNum();\n              }\n\n            case 'string':\n              {\n                return this._parseString();\n              }\n\n            case 'pair':\n              {\n                return this._parseStringPair();\n              }\n\n            case 'binary':\n              {\n                return this._parseBuffer();\n              }\n          }\n        }\n\n        _parseProperties() {\n          debug('_parseProperties');\n\n          const length = this._parseVarByteNum();\n\n          const start = this._pos;\n          const end = start + length;\n          const result = {};\n\n          while (this._pos < end) {\n            const type = this._parseByte();\n\n            if (!type) {\n              this._emitError(new Error('Cannot parse property code type'));\n\n              return false;\n            }\n\n            const name = constants.propertiesCodes[type];\n\n            if (!name) {\n              this._emitError(new Error('Unknown property'));\n\n              return false;\n            } // user properties process\n\n\n            if (name === 'userProperties') {\n              if (!result[name]) {\n                result[name] = Object.create(null);\n              }\n\n              const currentUserProperty = this._parseByType(constants.propertiesTypes[name]);\n\n              if (result[name][currentUserProperty.name]) {\n                if (Array.isArray(result[name][currentUserProperty.name])) {\n                  result[name][currentUserProperty.name].push(currentUserProperty.value);\n                } else {\n                  const currentValue = result[name][currentUserProperty.name];\n                  result[name][currentUserProperty.name] = [currentValue];\n                  result[name][currentUserProperty.name].push(currentUserProperty.value);\n                }\n              } else {\n                result[name][currentUserProperty.name] = currentUserProperty.value;\n              }\n\n              continue;\n            }\n\n            if (result[name]) {\n              if (Array.isArray(result[name])) {\n                result[name].push(this._parseByType(constants.propertiesTypes[name]));\n              } else {\n                result[name] = [result[name]];\n                result[name].push(this._parseByType(constants.propertiesTypes[name]));\n              }\n            } else {\n              result[name] = this._parseByType(constants.propertiesTypes[name]);\n            }\n          }\n\n          return result;\n        }\n\n        _newPacket() {\n          debug('_newPacket');\n\n          if (this.packet) {\n            this._list.consume(this.packet.length);\n\n            debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d', this.packet.cmd, this.packet.payload, this.packet.length);\n            this.emit('packet', this.packet);\n          }\n\n          debug('_newPacket: new packet');\n          this.packet = new Packet();\n          this._pos = 0;\n          return true;\n        }\n\n        _emitError(err) {\n          debug('_emitError');\n          this.error = err;\n          this.emit('error', err);\n        }\n\n      }\n\n      module.exports = Parser;\n    }, {\n      \"./constants\": 36,\n      \"./packet\": 40,\n      \"bl\": 17,\n      \"debug\": 19,\n      \"events\": 4\n    }],\n    42: [function (require, module, exports) {\n      (function (Buffer) {\n        (function () {\n          const protocol = require('./constants');\n\n          const empty = Buffer.allocUnsafe(0);\n          const zeroBuf = Buffer.from([0]);\n\n          const numbers = require('./numbers');\n\n          const nextTick = require('process-nextick-args').nextTick;\n\n          const debug = require('debug')('mqtt-packet:writeToStream');\n\n          const numCache = numbers.cache;\n          const generateNumber = numbers.generateNumber;\n          const generateCache = numbers.generateCache;\n          const genBufVariableByteInt = numbers.genBufVariableByteInt;\n          const generate4ByteBuffer = numbers.generate4ByteBuffer;\n          let writeNumber = writeNumberCached;\n          let toGenerate = true;\n\n          function generate(packet, stream, opts) {\n            debug('generate called');\n\n            if (stream.cork) {\n              stream.cork();\n              nextTick(uncork, stream);\n            }\n\n            if (toGenerate) {\n              toGenerate = false;\n              generateCache();\n            }\n\n            debug('generate: packet.cmd: %s', packet.cmd);\n\n            switch (packet.cmd) {\n              case 'connect':\n                return connect(packet, stream, opts);\n\n              case 'connack':\n                return connack(packet, stream, opts);\n\n              case 'publish':\n                return publish(packet, stream, opts);\n\n              case 'puback':\n              case 'pubrec':\n              case 'pubrel':\n              case 'pubcomp':\n                return confirmation(packet, stream, opts);\n\n              case 'subscribe':\n                return subscribe(packet, stream, opts);\n\n              case 'suback':\n                return suback(packet, stream, opts);\n\n              case 'unsubscribe':\n                return unsubscribe(packet, stream, opts);\n\n              case 'unsuback':\n                return unsuback(packet, stream, opts);\n\n              case 'pingreq':\n              case 'pingresp':\n                return emptyPacket(packet, stream, opts);\n\n              case 'disconnect':\n                return disconnect(packet, stream, opts);\n\n              case 'auth':\n                return auth(packet, stream, opts);\n\n              default:\n                stream.emit('error', new Error('Unknown command'));\n                return false;\n            }\n          }\n          /**\n           * Controls numbers cache.\n           * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n           */\n\n\n          Object.defineProperty(generate, 'cacheNumbers', {\n            get() {\n              return writeNumber === writeNumberCached;\n            },\n\n            set(value) {\n              if (value) {\n                if (!numCache || Object.keys(numCache).length === 0) toGenerate = true;\n                writeNumber = writeNumberCached;\n              } else {\n                toGenerate = false;\n                writeNumber = writeNumberGenerated;\n              }\n            }\n\n          });\n\n          function uncork(stream) {\n            stream.uncork();\n          }\n\n          function connect(packet, stream, opts) {\n            const settings = packet || {};\n            const protocolId = settings.protocolId || 'MQTT';\n            let protocolVersion = settings.protocolVersion || 4;\n            const will = settings.will;\n            let clean = settings.clean;\n            const keepalive = settings.keepalive || 0;\n            const clientId = settings.clientId || '';\n            const username = settings.username;\n            const password = settings.password;\n            /* mqtt5 new oprions */\n\n            const properties = settings.properties;\n            if (clean === undefined) clean = true;\n            let length = 0; // Must be a string and non-falsy\n\n            if (!protocolId || typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId)) {\n              stream.emit('error', new Error('Invalid protocolId'));\n              return false;\n            } else length += protocolId.length + 2; // Must be 3 or 4 or 5\n\n\n            if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n              stream.emit('error', new Error('Invalid protocol version'));\n              return false;\n            } else length += 1; // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n\n\n            if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) && (clientId || protocolVersion >= 4) && (clientId || clean)) {\n              length += Buffer.byteLength(clientId) + 2;\n            } else {\n              if (protocolVersion < 4) {\n                stream.emit('error', new Error('clientId must be supplied before 3.1.1'));\n                return false;\n              }\n\n              if (clean * 1 === 0) {\n                stream.emit('error', new Error('clientId must be given if cleanSession set to 0'));\n                return false;\n              }\n            } // Must be a two byte number\n\n\n            if (typeof keepalive !== 'number' || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {\n              stream.emit('error', new Error('Invalid keepalive'));\n              return false;\n            } else length += 2; // Connect flags\n\n\n            length += 1; // Properties\n\n            if (protocolVersion === 5) {\n              var propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // If will exists...\n\n\n            if (will) {\n              // It must be an object\n              if (typeof will !== 'object') {\n                stream.emit('error', new Error('Invalid will'));\n                return false;\n              } // It must have topic typeof string\n\n\n              if (!will.topic || typeof will.topic !== 'string') {\n                stream.emit('error', new Error('Invalid will topic'));\n                return false;\n              } else {\n                length += Buffer.byteLength(will.topic) + 2;\n              } // Payload\n\n\n              length += 2; // payload length\n\n              if (will.payload) {\n                if (will.payload.length >= 0) {\n                  if (typeof will.payload === 'string') {\n                    length += Buffer.byteLength(will.payload);\n                  } else {\n                    length += will.payload.length;\n                  }\n                } else {\n                  stream.emit('error', new Error('Invalid will payload'));\n                  return false;\n                }\n              } // will properties\n\n\n              var willProperties = {};\n\n              if (protocolVersion === 5) {\n                willProperties = getProperties(stream, will.properties);\n\n                if (!willProperties) {\n                  return false;\n                }\n\n                length += willProperties.length;\n              }\n            } // Username\n\n\n            let providedUsername = false;\n\n            if (username != null) {\n              if (isStringOrBuffer(username)) {\n                providedUsername = true;\n                length += Buffer.byteLength(username) + 2;\n              } else {\n                stream.emit('error', new Error('Invalid username'));\n                return false;\n              }\n            } // Password\n\n\n            if (password != null) {\n              if (!providedUsername) {\n                stream.emit('error', new Error('Username is required to use password'));\n                return false;\n              }\n\n              if (isStringOrBuffer(password)) {\n                length += byteLength(password) + 2;\n              } else {\n                stream.emit('error', new Error('Invalid password'));\n                return false;\n              }\n            } // Generate header\n\n\n            stream.write(protocol.CONNECT_HEADER); // Generate length\n\n            writeVarByteInt(stream, length); // Generate protocol ID\n\n            writeStringOrBuffer(stream, protocolId);\n\n            if (settings.bridgeMode) {\n              protocolVersion += 128;\n            }\n\n            stream.write(protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3); // Connect flags\n\n            let flags = 0;\n            flags |= username != null ? protocol.USERNAME_MASK : 0;\n            flags |= password != null ? protocol.PASSWORD_MASK : 0;\n            flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;\n            flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;\n            flags |= will ? protocol.WILL_FLAG_MASK : 0;\n            flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;\n            stream.write(Buffer.from([flags])); // Keepalive\n\n            writeNumber(stream, keepalive); // Properties\n\n            if (protocolVersion === 5) {\n              propertiesData.write();\n            } // Client ID\n\n\n            writeStringOrBuffer(stream, clientId); // Will\n\n            if (will) {\n              if (protocolVersion === 5) {\n                willProperties.write();\n              }\n\n              writeString(stream, will.topic);\n              writeStringOrBuffer(stream, will.payload);\n            } // Username and password\n\n\n            if (username != null) {\n              writeStringOrBuffer(stream, username);\n            }\n\n            if (password != null) {\n              writeStringOrBuffer(stream, password);\n            } // This is a small packet that happens only once on a stream\n            // We assume the stream is always free to receive more data after this\n\n\n            return true;\n          }\n\n          function connack(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const rc = version === 5 ? settings.reasonCode : settings.returnCode;\n            const properties = settings.properties;\n            let length = 2; // length of rc and sessionHeader\n            // Check return code\n\n            if (typeof rc !== 'number') {\n              stream.emit('error', new Error('Invalid return code'));\n              return false;\n            } // mqtt5 properties\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            }\n\n            stream.write(protocol.CONNACK_HEADER); // length\n\n            writeVarByteInt(stream, length);\n            stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);\n            stream.write(Buffer.from([rc]));\n\n            if (propertiesData != null) {\n              propertiesData.write();\n            }\n\n            return true;\n          }\n\n          function publish(packet, stream, opts) {\n            debug('publish: packet: %o', packet);\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const qos = settings.qos || 0;\n            const retain = settings.retain ? protocol.RETAIN_MASK : 0;\n            const topic = settings.topic;\n            const payload = settings.payload || empty;\n            const id = settings.messageId;\n            const properties = settings.properties;\n            let length = 0; // Topic must be a non-empty string or Buffer\n\n            if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2;else if (Buffer.isBuffer(topic)) length += topic.length + 2;else {\n              stream.emit('error', new Error('Invalid topic'));\n              return false;\n            } // Get the payload length\n\n            if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload);else length += payload.length; // Message ID must a number if qos > 0\n\n            if (qos && typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } else if (qos) length += 2; // mqtt5 properties\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Header\n\n\n            stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]); // Remaining length\n\n            writeVarByteInt(stream, length); // Topic\n\n            writeNumber(stream, byteLength(topic));\n            stream.write(topic); // Message ID\n\n            if (qos > 0) writeNumber(stream, id); // Properties\n\n            if (propertiesData != null) {\n              propertiesData.write();\n            } // Payload\n\n\n            debug('publish: payload: %o', payload);\n            return stream.write(payload);\n          }\n          /* Puback, pubrec, pubrel and pubcomp */\n\n\n          function confirmation(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const type = settings.cmd || 'puback';\n            const id = settings.messageId;\n            const dup = settings.dup && type === 'pubrel' ? protocol.DUP_MASK : 0;\n            let qos = 0;\n            const reasonCode = settings.reasonCode;\n            const properties = settings.properties;\n            let length = version === 5 ? 3 : 2;\n            if (type === 'pubrel') qos = 1; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n              if (typeof properties === 'object') {\n                propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n                if (!propertiesData) {\n                  return false;\n                }\n\n                length += propertiesData.length;\n              }\n            } // Header\n\n\n            stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n            writeVarByteInt(stream, length); // Message ID\n\n            writeNumber(stream, id); // reason code in header\n\n            if (version === 5) {\n              stream.write(Buffer.from([reasonCode]));\n            } // properies mqtt 5\n\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            return true;\n          }\n\n          function subscribe(packet, stream, opts) {\n            debug('subscribe: packet: ');\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const dup = settings.dup ? protocol.DUP_MASK : 0;\n            const id = settings.messageId;\n            const subs = settings.subscriptions;\n            const properties = settings.properties;\n            let length = 0; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } else length += 2; // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Check subscriptions\n\n\n            if (typeof subs === 'object' && subs.length) {\n              for (let i = 0; i < subs.length; i += 1) {\n                const itopic = subs[i].topic;\n                const iqos = subs[i].qos;\n\n                if (typeof itopic !== 'string') {\n                  stream.emit('error', new Error('Invalid subscriptions - invalid topic'));\n                  return false;\n                }\n\n                if (typeof iqos !== 'number') {\n                  stream.emit('error', new Error('Invalid subscriptions - invalid qos'));\n                  return false;\n                }\n\n                if (version === 5) {\n                  const nl = subs[i].nl || false;\n\n                  if (typeof nl !== 'boolean') {\n                    stream.emit('error', new Error('Invalid subscriptions - invalid No Local'));\n                    return false;\n                  }\n\n                  const rap = subs[i].rap || false;\n\n                  if (typeof rap !== 'boolean') {\n                    stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'));\n                    return false;\n                  }\n\n                  const rh = subs[i].rh || 0;\n\n                  if (typeof rh !== 'number' || rh > 2) {\n                    stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'));\n                    return false;\n                  }\n                }\n\n                length += Buffer.byteLength(itopic) + 2 + 1;\n              }\n            } else {\n              stream.emit('error', new Error('Invalid subscriptions'));\n              return false;\n            } // Generate header\n\n\n            debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER);\n            stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Generate length\n\n            writeVarByteInt(stream, length); // Generate message ID\n\n            writeNumber(stream, id); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            let result = true; // Generate subs\n\n            for (const sub of subs) {\n              const jtopic = sub.topic;\n              const jqos = sub.qos;\n              const jnl = +sub.nl;\n              const jrap = +sub.rap;\n              const jrh = sub.rh;\n              let joptions; // Write topic string\n\n              writeString(stream, jtopic); // options process\n\n              joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];\n\n              if (version === 5) {\n                joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;\n                joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;\n                joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;\n              } // Write options\n\n\n              result = stream.write(Buffer.from([joptions]));\n            }\n\n            return result;\n          }\n\n          function suback(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const id = settings.messageId;\n            const granted = settings.granted;\n            const properties = settings.properties;\n            let length = 0; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } else length += 2; // Check granted qos vector\n\n\n            if (typeof granted === 'object' && granted.length) {\n              for (let i = 0; i < granted.length; i += 1) {\n                if (typeof granted[i] !== 'number') {\n                  stream.emit('error', new Error('Invalid qos vector'));\n                  return false;\n                }\n\n                length += 1;\n              }\n            } else {\n              stream.emit('error', new Error('Invalid qos vector'));\n              return false;\n            } // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // header\n\n\n            stream.write(protocol.SUBACK_HEADER); // Length\n\n            writeVarByteInt(stream, length); // Message ID\n\n            writeNumber(stream, id); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            return stream.write(Buffer.from(granted));\n          }\n\n          function unsubscribe(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const id = settings.messageId;\n            const dup = settings.dup ? protocol.DUP_MASK : 0;\n            const unsubs = settings.unsubscriptions;\n            const properties = settings.properties;\n            let length = 0; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } else {\n              length += 2;\n            } // Check unsubs\n\n\n            if (typeof unsubs === 'object' && unsubs.length) {\n              for (let i = 0; i < unsubs.length; i += 1) {\n                if (typeof unsubs[i] !== 'string') {\n                  stream.emit('error', new Error('Invalid unsubscriptions'));\n                  return false;\n                }\n\n                length += Buffer.byteLength(unsubs[i]) + 2;\n              }\n            } else {\n              stream.emit('error', new Error('Invalid unsubscriptions'));\n              return false;\n            } // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getProperties(stream, properties);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Header\n\n\n            stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Length\n\n            writeVarByteInt(stream, length); // Message ID\n\n            writeNumber(stream, id); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            } // Unsubs\n\n\n            let result = true;\n\n            for (let j = 0; j < unsubs.length; j++) {\n              result = writeString(stream, unsubs[j]);\n            }\n\n            return result;\n          }\n\n          function unsuback(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const id = settings.messageId;\n            const dup = settings.dup ? protocol.DUP_MASK : 0;\n            const granted = settings.granted;\n            const properties = settings.properties;\n            const type = settings.cmd;\n            const qos = 0;\n            let length = 2; // Check message ID\n\n            if (typeof id !== 'number') {\n              stream.emit('error', new Error('Invalid messageId'));\n              return false;\n            } // Check granted\n\n\n            if (version === 5) {\n              if (typeof granted === 'object' && granted.length) {\n                for (let i = 0; i < granted.length; i += 1) {\n                  if (typeof granted[i] !== 'number') {\n                    stream.emit('error', new Error('Invalid qos vector'));\n                    return false;\n                  }\n\n                  length += 1;\n                }\n              } else {\n                stream.emit('error', new Error('Invalid qos vector'));\n                return false;\n              }\n            } // properies mqtt 5\n\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Header\n\n\n            stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n            writeVarByteInt(stream, length); // Message ID\n\n            writeNumber(stream, id); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            } // payload\n\n\n            if (version === 5) {\n              stream.write(Buffer.from(granted));\n            }\n\n            return true;\n          }\n\n          function emptyPacket(packet, stream, opts) {\n            return stream.write(protocol.EMPTY[packet.cmd]);\n          }\n\n          function disconnect(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const reasonCode = settings.reasonCode;\n            const properties = settings.properties;\n            let length = version === 5 ? 1 : 0; // properies mqtt 5\n\n            let propertiesData = null;\n\n            if (version === 5) {\n              propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n              if (!propertiesData) {\n                return false;\n              }\n\n              length += propertiesData.length;\n            } // Header\n\n\n            stream.write(Buffer.from([protocol.codes.disconnect << 4])); // Length\n\n            writeVarByteInt(stream, length); // reason code in header\n\n            if (version === 5) {\n              stream.write(Buffer.from([reasonCode]));\n            } // properies mqtt 5\n\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            return true;\n          }\n\n          function auth(packet, stream, opts) {\n            const version = opts ? opts.protocolVersion : 4;\n            const settings = packet || {};\n            const reasonCode = settings.reasonCode;\n            const properties = settings.properties;\n            let length = version === 5 ? 1 : 0;\n            if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet')); // properies mqtt 5\n\n            const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n            if (!propertiesData) {\n              return false;\n            }\n\n            length += propertiesData.length; // Header\n\n            stream.write(Buffer.from([protocol.codes.auth << 4])); // Length\n\n            writeVarByteInt(stream, length); // reason code in header\n\n            stream.write(Buffer.from([reasonCode])); // properies mqtt 5\n\n            if (propertiesData !== null) {\n              propertiesData.write();\n            }\n\n            return true;\n          }\n          /**\n           * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n           *\n           * @param <Buffer> buffer - destination\n           * @param <Number> pos - offset\n           * @param <Number> length - length (>0)\n           * @returns <Number> number of bytes written\n           *\n           * @api private\n           */\n\n\n          const varByteIntCache = {};\n\n          function writeVarByteInt(stream, num) {\n            if (num > protocol.VARBYTEINT_MAX) {\n              stream.emit('error', new Error(`Invalid variable byte integer: ${num}`));\n              return false;\n            }\n\n            let buffer = varByteIntCache[num];\n\n            if (!buffer) {\n              buffer = genBufVariableByteInt(num);\n              if (num < 16384) varByteIntCache[num] = buffer;\n            }\n\n            debug('writeVarByteInt: writing to stream: %o', buffer);\n            return stream.write(buffer);\n          }\n          /**\n           * writeString - write a utf8 string to the buffer\n           *\n           * @param <Buffer> buffer - destination\n           * @param <Number> pos - offset\n           * @param <String> string - string to write\n           * @return <Number> number of bytes written\n           *\n           * @api private\n           */\n\n\n          function writeString(stream, string) {\n            const strlen = Buffer.byteLength(string);\n            writeNumber(stream, strlen);\n            debug('writeString: %s', string);\n            return stream.write(string, 'utf8');\n          }\n          /**\n           * writeStringPair - write a utf8 string pairs to the buffer\n           *\n           * @param <Buffer> buffer - destination\n           * @param <String> name - string name to write\n           * @param <String> value - string value to write\n           * @return <Number> number of bytes written\n           *\n           * @api private\n           */\n\n\n          function writeStringPair(stream, name, value) {\n            writeString(stream, name);\n            writeString(stream, value);\n          }\n          /**\n           * writeNumber - write a two byte number to the buffer\n           *\n           * @param <Buffer> buffer - destination\n           * @param <Number> pos - offset\n           * @param <String> number - number to write\n           * @return <Number> number of bytes written\n           *\n           * @api private\n           */\n\n\n          function writeNumberCached(stream, number) {\n            debug('writeNumberCached: number: %d', number);\n            debug('writeNumberCached: %o', numCache[number]);\n            return stream.write(numCache[number]);\n          }\n\n          function writeNumberGenerated(stream, number) {\n            const generatedNumber = generateNumber(number);\n            debug('writeNumberGenerated: %o', generatedNumber);\n            return stream.write(generatedNumber);\n          }\n\n          function write4ByteNumber(stream, number) {\n            const generated4ByteBuffer = generate4ByteBuffer(number);\n            debug('write4ByteNumber: %o', generated4ByteBuffer);\n            return stream.write(generated4ByteBuffer);\n          }\n          /**\n           * writeStringOrBuffer - write a String or Buffer with the its length prefix\n           *\n           * @param <Buffer> buffer - destination\n           * @param <Number> pos - offset\n           * @param <String> toWrite - String or Buffer\n           * @return <Number> number of bytes written\n           */\n\n\n          function writeStringOrBuffer(stream, toWrite) {\n            if (typeof toWrite === 'string') {\n              writeString(stream, toWrite);\n            } else if (toWrite) {\n              writeNumber(stream, toWrite.length);\n              stream.write(toWrite);\n            } else writeNumber(stream, 0);\n          }\n\n          function getProperties(stream, properties) {\n            /* connect properties */\n            if (typeof properties !== 'object' || properties.length != null) {\n              return {\n                length: 1,\n\n                write() {\n                  writeProperties(stream, {}, 0);\n                }\n\n              };\n            }\n\n            let propertiesLength = 0;\n\n            function getLengthProperty(name, value) {\n              const type = protocol.propertiesTypes[name];\n              let length = 0;\n\n              switch (type) {\n                case 'byte':\n                  {\n                    if (typeof value !== 'boolean') {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 1;\n                    break;\n                  }\n\n                case 'int8':\n                  {\n                    if (typeof value !== 'number' || value < 0 || value > 0xff) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 1;\n                    break;\n                  }\n\n                case 'binary':\n                  {\n                    if (value && value === null) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + Buffer.byteLength(value) + 2;\n                    break;\n                  }\n\n                case 'int16':\n                  {\n                    if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 2;\n                    break;\n                  }\n\n                case 'int32':\n                  {\n                    if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 4;\n                    break;\n                  }\n\n                case 'var':\n                  {\n                    // var byte integer is max 24 bits packed in 32 bits\n                    if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + Buffer.byteLength(genBufVariableByteInt(value));\n                    break;\n                  }\n\n                case 'string':\n                  {\n                    if (typeof value !== 'string') {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += 1 + 2 + Buffer.byteLength(value.toString());\n                    break;\n                  }\n\n                case 'pair':\n                  {\n                    if (typeof value !== 'object') {\n                      stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n                      return false;\n                    }\n\n                    length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n                      const currentValue = value[name];\n\n                      if (Array.isArray(currentValue)) {\n                        result += currentValue.reduce((currentLength, value) => {\n                          currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString());\n                          return currentLength;\n                        }, 0);\n                      } else {\n                        result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString());\n                      }\n\n                      return result;\n                    }, 0);\n                    break;\n                  }\n\n                default:\n                  {\n                    stream.emit('error', new Error(`Invalid property ${name}: ${value}`));\n                    return false;\n                  }\n              }\n\n              return length;\n            }\n\n            if (properties) {\n              for (const propName in properties) {\n                let propLength = 0;\n                let propValueLength = 0;\n                const propValue = properties[propName];\n\n                if (Array.isArray(propValue)) {\n                  for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n                    propValueLength = getLengthProperty(propName, propValue[valueIndex]);\n\n                    if (!propValueLength) {\n                      return false;\n                    }\n\n                    propLength += propValueLength;\n                  }\n                } else {\n                  propValueLength = getLengthProperty(propName, propValue);\n\n                  if (!propValueLength) {\n                    return false;\n                  }\n\n                  propLength = propValueLength;\n                }\n\n                if (!propLength) return false;\n                propertiesLength += propLength;\n              }\n            }\n\n            const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength));\n            return {\n              length: propertiesLengthLength + propertiesLength,\n\n              write() {\n                writeProperties(stream, properties, propertiesLength);\n              }\n\n            };\n          }\n\n          function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {\n            const mayEmptyProps = ['reasonString', 'userProperties'];\n            const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;\n            let propertiesData = getProperties(stream, properties);\n\n            if (maximumPacketSize) {\n              while (length + propertiesData.length > maximumPacketSize) {\n                const currentMayEmptyProp = mayEmptyProps.shift();\n\n                if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n                  delete properties[currentMayEmptyProp];\n                  propertiesData = getProperties(stream, properties);\n                } else {\n                  return false;\n                }\n              }\n            }\n\n            return propertiesData;\n          }\n\n          function writeProperty(stream, propName, value) {\n            const type = protocol.propertiesTypes[propName];\n\n            switch (type) {\n              case 'byte':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([+value]));\n                  break;\n                }\n\n              case 'int8':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([value]));\n                  break;\n                }\n\n              case 'binary':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeStringOrBuffer(stream, value);\n                  break;\n                }\n\n              case 'int16':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeNumber(stream, value);\n                  break;\n                }\n\n              case 'int32':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  write4ByteNumber(stream, value);\n                  break;\n                }\n\n              case 'var':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeVarByteInt(stream, value);\n                  break;\n                }\n\n              case 'string':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeString(stream, value);\n                  break;\n                }\n\n              case 'pair':\n                {\n                  Object.getOwnPropertyNames(value).forEach(name => {\n                    const currentValue = value[name];\n\n                    if (Array.isArray(currentValue)) {\n                      currentValue.forEach(value => {\n                        stream.write(Buffer.from([protocol.properties[propName]]));\n                        writeStringPair(stream, name.toString(), value.toString());\n                      });\n                    } else {\n                      stream.write(Buffer.from([protocol.properties[propName]]));\n                      writeStringPair(stream, name.toString(), currentValue.toString());\n                    }\n                  });\n                  break;\n                }\n\n              default:\n                {\n                  stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`));\n                  return false;\n                }\n            }\n          }\n\n          function writeProperties(stream, properties, propertiesLength) {\n            /* write properties to stream */\n            writeVarByteInt(stream, propertiesLength);\n\n            for (const propName in properties) {\n              if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n                const value = properties[propName];\n\n                if (Array.isArray(value)) {\n                  for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n                    writeProperty(stream, propName, value[valueIndex]);\n                  }\n                } else {\n                  writeProperty(stream, propName, value);\n                }\n              }\n            }\n          }\n\n          function byteLength(bufOrString) {\n            if (!bufOrString) return 0;else if (bufOrString instanceof Buffer) return bufOrString.length;else return Buffer.byteLength(bufOrString);\n          }\n\n          function isStringOrBuffer(field) {\n            return typeof field === 'string' || field instanceof Buffer;\n          }\n\n          module.exports = generate;\n        }).call(this);\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"./constants\": 36,\n      \"./numbers\": 39,\n      \"buffer\": 3,\n      \"debug\": 19,\n      \"process-nextick-args\": 45\n    }],\n    43: [function (require, module, exports) {\n      /**\n       * Helpers.\n       */\n      var s = 1000;\n      var m = s * 60;\n      var h = m * 60;\n      var d = h * 24;\n      var w = d * 7;\n      var y = d * 365.25;\n      /**\n       * Parse or format the given `val`.\n       *\n       * Options:\n       *\n       *  - `long` verbose formatting [false]\n       *\n       * @param {String|Number} val\n       * @param {Object} [options]\n       * @throws {Error} throw an error if val is not a non-empty string or a number\n       * @return {String|Number}\n       * @api public\n       */\n\n      module.exports = function (val, options) {\n        options = options || {};\n        var type = typeof val;\n\n        if (type === 'string' && val.length > 0) {\n          return parse(val);\n        } else if (type === 'number' && isFinite(val)) {\n          return options.long ? fmtLong(val) : fmtShort(val);\n        }\n\n        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n      };\n      /**\n       * Parse the given `str` and return milliseconds.\n       *\n       * @param {String} str\n       * @return {Number}\n       * @api private\n       */\n\n\n      function parse(str) {\n        str = String(str);\n\n        if (str.length > 100) {\n          return;\n        }\n\n        var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n\n        if (!match) {\n          return;\n        }\n\n        var n = parseFloat(match[1]);\n        var type = (match[2] || 'ms').toLowerCase();\n\n        switch (type) {\n          case 'years':\n          case 'year':\n          case 'yrs':\n          case 'yr':\n          case 'y':\n            return n * y;\n\n          case 'weeks':\n          case 'week':\n          case 'w':\n            return n * w;\n\n          case 'days':\n          case 'day':\n          case 'd':\n            return n * d;\n\n          case 'hours':\n          case 'hour':\n          case 'hrs':\n          case 'hr':\n          case 'h':\n            return n * h;\n\n          case 'minutes':\n          case 'minute':\n          case 'mins':\n          case 'min':\n          case 'm':\n            return n * m;\n\n          case 'seconds':\n          case 'second':\n          case 'secs':\n          case 'sec':\n          case 's':\n            return n * s;\n\n          case 'milliseconds':\n          case 'millisecond':\n          case 'msecs':\n          case 'msec':\n          case 'ms':\n            return n;\n\n          default:\n            return undefined;\n        }\n      }\n      /**\n       * Short format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n\n      function fmtShort(ms) {\n        var msAbs = Math.abs(ms);\n\n        if (msAbs >= d) {\n          return Math.round(ms / d) + 'd';\n        }\n\n        if (msAbs >= h) {\n          return Math.round(ms / h) + 'h';\n        }\n\n        if (msAbs >= m) {\n          return Math.round(ms / m) + 'm';\n        }\n\n        if (msAbs >= s) {\n          return Math.round(ms / s) + 's';\n        }\n\n        return ms + 'ms';\n      }\n      /**\n       * Long format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n\n      function fmtLong(ms) {\n        var msAbs = Math.abs(ms);\n\n        if (msAbs >= d) {\n          return plural(ms, msAbs, d, 'day');\n        }\n\n        if (msAbs >= h) {\n          return plural(ms, msAbs, h, 'hour');\n        }\n\n        if (msAbs >= m) {\n          return plural(ms, msAbs, m, 'minute');\n        }\n\n        if (msAbs >= s) {\n          return plural(ms, msAbs, s, 'second');\n        }\n\n        return ms + ' ms';\n      }\n      /**\n       * Pluralization helper.\n       */\n\n\n      function plural(ms, msAbs, n, name) {\n        var isPlural = msAbs >= n * 1.5;\n        return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n      }\n    }, {}],\n    44: [function (require, module, exports) {\n      var wrappy = require('wrappy');\n\n      module.exports = wrappy(once);\n      module.exports.strict = wrappy(onceStrict);\n      once.proto = once(function () {\n        Object.defineProperty(Function.prototype, 'once', {\n          value: function () {\n            return once(this);\n          },\n          configurable: true\n        });\n        Object.defineProperty(Function.prototype, 'onceStrict', {\n          value: function () {\n            return onceStrict(this);\n          },\n          configurable: true\n        });\n      });\n\n      function once(fn) {\n        var f = function () {\n          if (f.called) return f.value;\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n\n        f.called = false;\n        return f;\n      }\n\n      function onceStrict(fn) {\n        var f = function () {\n          if (f.called) throw new Error(f.onceError);\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n\n        var name = fn.name || 'Function wrapped with `once`';\n        f.onceError = name + \" shouldn't be called more than once\";\n        f.called = false;\n        return f;\n      }\n    }, {\n      \"wrappy\": 66\n    }],\n    45: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n            module.exports = {\n              nextTick: nextTick\n            };\n          } else {\n            module.exports = process;\n          }\n\n          function nextTick(fn, arg1, arg2, arg3) {\n            if (typeof fn !== 'function') {\n              throw new TypeError('\"callback\" argument must be a function');\n            }\n\n            var len = arguments.length;\n            var args, i;\n\n            switch (len) {\n              case 0:\n              case 1:\n                return process.nextTick(fn);\n\n              case 2:\n                return process.nextTick(function afterTickOne() {\n                  fn.call(null, arg1);\n                });\n\n              case 3:\n                return process.nextTick(function afterTickTwo() {\n                  fn.call(null, arg1, arg2);\n                });\n\n              case 4:\n                return process.nextTick(function afterTickThree() {\n                  fn.call(null, arg1, arg2, arg3);\n                });\n\n              default:\n                args = new Array(len - 1);\n                i = 0;\n\n                while (i < args.length) {\n                  args[i++] = arguments[i];\n                }\n\n                return process.nextTick(function afterTick() {\n                  fn.apply(null, args);\n                });\n            }\n          }\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"_process\": 69\n    }],\n    46: [function (require, module, exports) {\n      'use strict';\n\n      function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n\n      var codes = {};\n\n      function createErrorType(code, message, Base) {\n        if (!Base) {\n          Base = Error;\n        }\n\n        function getMessage(arg1, arg2, arg3) {\n          if (typeof message === 'string') {\n            return message;\n          } else {\n            return message(arg1, arg2, arg3);\n          }\n        }\n\n        var NodeError = /*#__PURE__*/function (_Base) {\n          _inheritsLoose(NodeError, _Base);\n\n          function NodeError(arg1, arg2, arg3) {\n            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n          }\n\n          return NodeError;\n        }(Base);\n\n        NodeError.prototype.name = Base.name;\n        NodeError.prototype.code = code;\n        codes[code] = NodeError;\n      } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\n      function oneOf(expected, thing) {\n        if (Array.isArray(expected)) {\n          var len = expected.length;\n          expected = expected.map(function (i) {\n            return String(i);\n          });\n\n          if (len > 2) {\n            return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n          } else if (len === 2) {\n            return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n          } else {\n            return \"of \".concat(thing, \" \").concat(expected[0]);\n          }\n        } else {\n          return \"of \".concat(thing, \" \").concat(String(expected));\n        }\n      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\n      function startsWith(str, search, pos) {\n        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\n      function endsWith(str, search, this_len) {\n        if (this_len === undefined || this_len > str.length) {\n          this_len = str.length;\n        }\n\n        return str.substring(this_len - search.length, this_len) === search;\n      } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\n      function includes(str, search, start) {\n        if (typeof start !== 'number') {\n          start = 0;\n        }\n\n        if (start + search.length > str.length) {\n          return false;\n        } else {\n          return str.indexOf(search, start) !== -1;\n        }\n      }\n\n      createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n        return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n      }, TypeError);\n      createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n        // determiner: 'must be' or 'must not be'\n        var determiner;\n\n        if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n          determiner = 'must not be';\n          expected = expected.replace(/^not /, '');\n        } else {\n          determiner = 'must be';\n        }\n\n        var msg;\n\n        if (endsWith(name, ' argument')) {\n          // For cases like 'first argument'\n          msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n        } else {\n          var type = includes(name, '.') ? 'property' : 'argument';\n          msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n        }\n\n        msg += \". Received type \".concat(typeof actual);\n        return msg;\n      }, TypeError);\n      createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\n      createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n        return 'The ' + name + ' method is not implemented';\n      });\n      createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\n      createErrorType('ERR_STREAM_DESTROYED', function (name) {\n        return 'Cannot call ' + name + ' after a stream was destroyed';\n      });\n      createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\n      createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\n      createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\n      createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\n      createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n        return 'Unknown encoding: ' + arg;\n      }, TypeError);\n      createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\n      module.exports.codes = codes;\n    }, {}],\n    47: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // a duplex stream is just a stream that is both readable and writable.\n          // Since JS doesn't have multiple prototypal inheritance, this class\n          // prototypally inherits from Readable, and then parasitically from\n          // Writable.\n          'use strict';\n          /*<replacement>*/\n\n          var objectKeys = Object.keys || function (obj) {\n            var keys = [];\n\n            for (var key in obj) {\n              keys.push(key);\n            }\n\n            return keys;\n          };\n          /*</replacement>*/\n\n\n          module.exports = Duplex;\n\n          var Readable = require('./_stream_readable');\n\n          var Writable = require('./_stream_writable');\n\n          require('inherits')(Duplex, Readable);\n\n          {\n            // Allow the keys array to be GC'ed.\n            var keys = objectKeys(Writable.prototype);\n\n            for (var v = 0; v < keys.length; v++) {\n              var method = keys[v];\n              if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n            }\n          }\n\n          function Duplex(options) {\n            if (!(this instanceof Duplex)) return new Duplex(options);\n            Readable.call(this, options);\n            Writable.call(this, options);\n            this.allowHalfOpen = true;\n\n            if (options) {\n              if (options.readable === false) this.readable = false;\n              if (options.writable === false) this.writable = false;\n\n              if (options.allowHalfOpen === false) {\n                this.allowHalfOpen = false;\n                this.once('end', onend);\n              }\n            }\n          }\n\n          Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.highWaterMark;\n            }\n          });\n          Object.defineProperty(Duplex.prototype, 'writableBuffer', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState && this._writableState.getBuffer();\n            }\n          });\n          Object.defineProperty(Duplex.prototype, 'writableLength', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.length;\n            }\n          }); // the no-half-open enforcer\n\n          function onend() {\n            // If the writable side ended, then we're ok.\n            if (this._writableState.ended) return; // no more data can be written.\n            // But allow more writes to happen in this tick.\n\n            process.nextTick(onEndNT, this);\n          }\n\n          function onEndNT(self) {\n            self.end();\n          }\n\n          Object.defineProperty(Duplex.prototype, 'destroyed', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              if (this._readableState === undefined || this._writableState === undefined) {\n                return false;\n              }\n\n              return this._readableState.destroyed && this._writableState.destroyed;\n            },\n            set: function set(value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (this._readableState === undefined || this._writableState === undefined) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._readableState.destroyed = value;\n              this._writableState.destroyed = value;\n            }\n          });\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"./_stream_readable\": 49,\n      \"./_stream_writable\": 51,\n      \"_process\": 69,\n      \"inherits\": 34\n    }],\n    48: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a passthrough stream.\n      // basically just the most minimal sort of Transform stream.\n      // Every written chunk gets output as-is.\n      'use strict';\n\n      module.exports = PassThrough;\n\n      var Transform = require('./_stream_transform');\n\n      require('inherits')(PassThrough, Transform);\n\n      function PassThrough(options) {\n        if (!(this instanceof PassThrough)) return new PassThrough(options);\n        Transform.call(this, options);\n      }\n\n      PassThrough.prototype._transform = function (chunk, encoding, cb) {\n        cb(null, chunk);\n      };\n    }, {\n      \"./_stream_transform\": 50,\n      \"inherits\": 34\n    }],\n    49: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          'use strict';\n\n          module.exports = Readable;\n          /*<replacement>*/\n\n          var Duplex;\n          /*</replacement>*/\n\n          Readable.ReadableState = ReadableState;\n          /*<replacement>*/\n\n          var EE = require('events').EventEmitter;\n\n          var EElistenerCount = function EElistenerCount(emitter, type) {\n            return emitter.listeners(type).length;\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Stream = require('./internal/streams/stream');\n          /*</replacement>*/\n\n\n          var Buffer = require('buffer').Buffer;\n\n          var OurUint8Array = global.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n          /*<replacement>*/\n\n\n          var debugUtil = require('util');\n\n          var debug;\n\n          if (debugUtil && debugUtil.debuglog) {\n            debug = debugUtil.debuglog('stream');\n          } else {\n            debug = function debug() {};\n          }\n          /*</replacement>*/\n\n\n          var BufferList = require('./internal/streams/buffer_list');\n\n          var destroyImpl = require('./internal/streams/destroy');\n\n          var _require = require('./internal/streams/state'),\n              getHighWaterMark = _require.getHighWaterMark;\n\n          var _require$codes = require('../errors').codes,\n              ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n              ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n              ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n              ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\n          var StringDecoder;\n          var createReadableStreamAsyncIterator;\n          var from;\n\n          require('inherits')(Readable, Stream);\n\n          var errorOrDestroy = destroyImpl.errorOrDestroy;\n          var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\n          function prependListener(emitter, event, fn) {\n            // Sadly this is not cacheable as some libraries bundle their own\n            // event emitter implementation with them.\n            if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n            // userland ones.  NEVER DO THIS. This is here only because this code needs\n            // to continue to work with older versions of Node.js that do not include\n            // the prependListener() method. The goal is to eventually remove this hack.\n\n            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n          }\n\n          function ReadableState(options, stream, isDuplex) {\n            Duplex = Duplex || require('./_stream_duplex');\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream.\n            // These options can be provided separately as readableXXX and writableXXX.\n\n            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n            // make all the buffer merging and length checks go away\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n            // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n            this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n            // linked list can remove elements from the beginning faster than\n            // array.shift()\n\n            this.buffer = new BufferList();\n            this.length = 0;\n            this.pipes = null;\n            this.pipesCount = 0;\n            this.flowing = null;\n            this.ended = false;\n            this.endEmitted = false;\n            this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n            // immediately, or on a later tick.  We set this to true at first, because\n            // any actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first read call.\n\n            this.sync = true; // whenever we return null, then we set a flag to say\n            // that we're awaiting a 'readable' event emission.\n\n            this.needReadable = false;\n            this.emittedReadable = false;\n            this.readableListening = false;\n            this.resumeScheduled = false;\n            this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n            this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n            this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n            this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n            this.readingMore = false;\n            this.decoder = null;\n            this.encoding = null;\n\n            if (options.encoding) {\n              if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n              this.decoder = new StringDecoder(options.encoding);\n              this.encoding = options.encoding;\n            }\n          }\n\n          function Readable(options) {\n            Duplex = Duplex || require('./_stream_duplex');\n            if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n            // the ReadableState constructor, at least with V8 6.5\n\n            var isDuplex = this instanceof Duplex;\n            this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n            this.readable = true;\n\n            if (options) {\n              if (typeof options.read === 'function') this._read = options.read;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n            }\n\n            Stream.call(this);\n          }\n\n          Object.defineProperty(Readable.prototype, 'destroyed', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              if (this._readableState === undefined) {\n                return false;\n              }\n\n              return this._readableState.destroyed;\n            },\n            set: function set(value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._readableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._readableState.destroyed = value;\n            }\n          });\n          Readable.prototype.destroy = destroyImpl.destroy;\n          Readable.prototype._undestroy = destroyImpl.undestroy;\n\n          Readable.prototype._destroy = function (err, cb) {\n            cb(err);\n          }; // Manually shove something into the read() buffer.\n          // This returns true if the highWaterMark has not been hit yet,\n          // similar to how Writable.write() returns true if you should\n          // write() some more.\n\n\n          Readable.prototype.push = function (chunk, encoding) {\n            var state = this._readableState;\n            var skipChunkCheck;\n\n            if (!state.objectMode) {\n              if (typeof chunk === 'string') {\n                encoding = encoding || state.defaultEncoding;\n\n                if (encoding !== state.encoding) {\n                  chunk = Buffer.from(chunk, encoding);\n                  encoding = '';\n                }\n\n                skipChunkCheck = true;\n              }\n            } else {\n              skipChunkCheck = true;\n            }\n\n            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n          }; // Unshift should *always* be something directly out of read()\n\n\n          Readable.prototype.unshift = function (chunk) {\n            return readableAddChunk(this, chunk, null, true, false);\n          };\n\n          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n            debug('readableAddChunk', chunk);\n            var state = stream._readableState;\n\n            if (chunk === null) {\n              state.reading = false;\n              onEofChunk(stream, state);\n            } else {\n              var er;\n              if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n              if (er) {\n                errorOrDestroy(stream, er);\n              } else if (state.objectMode || chunk && chunk.length > 0) {\n                if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                  chunk = _uint8ArrayToBuffer(chunk);\n                }\n\n                if (addToFront) {\n                  if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n                } else if (state.ended) {\n                  errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n                } else if (state.destroyed) {\n                  return false;\n                } else {\n                  state.reading = false;\n\n                  if (state.decoder && !encoding) {\n                    chunk = state.decoder.write(chunk);\n                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n                  } else {\n                    addChunk(stream, state, chunk, false);\n                  }\n                }\n              } else if (!addToFront) {\n                state.reading = false;\n                maybeReadMore(stream, state);\n              }\n            } // We can push more data if we are below the highWaterMark.\n            // Also, if we have no data yet, we can stand some more bytes.\n            // This is to work around cases where hwm=0, such as the repl.\n\n\n            return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n          }\n\n          function addChunk(stream, state, chunk, addToFront) {\n            if (state.flowing && state.length === 0 && !state.sync) {\n              state.awaitDrain = 0;\n              stream.emit('data', chunk);\n            } else {\n              // update the buffer info.\n              state.length += state.objectMode ? 1 : chunk.length;\n              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n              if (state.needReadable) emitReadable(stream);\n            }\n\n            maybeReadMore(stream, state);\n          }\n\n          function chunkInvalid(state, chunk) {\n            var er;\n\n            if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n            }\n\n            return er;\n          }\n\n          Readable.prototype.isPaused = function () {\n            return this._readableState.flowing === false;\n          }; // backwards compatibility.\n\n\n          Readable.prototype.setEncoding = function (enc) {\n            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n            var decoder = new StringDecoder(enc);\n            this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n            this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n            var p = this._readableState.buffer.head;\n            var content = '';\n\n            while (p !== null) {\n              content += decoder.write(p.data);\n              p = p.next;\n            }\n\n            this._readableState.buffer.clear();\n\n            if (content !== '') this._readableState.buffer.push(content);\n            this._readableState.length = content.length;\n            return this;\n          }; // Don't raise the hwm > 1GB\n\n\n          var MAX_HWM = 0x40000000;\n\n          function computeNewHighWaterMark(n) {\n            if (n >= MAX_HWM) {\n              // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n              n = MAX_HWM;\n            } else {\n              // Get the next highest power of 2 to prevent increasing hwm excessively in\n              // tiny amounts\n              n--;\n              n |= n >>> 1;\n              n |= n >>> 2;\n              n |= n >>> 4;\n              n |= n >>> 8;\n              n |= n >>> 16;\n              n++;\n            }\n\n            return n;\n          } // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function howMuchToRead(n, state) {\n            if (n <= 0 || state.length === 0 && state.ended) return 0;\n            if (state.objectMode) return 1;\n\n            if (n !== n) {\n              // Only flow one buffer at a time\n              if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n            } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n            if (n <= state.length) return n; // Don't have enough\n\n            if (!state.ended) {\n              state.needReadable = true;\n              return 0;\n            }\n\n            return state.length;\n          } // you can override either this method, or the async _read(n) below.\n\n\n          Readable.prototype.read = function (n) {\n            debug('read', n);\n            n = parseInt(n, 10);\n            var state = this._readableState;\n            var nOrig = n;\n            if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n            // already have a bunch of data in the buffer, then just trigger\n            // the 'readable' event and move on.\n\n            if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n              debug('read: emitReadable', state.length, state.ended);\n              if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n              return null;\n            }\n\n            n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n            if (n === 0 && state.ended) {\n              if (state.length === 0) endReadable(this);\n              return null;\n            } // All the actual chunk generation logic needs to be\n            // *below* the call to _read.  The reason is that in certain\n            // synthetic stream cases, such as passthrough streams, _read\n            // may be a completely synchronous operation which may change\n            // the state of the read buffer, providing enough data when\n            // before there was *not* enough.\n            //\n            // So, the steps are:\n            // 1. Figure out what the state of things will be after we do\n            // a read from the buffer.\n            //\n            // 2. If that resulting state will trigger a _read, then call _read.\n            // Note that this may be asynchronous, or synchronous.  Yes, it is\n            // deeply ugly to write APIs this way, but that still doesn't mean\n            // that the Readable class should behave improperly, as streams are\n            // designed to be sync/async agnostic.\n            // Take note if the _read call is sync or async (ie, if the read call\n            // has returned yet), so that we know whether or not it's safe to emit\n            // 'readable' etc.\n            //\n            // 3. Actually pull the requested chunks out of the buffer and return.\n            // if we need a readable event, then we need to do some reading.\n\n\n            var doRead = state.needReadable;\n            debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n            if (state.length === 0 || state.length - n < state.highWaterMark) {\n              doRead = true;\n              debug('length less than watermark', doRead);\n            } // however, if we've ended, then there's no point, and if we're already\n            // reading, then it's unnecessary.\n\n\n            if (state.ended || state.reading) {\n              doRead = false;\n              debug('reading or ended', doRead);\n            } else if (doRead) {\n              debug('do read');\n              state.reading = true;\n              state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n              if (state.length === 0) state.needReadable = true; // call internal read method\n\n              this._read(state.highWaterMark);\n\n              state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n              // and we need to re-evaluate how much data we can return to the user.\n\n              if (!state.reading) n = howMuchToRead(nOrig, state);\n            }\n\n            var ret;\n            if (n > 0) ret = fromList(n, state);else ret = null;\n\n            if (ret === null) {\n              state.needReadable = state.length <= state.highWaterMark;\n              n = 0;\n            } else {\n              state.length -= n;\n              state.awaitDrain = 0;\n            }\n\n            if (state.length === 0) {\n              // If we have nothing in the buffer, then we want to know\n              // as soon as we *do* get something into the buffer.\n              if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n              if (nOrig !== n && state.ended) endReadable(this);\n            }\n\n            if (ret !== null) this.emit('data', ret);\n            return ret;\n          };\n\n          function onEofChunk(stream, state) {\n            debug('onEofChunk');\n            if (state.ended) return;\n\n            if (state.decoder) {\n              var chunk = state.decoder.end();\n\n              if (chunk && chunk.length) {\n                state.buffer.push(chunk);\n                state.length += state.objectMode ? 1 : chunk.length;\n              }\n            }\n\n            state.ended = true;\n\n            if (state.sync) {\n              // if we are sync, wait until next tick to emit the data.\n              // Otherwise we risk emitting data in the flow()\n              // the readable code triggers during a read() call\n              emitReadable(stream);\n            } else {\n              // emit 'readable' now to make sure it gets picked up.\n              state.needReadable = false;\n\n              if (!state.emittedReadable) {\n                state.emittedReadable = true;\n                emitReadable_(stream);\n              }\n            }\n          } // Don't emit readable right away in sync mode, because this can trigger\n          // another read() call => stack overflow.  This way, it might trigger\n          // a nextTick recursion warning, but that's not so bad.\n\n\n          function emitReadable(stream) {\n            var state = stream._readableState;\n            debug('emitReadable', state.needReadable, state.emittedReadable);\n            state.needReadable = false;\n\n            if (!state.emittedReadable) {\n              debug('emitReadable', state.flowing);\n              state.emittedReadable = true;\n              process.nextTick(emitReadable_, stream);\n            }\n          }\n\n          function emitReadable_(stream) {\n            var state = stream._readableState;\n            debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n            if (!state.destroyed && (state.length || state.ended)) {\n              stream.emit('readable');\n              state.emittedReadable = false;\n            } // The stream needs another readable event if\n            // 1. It is not flowing, as the flow mechanism will take\n            //    care of it.\n            // 2. It is not ended.\n            // 3. It is below the highWaterMark, so we can schedule\n            //    another readable later.\n\n\n            state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n            flow(stream);\n          } // at this point, the user has presumably seen the 'readable' event,\n          // and called read() to consume some data.  that may have triggered\n          // in turn another _read(n) call, in which case reading = true if\n          // it's in progress.\n          // However, if we're not ended, or reading, and the length < hwm,\n          // then go ahead and try to read some more preemptively.\n\n\n          function maybeReadMore(stream, state) {\n            if (!state.readingMore) {\n              state.readingMore = true;\n              process.nextTick(maybeReadMore_, stream, state);\n            }\n          }\n\n          function maybeReadMore_(stream, state) {\n            // Attempt to read more data if we should.\n            //\n            // The conditions for reading more data are (one of):\n            // - Not enough data buffered (state.length < state.highWaterMark). The loop\n            //   is responsible for filling the buffer with enough data if such data\n            //   is available. If highWaterMark is 0 and we are not in the flowing mode\n            //   we should _not_ attempt to buffer any extra data. We'll get more data\n            //   when the stream consumer calls read() instead.\n            // - No data in the buffer, and the stream is in flowing mode. In this mode\n            //   the loop below is responsible for ensuring read() is called. Failing to\n            //   call read here would abort the flow and there's no other mechanism for\n            //   continuing the flow if the stream consumer has just subscribed to the\n            //   'data' event.\n            //\n            // In addition to the above conditions to keep reading data, the following\n            // conditions prevent the data from being read:\n            // - The stream has ended (state.ended).\n            // - There is already a pending 'read' operation (state.reading). This is a\n            //   case where the the stream has called the implementation defined _read()\n            //   method, but they are processing the call asynchronously and have _not_\n            //   called push() with new data. In this case we skip performing more\n            //   read()s. The execution ends in this method again after the _read() ends\n            //   up calling push() with more data.\n            while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n              var len = state.length;\n              debug('maybeReadMore read 0');\n              stream.read(0);\n              if (len === state.length) // didn't get any data, stop spinning.\n                break;\n            }\n\n            state.readingMore = false;\n          } // abstract method.  to be overridden in specific implementation classes.\n          // call cb(er, data) where data is <= n in length.\n          // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n          // arbitrary, and perhaps not very meaningful.\n\n\n          Readable.prototype._read = function (n) {\n            errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n          };\n\n          Readable.prototype.pipe = function (dest, pipeOpts) {\n            var src = this;\n            var state = this._readableState;\n\n            switch (state.pipesCount) {\n              case 0:\n                state.pipes = dest;\n                break;\n\n              case 1:\n                state.pipes = [state.pipes, dest];\n                break;\n\n              default:\n                state.pipes.push(dest);\n                break;\n            }\n\n            state.pipesCount += 1;\n            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n            var endFn = doEnd ? onend : unpipe;\n            if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n            dest.on('unpipe', onunpipe);\n\n            function onunpipe(readable, unpipeInfo) {\n              debug('onunpipe');\n\n              if (readable === src) {\n                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                  unpipeInfo.hasUnpiped = true;\n                  cleanup();\n                }\n              }\n            }\n\n            function onend() {\n              debug('onend');\n              dest.end();\n            } // when the dest drains, it reduces the awaitDrain counter\n            // on the source.  This would be more elegant with a .once()\n            // handler in flow(), but adding and removing repeatedly is\n            // too slow.\n\n\n            var ondrain = pipeOnDrain(src);\n            dest.on('drain', ondrain);\n            var cleanedUp = false;\n\n            function cleanup() {\n              debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n              dest.removeListener('close', onclose);\n              dest.removeListener('finish', onfinish);\n              dest.removeListener('drain', ondrain);\n              dest.removeListener('error', onerror);\n              dest.removeListener('unpipe', onunpipe);\n              src.removeListener('end', onend);\n              src.removeListener('end', unpipe);\n              src.removeListener('data', ondata);\n              cleanedUp = true; // if the reader is waiting for a drain event from this\n              // specific writer, then it would cause it to never start\n              // flowing again.\n              // So, if this is awaiting a drain, then we just call it now.\n              // If we don't know, then assume that we are waiting for one.\n\n              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n            }\n\n            src.on('data', ondata);\n\n            function ondata(chunk) {\n              debug('ondata');\n              var ret = dest.write(chunk);\n              debug('dest.write', ret);\n\n              if (ret === false) {\n                // If the user unpiped during `dest.write()`, it is possible\n                // to get stuck in a permanently paused state if that write\n                // also returned false.\n                // => Check whether `dest` is still a piping destination.\n                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n                  debug('false write response, pause', state.awaitDrain);\n                  state.awaitDrain++;\n                }\n\n                src.pause();\n              }\n            } // if the dest has an error, then stop piping into it.\n            // however, don't suppress the throwing behavior for this.\n\n\n            function onerror(er) {\n              debug('onerror', er);\n              unpipe();\n              dest.removeListener('error', onerror);\n              if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n            } // Make sure our error handler is attached before userland ones.\n\n\n            prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n            function onclose() {\n              dest.removeListener('finish', onfinish);\n              unpipe();\n            }\n\n            dest.once('close', onclose);\n\n            function onfinish() {\n              debug('onfinish');\n              dest.removeListener('close', onclose);\n              unpipe();\n            }\n\n            dest.once('finish', onfinish);\n\n            function unpipe() {\n              debug('unpipe');\n              src.unpipe(dest);\n            } // tell the dest that it's being piped to\n\n\n            dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n            if (!state.flowing) {\n              debug('pipe resume');\n              src.resume();\n            }\n\n            return dest;\n          };\n\n          function pipeOnDrain(src) {\n            return function pipeOnDrainFunctionResult() {\n              var state = src._readableState;\n              debug('pipeOnDrain', state.awaitDrain);\n              if (state.awaitDrain) state.awaitDrain--;\n\n              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n                state.flowing = true;\n                flow(src);\n              }\n            };\n          }\n\n          Readable.prototype.unpipe = function (dest) {\n            var state = this._readableState;\n            var unpipeInfo = {\n              hasUnpiped: false\n            }; // if we're not piping anywhere, then do nothing.\n\n            if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n            if (state.pipesCount === 1) {\n              // passed in one, but it's not the right one.\n              if (dest && dest !== state.pipes) return this;\n              if (!dest) dest = state.pipes; // got a match.\n\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n              if (dest) dest.emit('unpipe', this, unpipeInfo);\n              return this;\n            } // slow case. multiple pipe destinations.\n\n\n            if (!dest) {\n              // remove all.\n              var dests = state.pipes;\n              var len = state.pipesCount;\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n\n              for (var i = 0; i < len; i++) {\n                dests[i].emit('unpipe', this, {\n                  hasUnpiped: false\n                });\n              }\n\n              return this;\n            } // try to find the right one.\n\n\n            var index = indexOf(state.pipes, dest);\n            if (index === -1) return this;\n            state.pipes.splice(index, 1);\n            state.pipesCount -= 1;\n            if (state.pipesCount === 1) state.pipes = state.pipes[0];\n            dest.emit('unpipe', this, unpipeInfo);\n            return this;\n          }; // set up data events if they are asked for\n          // Ensure readable listeners eventually get something\n\n\n          Readable.prototype.on = function (ev, fn) {\n            var res = Stream.prototype.on.call(this, ev, fn);\n            var state = this._readableState;\n\n            if (ev === 'data') {\n              // update readableListening so that resume() may be a no-op\n              // a few lines down. This is needed to support once('readable').\n              state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n              if (state.flowing !== false) this.resume();\n            } else if (ev === 'readable') {\n              if (!state.endEmitted && !state.readableListening) {\n                state.readableListening = state.needReadable = true;\n                state.flowing = false;\n                state.emittedReadable = false;\n                debug('on readable', state.length, state.reading);\n\n                if (state.length) {\n                  emitReadable(this);\n                } else if (!state.reading) {\n                  process.nextTick(nReadingNextTick, this);\n                }\n              }\n            }\n\n            return res;\n          };\n\n          Readable.prototype.addListener = Readable.prototype.on;\n\n          Readable.prototype.removeListener = function (ev, fn) {\n            var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n            if (ev === 'readable') {\n              // We need to check if there is someone still listening to\n              // readable and reset the state. However this needs to happen\n              // after readable has been emitted but before I/O (nextTick) to\n              // support once('readable', fn) cycles. This means that calling\n              // resume within the same tick will have no\n              // effect.\n              process.nextTick(updateReadableListening, this);\n            }\n\n            return res;\n          };\n\n          Readable.prototype.removeAllListeners = function (ev) {\n            var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n            if (ev === 'readable' || ev === undefined) {\n              // We need to check if there is someone still listening to\n              // readable and reset the state. However this needs to happen\n              // after readable has been emitted but before I/O (nextTick) to\n              // support once('readable', fn) cycles. This means that calling\n              // resume within the same tick will have no\n              // effect.\n              process.nextTick(updateReadableListening, this);\n            }\n\n            return res;\n          };\n\n          function updateReadableListening(self) {\n            var state = self._readableState;\n            state.readableListening = self.listenerCount('readable') > 0;\n\n            if (state.resumeScheduled && !state.paused) {\n              // flowing needs to be set to true now, otherwise\n              // the upcoming resume will not flow.\n              state.flowing = true; // crude way to check if we should resume\n            } else if (self.listenerCount('data') > 0) {\n              self.resume();\n            }\n          }\n\n          function nReadingNextTick(self) {\n            debug('readable nexttick read 0');\n            self.read(0);\n          } // pause() and resume() are remnants of the legacy readable stream API\n          // If the user uses them, then switch into old mode.\n\n\n          Readable.prototype.resume = function () {\n            var state = this._readableState;\n\n            if (!state.flowing) {\n              debug('resume'); // we flow only if there is no one listening\n              // for readable, but we still have to call\n              // resume()\n\n              state.flowing = !state.readableListening;\n              resume(this, state);\n            }\n\n            state.paused = false;\n            return this;\n          };\n\n          function resume(stream, state) {\n            if (!state.resumeScheduled) {\n              state.resumeScheduled = true;\n              process.nextTick(resume_, stream, state);\n            }\n          }\n\n          function resume_(stream, state) {\n            debug('resume', state.reading);\n\n            if (!state.reading) {\n              stream.read(0);\n            }\n\n            state.resumeScheduled = false;\n            stream.emit('resume');\n            flow(stream);\n            if (state.flowing && !state.reading) stream.read(0);\n          }\n\n          Readable.prototype.pause = function () {\n            debug('call pause flowing=%j', this._readableState.flowing);\n\n            if (this._readableState.flowing !== false) {\n              debug('pause');\n              this._readableState.flowing = false;\n              this.emit('pause');\n            }\n\n            this._readableState.paused = true;\n            return this;\n          };\n\n          function flow(stream) {\n            var state = stream._readableState;\n            debug('flow', state.flowing);\n\n            while (state.flowing && stream.read() !== null) {\n              ;\n            }\n          } // wrap an old-style stream as the async data source.\n          // This is *not* part of the readable stream interface.\n          // It is an ugly unfortunate mess of history.\n\n\n          Readable.prototype.wrap = function (stream) {\n            var _this = this;\n\n            var state = this._readableState;\n            var paused = false;\n            stream.on('end', function () {\n              debug('wrapped end');\n\n              if (state.decoder && !state.ended) {\n                var chunk = state.decoder.end();\n                if (chunk && chunk.length) _this.push(chunk);\n              }\n\n              _this.push(null);\n            });\n            stream.on('data', function (chunk) {\n              debug('wrapped data');\n              if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n              if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n              var ret = _this.push(chunk);\n\n              if (!ret) {\n                paused = true;\n                stream.pause();\n              }\n            }); // proxy all the other methods.\n            // important when wrapping filters and duplexes.\n\n            for (var i in stream) {\n              if (this[i] === undefined && typeof stream[i] === 'function') {\n                this[i] = function methodWrap(method) {\n                  return function methodWrapReturnFunction() {\n                    return stream[method].apply(stream, arguments);\n                  };\n                }(i);\n              }\n            } // proxy certain important events.\n\n\n            for (var n = 0; n < kProxyEvents.length; n++) {\n              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n            } // when we try to consume some more bytes, simply unpause the\n            // underlying stream.\n\n\n            this._read = function (n) {\n              debug('wrapped _read', n);\n\n              if (paused) {\n                paused = false;\n                stream.resume();\n              }\n            };\n\n            return this;\n          };\n\n          if (typeof Symbol === 'function') {\n            Readable.prototype[Symbol.asyncIterator] = function () {\n              if (createReadableStreamAsyncIterator === undefined) {\n                createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n              }\n\n              return createReadableStreamAsyncIterator(this);\n            };\n          }\n\n          Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState.highWaterMark;\n            }\n          });\n          Object.defineProperty(Readable.prototype, 'readableBuffer', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState && this._readableState.buffer;\n            }\n          });\n          Object.defineProperty(Readable.prototype, 'readableFlowing', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState.flowing;\n            },\n            set: function set(state) {\n              if (this._readableState) {\n                this._readableState.flowing = state;\n              }\n            }\n          }); // exposed for testing purposes only.\n\n          Readable._fromList = fromList;\n          Object.defineProperty(Readable.prototype, 'readableLength', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState.length;\n            }\n          }); // Pluck off n bytes from an array of buffers.\n          // Length is the combined lengths of all the buffers in the list.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n          function fromList(n, state) {\n            // nothing buffered\n            if (state.length === 0) return null;\n            var ret;\n            if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n              // read it all, truncate the list\n              if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n              state.buffer.clear();\n            } else {\n              // read part of list\n              ret = state.buffer.consume(n, state.decoder);\n            }\n            return ret;\n          }\n\n          function endReadable(stream) {\n            var state = stream._readableState;\n            debug('endReadable', state.endEmitted);\n\n            if (!state.endEmitted) {\n              state.ended = true;\n              process.nextTick(endReadableNT, state, stream);\n            }\n          }\n\n          function endReadableNT(state, stream) {\n            debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n            if (!state.endEmitted && state.length === 0) {\n              state.endEmitted = true;\n              stream.readable = false;\n              stream.emit('end');\n\n              if (state.autoDestroy) {\n                // In case of duplex streams we need a way to detect\n                // if the writable side is ready for autoDestroy as well\n                var wState = stream._writableState;\n\n                if (!wState || wState.autoDestroy && wState.finished) {\n                  stream.destroy();\n                }\n              }\n            }\n          }\n\n          if (typeof Symbol === 'function') {\n            Readable.from = function (iterable, opts) {\n              if (from === undefined) {\n                from = require('./internal/streams/from');\n              }\n\n              return from(Readable, iterable, opts);\n            };\n          }\n\n          function indexOf(xs, x) {\n            for (var i = 0, l = xs.length; i < l; i++) {\n              if (xs[i] === x) return i;\n            }\n\n            return -1;\n          }\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../errors\": 46,\n      \"./_stream_duplex\": 47,\n      \"./internal/streams/async_iterator\": 52,\n      \"./internal/streams/buffer_list\": 53,\n      \"./internal/streams/destroy\": 54,\n      \"./internal/streams/from\": 56,\n      \"./internal/streams/state\": 58,\n      \"./internal/streams/stream\": 59,\n      \"_process\": 69,\n      \"buffer\": 3,\n      \"events\": 4,\n      \"inherits\": 34,\n      \"string_decoder/\": 64,\n      \"util\": 2\n    }],\n    50: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      // a transform stream is a readable/writable stream where you do\n      // something with the data.  Sometimes it's called a \"filter\",\n      // but that's not a great name for it, since that implies a thing where\n      // some bits pass through, and others are simply ignored.  (That would\n      // be a valid example of a transform, of course.)\n      //\n      // While the output is causally related to the input, it's not a\n      // necessarily symmetric or synchronous transformation.  For example,\n      // a zlib stream might take multiple plain-text writes(), and then\n      // emit a single compressed chunk some time in the future.\n      //\n      // Here's how this works:\n      //\n      // The Transform stream has all the aspects of the readable and writable\n      // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n      // internally, and returns false if there's a lot of pending writes\n      // buffered up.  When you call read(), that calls _read(n) until\n      // there's enough pending readable data buffered up.\n      //\n      // In a transform stream, the written data is placed in a buffer.  When\n      // _read(n) is called, it transforms the queued up data, calling the\n      // buffered _write cb's as it consumes chunks.  If consuming a single\n      // written chunk would result in multiple output chunks, then the first\n      // outputted bit calls the readcb, and subsequent chunks just go into\n      // the read buffer, and will cause it to emit 'readable' if necessary.\n      //\n      // This way, back-pressure is actually determined by the reading side,\n      // since _read has to be called to start processing a new chunk.  However,\n      // a pathological inflate type of transform can cause excessive buffering\n      // here.  For example, imagine a stream where every byte of input is\n      // interpreted as an integer from 0-255, and then results in that many\n      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n      // 1kb of data being output.  In this case, you could write a very small\n      // amount of input, and end up with a very large amount of output.  In\n      // such a pathological inflating mechanism, there'd be no way to tell\n      // the system to stop doing the transform.  A single 4MB write could\n      // cause the system to run out of memory.\n      //\n      // However, even in such a pathological case, only a single written chunk\n      // would be consumed, and then the rest would wait (un-transformed) until\n      // the results of the previous transformed chunk were consumed.\n      'use strict';\n\n      module.exports = Transform;\n\n      var _require$codes = require('../errors').codes,\n          ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n          ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n          ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n          ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\n      var Duplex = require('./_stream_duplex');\n\n      require('inherits')(Transform, Duplex);\n\n      function afterTransform(er, data) {\n        var ts = this._transformState;\n        ts.transforming = false;\n        var cb = ts.writecb;\n\n        if (cb === null) {\n          return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n        }\n\n        ts.writechunk = null;\n        ts.writecb = null;\n        if (data != null) // single equals check for both `null` and `undefined`\n          this.push(data);\n        cb(er);\n        var rs = this._readableState;\n        rs.reading = false;\n\n        if (rs.needReadable || rs.length < rs.highWaterMark) {\n          this._read(rs.highWaterMark);\n        }\n      }\n\n      function Transform(options) {\n        if (!(this instanceof Transform)) return new Transform(options);\n        Duplex.call(this, options);\n        this._transformState = {\n          afterTransform: afterTransform.bind(this),\n          needTransform: false,\n          transforming: false,\n          writecb: null,\n          writechunk: null,\n          writeencoding: null\n        }; // start out asking for a readable event once data is transformed.\n\n        this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n        // that Readable wants before the first _read call, so unset the\n        // sync guard flag.\n\n        this._readableState.sync = false;\n\n        if (options) {\n          if (typeof options.transform === 'function') this._transform = options.transform;\n          if (typeof options.flush === 'function') this._flush = options.flush;\n        } // When the writable side finishes, then flush out anything remaining.\n\n\n        this.on('prefinish', prefinish);\n      }\n\n      function prefinish() {\n        var _this = this;\n\n        if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n          this._flush(function (er, data) {\n            done(_this, er, data);\n          });\n        } else {\n          done(this, null, null);\n        }\n      }\n\n      Transform.prototype.push = function (chunk, encoding) {\n        this._transformState.needTransform = false;\n        return Duplex.prototype.push.call(this, chunk, encoding);\n      }; // This is the part where you do stuff!\n      // override this function in implementation classes.\n      // 'chunk' is an input chunk.\n      //\n      // Call `push(newChunk)` to pass along transformed output\n      // to the readable side.  You may call 'push' zero or more times.\n      //\n      // Call `cb(err)` when you are done with this chunk.  If you pass\n      // an error, then that'll put the hurt on the whole operation.  If you\n      // never call cb(), then you'll never get another chunk.\n\n\n      Transform.prototype._transform = function (chunk, encoding, cb) {\n        cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n      };\n\n      Transform.prototype._write = function (chunk, encoding, cb) {\n        var ts = this._transformState;\n        ts.writecb = cb;\n        ts.writechunk = chunk;\n        ts.writeencoding = encoding;\n\n        if (!ts.transforming) {\n          var rs = this._readableState;\n          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n        }\n      }; // Doesn't matter what the args are here.\n      // _transform does all the work.\n      // That we got here means that the readable side wants more data.\n\n\n      Transform.prototype._read = function (n) {\n        var ts = this._transformState;\n\n        if (ts.writechunk !== null && !ts.transforming) {\n          ts.transforming = true;\n\n          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n        } else {\n          // mark that we need a transform, so that any data that comes in\n          // will get processed, now that we've asked for it.\n          ts.needTransform = true;\n        }\n      };\n\n      Transform.prototype._destroy = function (err, cb) {\n        Duplex.prototype._destroy.call(this, err, function (err2) {\n          cb(err2);\n        });\n      };\n\n      function done(stream, er, data) {\n        if (er) return stream.emit('error', er);\n        if (data != null) // single equals check for both `null` and `undefined`\n          stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n        // if there's nothing in the write buffer, then that means\n        // that nothing more will ever be provided\n\n        if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n        if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n        return stream.push(null);\n      }\n    }, {\n      \"../errors\": 46,\n      \"./_stream_duplex\": 47,\n      \"inherits\": 34\n    }],\n    51: [function (require, module, exports) {\n      (function (process, global) {\n        (function () {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // A bit simpler than readable streams.\n          // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n          // the drain event emission and buffering.\n          'use strict';\n\n          module.exports = Writable;\n          /* <replacement> */\n\n          function WriteReq(chunk, encoding, cb) {\n            this.chunk = chunk;\n            this.encoding = encoding;\n            this.callback = cb;\n            this.next = null;\n          } // It seems a linked list but it is not\n          // there will be only 2 of these for each stream\n\n\n          function CorkedRequest(state) {\n            var _this = this;\n\n            this.next = null;\n            this.entry = null;\n\n            this.finish = function () {\n              onCorkedFinish(_this, state);\n            };\n          }\n          /* </replacement> */\n\n          /*<replacement>*/\n\n\n          var Duplex;\n          /*</replacement>*/\n\n          Writable.WritableState = WritableState;\n          /*<replacement>*/\n\n          var internalUtil = {\n            deprecate: require('util-deprecate')\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var Stream = require('./internal/streams/stream');\n          /*</replacement>*/\n\n\n          var Buffer = require('buffer').Buffer;\n\n          var OurUint8Array = global.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n\n          var destroyImpl = require('./internal/streams/destroy');\n\n          var _require = require('./internal/streams/state'),\n              getHighWaterMark = _require.getHighWaterMark;\n\n          var _require$codes = require('../errors').codes,\n              ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n              ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n              ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n              ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n              ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n              ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n              ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n              ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\n          var errorOrDestroy = destroyImpl.errorOrDestroy;\n\n          require('inherits')(Writable, Stream);\n\n          function nop() {}\n\n          function WritableState(options, stream, isDuplex) {\n            Duplex = Duplex || require('./_stream_duplex');\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream,\n            // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n            // contains buffers or objects.\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n            // Note: 0 is a valid value, means that we always return false if\n            // the entire buffer is not flushed immediately on write()\n\n            this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n            this.finalCalled = false; // drain event flag.\n\n            this.needDrain = false; // at the start of calling end()\n\n            this.ending = false; // when end() has been called, and returned\n\n            this.ended = false; // when 'finish' is emitted\n\n            this.finished = false; // has it been destroyed\n\n            this.destroyed = false; // should we decode strings into buffers before passing to _write?\n            // this is here so that some node-core streams can optimize string\n            // handling at a lower level.\n\n            var noDecode = options.decodeStrings === false;\n            this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n            // of how much we're waiting to get pushed to some underlying\n            // socket or file.\n\n            this.length = 0; // a flag to see when we're in the middle of a write.\n\n            this.writing = false; // when true all writes will be buffered until .uncork() call\n\n            this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n            // or on a later tick.  We set this to true at first, because any\n            // actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first write call.\n\n            this.sync = true; // a flag to know if we're processing previously buffered items, which\n            // may call the _write() callback in the same tick, so that we don't\n            // end up in an overlapped onwrite situation.\n\n            this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n            this.onwrite = function (er) {\n              onwrite(stream, er);\n            }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n            this.writecb = null; // the amount that is being written when _write is called.\n\n            this.writelen = 0;\n            this.bufferedRequest = null;\n            this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n            // this must be 0 before 'finish' can be emitted\n\n            this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n            // This is relevant for synchronous Transform streams\n\n            this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n            this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n            this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n            this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n            // one allocated and free to use, and we maintain at most two\n\n            this.corkedRequestsFree = new CorkedRequest(this);\n          }\n\n          WritableState.prototype.getBuffer = function getBuffer() {\n            var current = this.bufferedRequest;\n            var out = [];\n\n            while (current) {\n              out.push(current);\n              current = current.next;\n            }\n\n            return out;\n          };\n\n          (function () {\n            try {\n              Object.defineProperty(WritableState.prototype, 'buffer', {\n                get: internalUtil.deprecate(function writableStateBufferGetter() {\n                  return this.getBuffer();\n                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n              });\n            } catch (_) {}\n          })(); // Test _writableState for inheritance to account for Duplex streams,\n          // whose prototype chain only points to Readable.\n\n\n          var realHasInstance;\n\n          if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n            realHasInstance = Function.prototype[Symbol.hasInstance];\n            Object.defineProperty(Writable, Symbol.hasInstance, {\n              value: function value(object) {\n                if (realHasInstance.call(this, object)) return true;\n                if (this !== Writable) return false;\n                return object && object._writableState instanceof WritableState;\n              }\n            });\n          } else {\n            realHasInstance = function realHasInstance(object) {\n              return object instanceof this;\n            };\n          }\n\n          function Writable(options) {\n            Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n            // `realHasInstance` is necessary because using plain `instanceof`\n            // would return false, as no `_writableState` property is attached.\n            // Trying to use the custom `instanceof` for Writable here will also break the\n            // Node.js LazyTransform implementation, which has a non-trivial getter for\n            // `_writableState` that would lead to infinite recursion.\n            // Checking for a Stream.Duplex instance is faster here instead of inside\n            // the WritableState constructor, at least with V8 6.5\n\n            var isDuplex = this instanceof Duplex;\n            if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n            this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n            this.writable = true;\n\n            if (options) {\n              if (typeof options.write === 'function') this._write = options.write;\n              if (typeof options.writev === 'function') this._writev = options.writev;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n              if (typeof options.final === 'function') this._final = options.final;\n            }\n\n            Stream.call(this);\n          } // Otherwise people can pipe Writable streams, which is just wrong.\n\n\n          Writable.prototype.pipe = function () {\n            errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n          };\n\n          function writeAfterEnd(stream, cb) {\n            var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n            errorOrDestroy(stream, er);\n            process.nextTick(cb, er);\n          } // Checks that a user-supplied chunk is valid, especially for the particular\n          // mode the stream is in. Currently this means that `null` is never accepted\n          // and undefined/non-string values are only allowed in object mode.\n\n\n          function validChunk(stream, state, chunk, cb) {\n            var er;\n\n            if (chunk === null) {\n              er = new ERR_STREAM_NULL_VALUES();\n            } else if (typeof chunk !== 'string' && !state.objectMode) {\n              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n            }\n\n            if (er) {\n              errorOrDestroy(stream, er);\n              process.nextTick(cb, er);\n              return false;\n            }\n\n            return true;\n          }\n\n          Writable.prototype.write = function (chunk, encoding, cb) {\n            var state = this._writableState;\n            var ret = false;\n\n            var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n            if (isBuf && !Buffer.isBuffer(chunk)) {\n              chunk = _uint8ArrayToBuffer(chunk);\n            }\n\n            if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n            if (typeof cb !== 'function') cb = nop;\n            if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n              state.pendingcb++;\n              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n            }\n            return ret;\n          };\n\n          Writable.prototype.cork = function () {\n            this._writableState.corked++;\n          };\n\n          Writable.prototype.uncork = function () {\n            var state = this._writableState;\n\n            if (state.corked) {\n              state.corked--;\n              if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n            }\n          };\n\n          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n            // node::ParseEncoding() requires lower case.\n            if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n            if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n            this._writableState.defaultEncoding = encoding;\n            return this;\n          };\n\n          Object.defineProperty(Writable.prototype, 'writableBuffer', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState && this._writableState.getBuffer();\n            }\n          });\n\n          function decodeChunk(state, chunk, encoding) {\n            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, encoding);\n            }\n\n            return chunk;\n          }\n\n          Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.highWaterMark;\n            }\n          }); // if we're already writing something, then just put this\n          // in the queue, and wait our turn.  Otherwise, call _write\n          // If we return false, then we need a drain event, so set that flag.\n\n          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n            if (!isBuf) {\n              var newChunk = decodeChunk(state, chunk, encoding);\n\n              if (chunk !== newChunk) {\n                isBuf = true;\n                encoding = 'buffer';\n                chunk = newChunk;\n              }\n            }\n\n            var len = state.objectMode ? 1 : chunk.length;\n            state.length += len;\n            var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n            if (!ret) state.needDrain = true;\n\n            if (state.writing || state.corked) {\n              var last = state.lastBufferedRequest;\n              state.lastBufferedRequest = {\n                chunk: chunk,\n                encoding: encoding,\n                isBuf: isBuf,\n                callback: cb,\n                next: null\n              };\n\n              if (last) {\n                last.next = state.lastBufferedRequest;\n              } else {\n                state.bufferedRequest = state.lastBufferedRequest;\n              }\n\n              state.bufferedRequestCount += 1;\n            } else {\n              doWrite(stream, state, false, len, chunk, encoding, cb);\n            }\n\n            return ret;\n          }\n\n          function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n            state.writelen = len;\n            state.writecb = cb;\n            state.writing = true;\n            state.sync = true;\n            if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n            state.sync = false;\n          }\n\n          function onwriteError(stream, state, sync, er, cb) {\n            --state.pendingcb;\n\n            if (sync) {\n              // defer the callback if we are being called synchronously\n              // to avoid piling up things on the stack\n              process.nextTick(cb, er); // this can emit finish, and it will always happen\n              // after error\n\n              process.nextTick(finishMaybe, stream, state);\n              stream._writableState.errorEmitted = true;\n              errorOrDestroy(stream, er);\n            } else {\n              // the caller expect this to happen before if\n              // it is async\n              cb(er);\n              stream._writableState.errorEmitted = true;\n              errorOrDestroy(stream, er); // this can emit finish, but finish must\n              // always follow error\n\n              finishMaybe(stream, state);\n            }\n          }\n\n          function onwriteStateUpdate(state) {\n            state.writing = false;\n            state.writecb = null;\n            state.length -= state.writelen;\n            state.writelen = 0;\n          }\n\n          function onwrite(stream, er) {\n            var state = stream._writableState;\n            var sync = state.sync;\n            var cb = state.writecb;\n            if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n            onwriteStateUpdate(state);\n            if (er) onwriteError(stream, state, sync, er, cb);else {\n              // Check if we're actually ready to finish, but don't emit yet\n              var finished = needFinish(state) || stream.destroyed;\n\n              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n                clearBuffer(stream, state);\n              }\n\n              if (sync) {\n                process.nextTick(afterWrite, stream, state, finished, cb);\n              } else {\n                afterWrite(stream, state, finished, cb);\n              }\n            }\n          }\n\n          function afterWrite(stream, state, finished, cb) {\n            if (!finished) onwriteDrain(stream, state);\n            state.pendingcb--;\n            cb();\n            finishMaybe(stream, state);\n          } // Must force callback to be called on nextTick, so that we don't\n          // emit 'drain' before the write() consumer gets the 'false' return\n          // value, and has a chance to attach a 'drain' listener.\n\n\n          function onwriteDrain(stream, state) {\n            if (state.length === 0 && state.needDrain) {\n              state.needDrain = false;\n              stream.emit('drain');\n            }\n          } // if there's something in the buffer waiting, then process it\n\n\n          function clearBuffer(stream, state) {\n            state.bufferProcessing = true;\n            var entry = state.bufferedRequest;\n\n            if (stream._writev && entry && entry.next) {\n              // Fast case, write everything using _writev()\n              var l = state.bufferedRequestCount;\n              var buffer = new Array(l);\n              var holder = state.corkedRequestsFree;\n              holder.entry = entry;\n              var count = 0;\n              var allBuffers = true;\n\n              while (entry) {\n                buffer[count] = entry;\n                if (!entry.isBuf) allBuffers = false;\n                entry = entry.next;\n                count += 1;\n              }\n\n              buffer.allBuffers = allBuffers;\n              doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n              // as the hot path ends with doWrite\n\n              state.pendingcb++;\n              state.lastBufferedRequest = null;\n\n              if (holder.next) {\n                state.corkedRequestsFree = holder.next;\n                holder.next = null;\n              } else {\n                state.corkedRequestsFree = new CorkedRequest(state);\n              }\n\n              state.bufferedRequestCount = 0;\n            } else {\n              // Slow case, write chunks one-by-one\n              while (entry) {\n                var chunk = entry.chunk;\n                var encoding = entry.encoding;\n                var cb = entry.callback;\n                var len = state.objectMode ? 1 : chunk.length;\n                doWrite(stream, state, false, len, chunk, encoding, cb);\n                entry = entry.next;\n                state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n                // it means that we need to wait until it does.\n                // also, that means that the chunk and cb are currently\n                // being processed, so move the buffer counter past them.\n\n                if (state.writing) {\n                  break;\n                }\n              }\n\n              if (entry === null) state.lastBufferedRequest = null;\n            }\n\n            state.bufferedRequest = entry;\n            state.bufferProcessing = false;\n          }\n\n          Writable.prototype._write = function (chunk, encoding, cb) {\n            cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n          };\n\n          Writable.prototype._writev = null;\n\n          Writable.prototype.end = function (chunk, encoding, cb) {\n            var state = this._writableState;\n\n            if (typeof chunk === 'function') {\n              cb = chunk;\n              chunk = null;\n              encoding = null;\n            } else if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n            if (state.corked) {\n              state.corked = 1;\n              this.uncork();\n            } // ignore unnecessary end() calls.\n\n\n            if (!state.ending) endWritable(this, state, cb);\n            return this;\n          };\n\n          Object.defineProperty(Writable.prototype, 'writableLength', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.length;\n            }\n          });\n\n          function needFinish(state) {\n            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n          }\n\n          function callFinal(stream, state) {\n            stream._final(function (err) {\n              state.pendingcb--;\n\n              if (err) {\n                errorOrDestroy(stream, err);\n              }\n\n              state.prefinished = true;\n              stream.emit('prefinish');\n              finishMaybe(stream, state);\n            });\n          }\n\n          function prefinish(stream, state) {\n            if (!state.prefinished && !state.finalCalled) {\n              if (typeof stream._final === 'function' && !state.destroyed) {\n                state.pendingcb++;\n                state.finalCalled = true;\n                process.nextTick(callFinal, stream, state);\n              } else {\n                state.prefinished = true;\n                stream.emit('prefinish');\n              }\n            }\n          }\n\n          function finishMaybe(stream, state) {\n            var need = needFinish(state);\n\n            if (need) {\n              prefinish(stream, state);\n\n              if (state.pendingcb === 0) {\n                state.finished = true;\n                stream.emit('finish');\n\n                if (state.autoDestroy) {\n                  // In case of duplex streams we need a way to detect\n                  // if the readable side is ready for autoDestroy as well\n                  var rState = stream._readableState;\n\n                  if (!rState || rState.autoDestroy && rState.endEmitted) {\n                    stream.destroy();\n                  }\n                }\n              }\n            }\n\n            return need;\n          }\n\n          function endWritable(stream, state, cb) {\n            state.ending = true;\n            finishMaybe(stream, state);\n\n            if (cb) {\n              if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n            }\n\n            state.ended = true;\n            stream.writable = false;\n          }\n\n          function onCorkedFinish(corkReq, state, err) {\n            var entry = corkReq.entry;\n            corkReq.entry = null;\n\n            while (entry) {\n              var cb = entry.callback;\n              state.pendingcb--;\n              cb(err);\n              entry = entry.next;\n            } // reuse the free corkReq.\n\n\n            state.corkedRequestsFree.next = corkReq;\n          }\n\n          Object.defineProperty(Writable.prototype, 'destroyed', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              if (this._writableState === undefined) {\n                return false;\n              }\n\n              return this._writableState.destroyed;\n            },\n            set: function set(value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._writableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._writableState.destroyed = value;\n            }\n          });\n          Writable.prototype.destroy = destroyImpl.destroy;\n          Writable.prototype._undestroy = destroyImpl.undestroy;\n\n          Writable.prototype._destroy = function (err, cb) {\n            cb(err);\n          };\n        }).call(this);\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"../errors\": 46,\n      \"./_stream_duplex\": 47,\n      \"./internal/streams/destroy\": 54,\n      \"./internal/streams/state\": 58,\n      \"./internal/streams/stream\": 59,\n      \"_process\": 69,\n      \"buffer\": 3,\n      \"inherits\": 34,\n      \"util-deprecate\": 65\n    }],\n    52: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          var _Object$setPrototypeO;\n\n          function _defineProperty(obj, key, value) {\n            if (key in obj) {\n              Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n              });\n            } else {\n              obj[key] = value;\n            }\n\n            return obj;\n          }\n\n          var finished = require('./end-of-stream');\n\n          var kLastResolve = Symbol('lastResolve');\n          var kLastReject = Symbol('lastReject');\n          var kError = Symbol('error');\n          var kEnded = Symbol('ended');\n          var kLastPromise = Symbol('lastPromise');\n          var kHandlePromise = Symbol('handlePromise');\n          var kStream = Symbol('stream');\n\n          function createIterResult(value, done) {\n            return {\n              value: value,\n              done: done\n            };\n          }\n\n          function readAndResolve(iter) {\n            var resolve = iter[kLastResolve];\n\n            if (resolve !== null) {\n              var data = iter[kStream].read(); // we defer if data is null\n              // we can be expecting either 'end' or\n              // 'error'\n\n              if (data !== null) {\n                iter[kLastPromise] = null;\n                iter[kLastResolve] = null;\n                iter[kLastReject] = null;\n                resolve(createIterResult(data, false));\n              }\n            }\n          }\n\n          function onReadable(iter) {\n            // we wait for the next tick, because it might\n            // emit an error with process.nextTick\n            process.nextTick(readAndResolve, iter);\n          }\n\n          function wrapForNext(lastPromise, iter) {\n            return function (resolve, reject) {\n              lastPromise.then(function () {\n                if (iter[kEnded]) {\n                  resolve(createIterResult(undefined, true));\n                  return;\n                }\n\n                iter[kHandlePromise](resolve, reject);\n              }, reject);\n            };\n          }\n\n          var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\n          var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n            get stream() {\n              return this[kStream];\n            },\n\n            next: function next() {\n              var _this = this; // if we have detected an error in the meanwhile\n              // reject straight away\n\n\n              var error = this[kError];\n\n              if (error !== null) {\n                return Promise.reject(error);\n              }\n\n              if (this[kEnded]) {\n                return Promise.resolve(createIterResult(undefined, true));\n              }\n\n              if (this[kStream].destroyed) {\n                // We need to defer via nextTick because if .destroy(err) is\n                // called, the error will be emitted via nextTick, and\n                // we cannot guarantee that there is no error lingering around\n                // waiting to be emitted.\n                return new Promise(function (resolve, reject) {\n                  process.nextTick(function () {\n                    if (_this[kError]) {\n                      reject(_this[kError]);\n                    } else {\n                      resolve(createIterResult(undefined, true));\n                    }\n                  });\n                });\n              } // if we have multiple next() calls\n              // we will wait for the previous Promise to finish\n              // this logic is optimized to support for await loops,\n              // where next() is only called once at a time\n\n\n              var lastPromise = this[kLastPromise];\n              var promise;\n\n              if (lastPromise) {\n                promise = new Promise(wrapForNext(lastPromise, this));\n              } else {\n                // fast path needed to support multiple this.push()\n                // without triggering the next() queue\n                var data = this[kStream].read();\n\n                if (data !== null) {\n                  return Promise.resolve(createIterResult(data, false));\n                }\n\n                promise = new Promise(this[kHandlePromise]);\n              }\n\n              this[kLastPromise] = promise;\n              return promise;\n            }\n          }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n            return this;\n          }), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n            var _this2 = this; // destroy(err, cb) is a private API\n            // we can guarantee we have that here, because we control the\n            // Readable class this is attached to\n\n\n            return new Promise(function (resolve, reject) {\n              _this2[kStream].destroy(null, function (err) {\n                if (err) {\n                  reject(err);\n                  return;\n                }\n\n                resolve(createIterResult(undefined, true));\n              });\n            });\n          }), _Object$setPrototypeO), AsyncIteratorPrototype);\n\n          var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n            var _Object$create;\n\n            var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n              value: stream,\n              writable: true\n            }), _defineProperty(_Object$create, kLastResolve, {\n              value: null,\n              writable: true\n            }), _defineProperty(_Object$create, kLastReject, {\n              value: null,\n              writable: true\n            }), _defineProperty(_Object$create, kError, {\n              value: null,\n              writable: true\n            }), _defineProperty(_Object$create, kEnded, {\n              value: stream._readableState.endEmitted,\n              writable: true\n            }), _defineProperty(_Object$create, kHandlePromise, {\n              value: function value(resolve, reject) {\n                var data = iterator[kStream].read();\n\n                if (data) {\n                  iterator[kLastPromise] = null;\n                  iterator[kLastResolve] = null;\n                  iterator[kLastReject] = null;\n                  resolve(createIterResult(data, false));\n                } else {\n                  iterator[kLastResolve] = resolve;\n                  iterator[kLastReject] = reject;\n                }\n              },\n              writable: true\n            }), _Object$create));\n            iterator[kLastPromise] = null;\n            finished(stream, function (err) {\n              if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n                var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n                // returned by next() and store the error\n\n                if (reject !== null) {\n                  iterator[kLastPromise] = null;\n                  iterator[kLastResolve] = null;\n                  iterator[kLastReject] = null;\n                  reject(err);\n                }\n\n                iterator[kError] = err;\n                return;\n              }\n\n              var resolve = iterator[kLastResolve];\n\n              if (resolve !== null) {\n                iterator[kLastPromise] = null;\n                iterator[kLastResolve] = null;\n                iterator[kLastReject] = null;\n                resolve(createIterResult(undefined, true));\n              }\n\n              iterator[kEnded] = true;\n            });\n            stream.on('readable', onReadable.bind(null, iterator));\n            return iterator;\n          };\n\n          module.exports = createReadableStreamAsyncIterator;\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"./end-of-stream\": 55,\n      \"_process\": 69\n    }],\n    53: [function (require, module, exports) {\n      'use strict';\n\n      function ownKeys(object, enumerableOnly) {\n        var keys = Object.keys(object);\n\n        if (Object.getOwnPropertySymbols) {\n          var symbols = Object.getOwnPropertySymbols(object);\n          if (enumerableOnly) symbols = symbols.filter(function (sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n          });\n          keys.push.apply(keys, symbols);\n        }\n\n        return keys;\n      }\n\n      function _objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n\n          if (i % 2) {\n            ownKeys(Object(source), true).forEach(function (key) {\n              _defineProperty(target, key, source[key]);\n            });\n          } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n          } else {\n            ownKeys(Object(source)).forEach(function (key) {\n              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n          }\n        }\n\n        return target;\n      }\n\n      function _defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      var _require = require('buffer'),\n          Buffer = _require.Buffer;\n\n      var _require2 = require('util'),\n          inspect = _require2.inspect;\n\n      var custom = inspect && inspect.custom || 'inspect';\n\n      function copyBuffer(src, target, offset) {\n        Buffer.prototype.copy.call(src, target, offset);\n      }\n\n      module.exports = /*#__PURE__*/function () {\n        function BufferList() {\n          _classCallCheck(this, BufferList);\n\n          this.head = null;\n          this.tail = null;\n          this.length = 0;\n        }\n\n        _createClass(BufferList, [{\n          key: \"push\",\n          value: function push(v) {\n            var entry = {\n              data: v,\n              next: null\n            };\n            if (this.length > 0) this.tail.next = entry;else this.head = entry;\n            this.tail = entry;\n            ++this.length;\n          }\n        }, {\n          key: \"unshift\",\n          value: function unshift(v) {\n            var entry = {\n              data: v,\n              next: this.head\n            };\n            if (this.length === 0) this.tail = entry;\n            this.head = entry;\n            ++this.length;\n          }\n        }, {\n          key: \"shift\",\n          value: function shift() {\n            if (this.length === 0) return;\n            var ret = this.head.data;\n            if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n            --this.length;\n            return ret;\n          }\n        }, {\n          key: \"clear\",\n          value: function clear() {\n            this.head = this.tail = null;\n            this.length = 0;\n          }\n        }, {\n          key: \"join\",\n          value: function join(s) {\n            if (this.length === 0) return '';\n            var p = this.head;\n            var ret = '' + p.data;\n\n            while (p = p.next) {\n              ret += s + p.data;\n            }\n\n            return ret;\n          }\n        }, {\n          key: \"concat\",\n          value: function concat(n) {\n            if (this.length === 0) return Buffer.alloc(0);\n            var ret = Buffer.allocUnsafe(n >>> 0);\n            var p = this.head;\n            var i = 0;\n\n            while (p) {\n              copyBuffer(p.data, ret, i);\n              i += p.data.length;\n              p = p.next;\n            }\n\n            return ret;\n          } // Consumes a specified amount of bytes or characters from the buffered data.\n\n        }, {\n          key: \"consume\",\n          value: function consume(n, hasStrings) {\n            var ret;\n\n            if (n < this.head.data.length) {\n              // `slice` is the same for buffers and strings.\n              ret = this.head.data.slice(0, n);\n              this.head.data = this.head.data.slice(n);\n            } else if (n === this.head.data.length) {\n              // First chunk is a perfect match.\n              ret = this.shift();\n            } else {\n              // Result spans more than one buffer.\n              ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n            }\n\n            return ret;\n          }\n        }, {\n          key: \"first\",\n          value: function first() {\n            return this.head.data;\n          } // Consumes a specified amount of characters from the buffered data.\n\n        }, {\n          key: \"_getString\",\n          value: function _getString(n) {\n            var p = this.head;\n            var c = 1;\n            var ret = p.data;\n            n -= ret.length;\n\n            while (p = p.next) {\n              var str = p.data;\n              var nb = n > str.length ? str.length : n;\n              if (nb === str.length) ret += str;else ret += str.slice(0, n);\n              n -= nb;\n\n              if (n === 0) {\n                if (nb === str.length) {\n                  ++c;\n                  if (p.next) this.head = p.next;else this.head = this.tail = null;\n                } else {\n                  this.head = p;\n                  p.data = str.slice(nb);\n                }\n\n                break;\n              }\n\n              ++c;\n            }\n\n            this.length -= c;\n            return ret;\n          } // Consumes a specified amount of bytes from the buffered data.\n\n        }, {\n          key: \"_getBuffer\",\n          value: function _getBuffer(n) {\n            var ret = Buffer.allocUnsafe(n);\n            var p = this.head;\n            var c = 1;\n            p.data.copy(ret);\n            n -= p.data.length;\n\n            while (p = p.next) {\n              var buf = p.data;\n              var nb = n > buf.length ? buf.length : n;\n              buf.copy(ret, ret.length - n, 0, nb);\n              n -= nb;\n\n              if (n === 0) {\n                if (nb === buf.length) {\n                  ++c;\n                  if (p.next) this.head = p.next;else this.head = this.tail = null;\n                } else {\n                  this.head = p;\n                  p.data = buf.slice(nb);\n                }\n\n                break;\n              }\n\n              ++c;\n            }\n\n            this.length -= c;\n            return ret;\n          } // Make sure the linked list only shows the minimal necessary information.\n\n        }, {\n          key: custom,\n          value: function value(_, options) {\n            return inspect(this, _objectSpread({}, options, {\n              // Only inspect one level.\n              depth: 0,\n              // It should not recurse.\n              customInspect: false\n            }));\n          }\n        }]);\n\n        return BufferList;\n      }();\n    }, {\n      \"buffer\": 3,\n      \"util\": 2\n    }],\n    54: [function (require, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict'; // undocumented cb() API, needed for core, not for public API\n\n          function destroy(err, cb) {\n            var _this = this;\n\n            var readableDestroyed = this._readableState && this._readableState.destroyed;\n            var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n            if (readableDestroyed || writableDestroyed) {\n              if (cb) {\n                cb(err);\n              } else if (err) {\n                if (!this._writableState) {\n                  process.nextTick(emitErrorNT, this, err);\n                } else if (!this._writableState.errorEmitted) {\n                  this._writableState.errorEmitted = true;\n                  process.nextTick(emitErrorNT, this, err);\n                }\n              }\n\n              return this;\n            } // we set destroyed to true before firing error callbacks in order\n            // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n            if (this._readableState) {\n              this._readableState.destroyed = true;\n            } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n            if (this._writableState) {\n              this._writableState.destroyed = true;\n            }\n\n            this._destroy(err || null, function (err) {\n              if (!cb && err) {\n                if (!_this._writableState) {\n                  process.nextTick(emitErrorAndCloseNT, _this, err);\n                } else if (!_this._writableState.errorEmitted) {\n                  _this._writableState.errorEmitted = true;\n                  process.nextTick(emitErrorAndCloseNT, _this, err);\n                } else {\n                  process.nextTick(emitCloseNT, _this);\n                }\n              } else if (cb) {\n                process.nextTick(emitCloseNT, _this);\n                cb(err);\n              } else {\n                process.nextTick(emitCloseNT, _this);\n              }\n            });\n\n            return this;\n          }\n\n          function emitErrorAndCloseNT(self, err) {\n            emitErrorNT(self, err);\n            emitCloseNT(self);\n          }\n\n          function emitCloseNT(self) {\n            if (self._writableState && !self._writableState.emitClose) return;\n            if (self._readableState && !self._readableState.emitClose) return;\n            self.emit('close');\n          }\n\n          function undestroy() {\n            if (this._readableState) {\n              this._readableState.destroyed = false;\n              this._readableState.reading = false;\n              this._readableState.ended = false;\n              this._readableState.endEmitted = false;\n            }\n\n            if (this._writableState) {\n              this._writableState.destroyed = false;\n              this._writableState.ended = false;\n              this._writableState.ending = false;\n              this._writableState.finalCalled = false;\n              this._writableState.prefinished = false;\n              this._writableState.finished = false;\n              this._writableState.errorEmitted = false;\n            }\n          }\n\n          function emitErrorNT(self, err) {\n            self.emit('error', err);\n          }\n\n          function errorOrDestroy(stream, err) {\n            // We have tests that rely on errors being emitted\n            // in the same tick, so changing this is semver major.\n            // For now when you opt-in to autoDestroy we allow\n            // the error to be emitted nextTick. In a future\n            // semver major update we should change the default to this.\n            var rState = stream._readableState;\n            var wState = stream._writableState;\n            if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n          }\n\n          module.exports = {\n            destroy: destroy,\n            undestroy: undestroy,\n            errorOrDestroy: errorOrDestroy\n          };\n        }).call(this);\n      }).call(this, require('_process'));\n    }, {\n      \"_process\": 69\n    }],\n    55: [function (require, module, exports) {\n      // Ported from https://github.com/mafintosh/end-of-stream with\n      // permission from the author, Mathias Buus (@mafintosh).\n      'use strict';\n\n      var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\n      function once(callback) {\n        var called = false;\n        return function () {\n          if (called) return;\n          called = true;\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          callback.apply(this, args);\n        };\n      }\n\n      function noop() {}\n\n      function isRequest(stream) {\n        return stream.setHeader && typeof stream.abort === 'function';\n      }\n\n      function eos(stream, opts, callback) {\n        if (typeof opts === 'function') return eos(stream, null, opts);\n        if (!opts) opts = {};\n        callback = once(callback || noop);\n        var readable = opts.readable || opts.readable !== false && stream.readable;\n        var writable = opts.writable || opts.writable !== false && stream.writable;\n\n        var onlegacyfinish = function onlegacyfinish() {\n          if (!stream.writable) onfinish();\n        };\n\n        var writableEnded = stream._writableState && stream._writableState.finished;\n\n        var onfinish = function onfinish() {\n          writable = false;\n          writableEnded = true;\n          if (!readable) callback.call(stream);\n        };\n\n        var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n        var onend = function onend() {\n          readable = false;\n          readableEnded = true;\n          if (!writable) callback.call(stream);\n        };\n\n        var onerror = function onerror(err) {\n          callback.call(stream, err);\n        };\n\n        var onclose = function onclose() {\n          var err;\n\n          if (readable && !readableEnded) {\n            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n            return callback.call(stream, err);\n          }\n\n          if (writable && !writableEnded) {\n            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n            return callback.call(stream, err);\n          }\n        };\n\n        var onrequest = function onrequest() {\n          stream.req.on('finish', onfinish);\n        };\n\n        if (isRequest(stream)) {\n          stream.on('complete', onfinish);\n          stream.on('abort', onclose);\n          if (stream.req) onrequest();else stream.on('request', onrequest);\n        } else if (writable && !stream._writableState) {\n          // legacy streams\n          stream.on('end', onlegacyfinish);\n          stream.on('close', onlegacyfinish);\n        }\n\n        stream.on('end', onend);\n        stream.on('finish', onfinish);\n        if (opts.error !== false) stream.on('error', onerror);\n        stream.on('close', onclose);\n        return function () {\n          stream.removeListener('complete', onfinish);\n          stream.removeListener('abort', onclose);\n          stream.removeListener('request', onrequest);\n          if (stream.req) stream.req.removeListener('finish', onfinish);\n          stream.removeListener('end', onlegacyfinish);\n          stream.removeListener('close', onlegacyfinish);\n          stream.removeListener('finish', onfinish);\n          stream.removeListener('end', onend);\n          stream.removeListener('error', onerror);\n          stream.removeListener('close', onclose);\n        };\n      }\n\n      module.exports = eos;\n    }, {\n      \"../../../errors\": 46\n    }],\n    56: [function (require, module, exports) {\n      module.exports = function () {\n        throw new Error('Readable.from is not available in the browser');\n      };\n    }, {}],\n    57: [function (require, module, exports) {\n      // Ported from https://github.com/mafintosh/pump with\n      // permission from the author, Mathias Buus (@mafintosh).\n      'use strict';\n\n      var eos;\n\n      function once(callback) {\n        var called = false;\n        return function () {\n          if (called) return;\n          called = true;\n          callback.apply(void 0, arguments);\n        };\n      }\n\n      var _require$codes = require('../../../errors').codes,\n          ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n          ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\n      function noop(err) {\n        // Rethrow the error if it exists to avoid swallowing it\n        if (err) throw err;\n      }\n\n      function isRequest(stream) {\n        return stream.setHeader && typeof stream.abort === 'function';\n      }\n\n      function destroyer(stream, reading, writing, callback) {\n        callback = once(callback);\n        var closed = false;\n        stream.on('close', function () {\n          closed = true;\n        });\n        if (eos === undefined) eos = require('./end-of-stream');\n        eos(stream, {\n          readable: reading,\n          writable: writing\n        }, function (err) {\n          if (err) return callback(err);\n          closed = true;\n          callback();\n        });\n        var destroyed = false;\n        return function (err) {\n          if (closed) return;\n          if (destroyed) return;\n          destroyed = true; // request.destroy just do .end - .abort is what we want\n\n          if (isRequest(stream)) return stream.abort();\n          if (typeof stream.destroy === 'function') return stream.destroy();\n          callback(err || new ERR_STREAM_DESTROYED('pipe'));\n        };\n      }\n\n      function call(fn) {\n        fn();\n      }\n\n      function pipe(from, to) {\n        return from.pipe(to);\n      }\n\n      function popCallback(streams) {\n        if (!streams.length) return noop;\n        if (typeof streams[streams.length - 1] !== 'function') return noop;\n        return streams.pop();\n      }\n\n      function pipeline() {\n        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n          streams[_key] = arguments[_key];\n        }\n\n        var callback = popCallback(streams);\n        if (Array.isArray(streams[0])) streams = streams[0];\n\n        if (streams.length < 2) {\n          throw new ERR_MISSING_ARGS('streams');\n        }\n\n        var error;\n        var destroys = streams.map(function (stream, i) {\n          var reading = i < streams.length - 1;\n          var writing = i > 0;\n          return destroyer(stream, reading, writing, function (err) {\n            if (!error) error = err;\n            if (err) destroys.forEach(call);\n            if (reading) return;\n            destroys.forEach(call);\n            callback(error);\n          });\n        });\n        return streams.reduce(pipe);\n      }\n\n      module.exports = pipeline;\n    }, {\n      \"../../../errors\": 46,\n      \"./end-of-stream\": 55\n    }],\n    58: [function (require, module, exports) {\n      'use strict';\n\n      var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\n      function highWaterMarkFrom(options, isDuplex, duplexKey) {\n        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n      }\n\n      function getHighWaterMark(state, options, duplexKey, isDuplex) {\n        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n        if (hwm != null) {\n          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n            var name = isDuplex ? duplexKey : 'highWaterMark';\n            throw new ERR_INVALID_OPT_VALUE(name, hwm);\n          }\n\n          return Math.floor(hwm);\n        } // Default value\n\n\n        return state.objectMode ? 16 : 16 * 1024;\n      }\n\n      module.exports = {\n        getHighWaterMark: getHighWaterMark\n      };\n    }, {\n      \"../../../errors\": 46\n    }],\n    59: [function (require, module, exports) {\n      arguments[4][29][0].apply(exports, arguments);\n    }, {\n      \"dup\": 29,\n      \"events\": 4\n    }],\n    60: [function (require, module, exports) {\n      exports = module.exports = require('./lib/_stream_readable.js');\n      exports.Stream = exports;\n      exports.Readable = exports;\n      exports.Writable = require('./lib/_stream_writable.js');\n      exports.Duplex = require('./lib/_stream_duplex.js');\n      exports.Transform = require('./lib/_stream_transform.js');\n      exports.PassThrough = require('./lib/_stream_passthrough.js');\n      exports.finished = require('./lib/internal/streams/end-of-stream.js');\n      exports.pipeline = require('./lib/internal/streams/pipeline.js');\n    }, {\n      \"./lib/_stream_duplex.js\": 47,\n      \"./lib/_stream_passthrough.js\": 48,\n      \"./lib/_stream_readable.js\": 49,\n      \"./lib/_stream_transform.js\": 50,\n      \"./lib/_stream_writable.js\": 51,\n      \"./lib/internal/streams/end-of-stream.js\": 55,\n      \"./lib/internal/streams/pipeline.js\": 57\n    }],\n    61: [function (require, module, exports) {\n      'use strict';\n\n      function ReInterval(callback, interval, args) {\n        var self = this;\n        this._callback = callback;\n        this._args = args;\n        this._interval = setInterval(callback, interval, this._args);\n\n        this.reschedule = function (interval) {\n          // if no interval entered, use the interval passed in on creation\n          if (!interval) interval = self._interval;\n          if (self._interval) clearInterval(self._interval);\n          self._interval = setInterval(self._callback, interval, self._args);\n        };\n\n        this.clear = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n            self._interval = undefined;\n          }\n        };\n\n        this.destroy = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n          }\n\n          self._callback = undefined;\n          self._interval = undefined;\n          self._args = undefined;\n        };\n      }\n\n      function reInterval() {\n        if (typeof arguments[0] !== 'function') throw new Error('callback needed');\n        if (typeof arguments[1] !== 'number') throw new Error('interval needed');\n        var args;\n\n        if (arguments.length > 0) {\n          args = new Array(arguments.length - 2);\n\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 2];\n          }\n        }\n\n        return new ReInterval(arguments[0], arguments[1], args);\n      }\n\n      module.exports = reInterval;\n    }, {}],\n    62: [function (require, module, exports) {\n      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\n      /* eslint-disable node/no-deprecated-api */\n      var buffer = require('buffer');\n\n      var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\n      function copyProps(src, dst) {\n        for (var key in src) {\n          dst[key] = src[key];\n        }\n      }\n\n      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n        module.exports = buffer;\n      } else {\n        // Copy properties from require('buffer')\n        copyProps(buffer, exports);\n        exports.Buffer = SafeBuffer;\n      }\n\n      function SafeBuffer(arg, encodingOrOffset, length) {\n        return Buffer(arg, encodingOrOffset, length);\n      }\n\n      SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer\n\n      copyProps(Buffer, SafeBuffer);\n\n      SafeBuffer.from = function (arg, encodingOrOffset, length) {\n        if (typeof arg === 'number') {\n          throw new TypeError('Argument must not be a number');\n        }\n\n        return Buffer(arg, encodingOrOffset, length);\n      };\n\n      SafeBuffer.alloc = function (size, fill, encoding) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        var buf = Buffer(size);\n\n        if (fill !== undefined) {\n          if (typeof encoding === 'string') {\n            buf.fill(fill, encoding);\n          } else {\n            buf.fill(fill);\n          }\n        } else {\n          buf.fill(0);\n        }\n\n        return buf;\n      };\n\n      SafeBuffer.allocUnsafe = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        return Buffer(size);\n      };\n\n      SafeBuffer.allocUnsafeSlow = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n\n        return buffer.SlowBuffer(size);\n      };\n    }, {\n      \"buffer\": 3\n    }],\n    63: [function (require, module, exports) {\n      module.exports = shift;\n\n      function shift(stream) {\n        var rs = stream._readableState;\n        if (!rs) return null;\n        return rs.objectMode || typeof stream._duplexState === 'number' ? stream.read() : stream.read(getStateLength(rs));\n      }\n\n      function getStateLength(state) {\n        if (state.buffer.length) {\n          // Since node 6.3.0 state.buffer is a BufferList not an array\n          if (state.buffer.head) {\n            return state.buffer.head.data.length;\n          }\n\n          return state.buffer[0].length;\n        }\n\n        return state.length;\n      }\n    }, {}],\n    64: [function (require, module, exports) {\n      arguments[4][32][0].apply(exports, arguments);\n    }, {\n      \"dup\": 32,\n      \"safe-buffer\": 62\n    }],\n    65: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          /**\n           * Module exports.\n           */\n          module.exports = deprecate;\n          /**\n           * Mark that a method should not be used.\n           * Returns a modified function which warns once by default.\n           *\n           * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n           *\n           * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n           * will throw an Error when invoked.\n           *\n           * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n           * will invoke `console.trace()` instead of `console.error()`.\n           *\n           * @param {Function} fn - the function to deprecate\n           * @param {String} msg - the string to print to the console when `fn` is invoked\n           * @returns {Function} a new \"deprecated\" version of `fn`\n           * @api public\n           */\n\n          function deprecate(fn, msg) {\n            if (config('noDeprecation')) {\n              return fn;\n            }\n\n            var warned = false;\n\n            function deprecated() {\n              if (!warned) {\n                if (config('throwDeprecation')) {\n                  throw new Error(msg);\n                } else if (config('traceDeprecation')) {\n                  console.trace(msg);\n                } else {\n                  console.warn(msg);\n                }\n\n                warned = true;\n              }\n\n              return fn.apply(this, arguments);\n            }\n\n            return deprecated;\n          }\n          /**\n           * Checks `localStorage` for boolean values for the given `name`.\n           *\n           * @param {String} name\n           * @returns {Boolean}\n           * @api private\n           */\n\n\n          function config(name) {\n            // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n            try {\n              if (!global.localStorage) return false;\n            } catch (_) {\n              return false;\n            }\n\n            var val = global.localStorage[name];\n            if (null == val) return false;\n            return String(val).toLowerCase() === 'true';\n          }\n        }).call(this);\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    66: [function (require, module, exports) {\n      // Returns a wrapper function that returns a wrapped callback\n      // The wrapper function should do some stuff, and return a\n      // presumably different callback function.\n      // This makes sure that own properties are retained, so that\n      // decorations and such are not lost along the way.\n      module.exports = wrappy;\n\n      function wrappy(fn, cb) {\n        if (fn && cb) return wrappy(fn)(cb);\n        if (typeof fn !== 'function') throw new TypeError('need wrapper function');\n        Object.keys(fn).forEach(function (k) {\n          wrapper[k] = fn[k];\n        });\n        return wrapper;\n\n        function wrapper() {\n          var args = new Array(arguments.length);\n\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i];\n          }\n\n          var ret = fn.apply(this, args);\n          var cb = args[args.length - 1];\n\n          if (typeof ret === 'function' && ret !== cb) {\n            Object.keys(cb).forEach(function (k) {\n              ret[k] = cb[k];\n            });\n          }\n\n          return ret;\n        }\n      }\n    }, {}],\n    67: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = function () {\n        throw new Error('ws does not work in the browser. Browser clients must use the native ' + 'WebSocket object');\n      };\n    }, {}],\n    68: [function (require, module, exports) {\n      module.exports = extend;\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      function extend() {\n        var target = {};\n\n        for (var i = 0; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      }\n    }, {}],\n    69: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        } // if setTimeout wasn't available but was latter defined\n\n\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        } // if clearTimeout wasn't available but was latter defined\n\n\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n\n        draining = false;\n\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n\n          queueIndex = -1;\n          len = queue.length;\n        }\n\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n\n        queue.push(new Item(fun, args));\n\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      }; // v8 likes predictible objects\n\n\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {\n        return [];\n      };\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {\n        return '/';\n      };\n\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n      process.umask = function () {\n        return 0;\n      };\n    }, {}],\n    70: [function (require, module, exports) {\n      (function (global) {\n        (function () {\n          /*! https://mths.be/punycode v1.4.1 by @mathias */\n          ;\n\n          (function (root) {\n            /** Detect free variables */\n            var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n            var freeModule = typeof module == 'object' && module && !module.nodeType && module;\n            var freeGlobal = typeof global == 'object' && global;\n\n            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n              root = freeGlobal;\n            }\n            /**\n             * The `punycode` object.\n             * @name punycode\n             * @type Object\n             */\n\n\n            var punycode,\n\n            /** Highest positive signed 32-bit float value */\n            maxInt = 2147483647,\n                // aka. 0x7FFFFFFF or 2^31-1\n\n            /** Bootstring parameters */\n            base = 36,\n                tMin = 1,\n                tMax = 26,\n                skew = 38,\n                damp = 700,\n                initialBias = 72,\n                initialN = 128,\n                // 0x80\n            delimiter = '-',\n                // '\\x2D'\n\n            /** Regular expressions */\n            regexPunycode = /^xn--/,\n                regexNonASCII = /[^\\x20-\\x7E]/,\n                // unprintable ASCII chars + non-ASCII chars\n            regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n                // RFC 3490 separators\n\n            /** Error messages */\n            errors = {\n              'overflow': 'Overflow: input needs wider integers to process',\n              'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n              'invalid-input': 'Invalid input'\n            },\n\n            /** Convenience shortcuts */\n            baseMinusTMin = base - tMin,\n                floor = Math.floor,\n                stringFromCharCode = String.fromCharCode,\n\n            /** Temporary variable */\n            key;\n            /*--------------------------------------------------------------------------*/\n\n            /**\n             * A generic error utility function.\n             * @private\n             * @param {String} type The error type.\n             * @returns {Error} Throws a `RangeError` with the applicable error message.\n             */\n\n            function error(type) {\n              throw new RangeError(errors[type]);\n            }\n            /**\n             * A generic `Array#map` utility function.\n             * @private\n             * @param {Array} array The array to iterate over.\n             * @param {Function} callback The function that gets called for every array\n             * item.\n             * @returns {Array} A new array of values returned by the callback function.\n             */\n\n\n            function map(array, fn) {\n              var length = array.length;\n              var result = [];\n\n              while (length--) {\n                result[length] = fn(array[length]);\n              }\n\n              return result;\n            }\n            /**\n             * A simple `Array#map`-like wrapper to work with domain name strings or email\n             * addresses.\n             * @private\n             * @param {String} domain The domain name or email address.\n             * @param {Function} callback The function that gets called for every\n             * character.\n             * @returns {Array} A new string of characters returned by the callback\n             * function.\n             */\n\n\n            function mapDomain(string, fn) {\n              var parts = string.split('@');\n              var result = '';\n\n              if (parts.length > 1) {\n                // In email addresses, only the domain name should be punycoded. Leave\n                // the local part (i.e. everything up to `@`) intact.\n                result = parts[0] + '@';\n                string = parts[1];\n              } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n              string = string.replace(regexSeparators, '\\x2E');\n              var labels = string.split('.');\n              var encoded = map(labels, fn).join('.');\n              return result + encoded;\n            }\n            /**\n             * Creates an array containing the numeric code points of each Unicode\n             * character in the string. While JavaScript uses UCS-2 internally,\n             * this function will convert a pair of surrogate halves (each of which\n             * UCS-2 exposes as separate characters) into a single code point,\n             * matching UTF-16.\n             * @see `punycode.ucs2.encode`\n             * @see <https://mathiasbynens.be/notes/javascript-encoding>\n             * @memberOf punycode.ucs2\n             * @name decode\n             * @param {String} string The Unicode input string (UCS-2).\n             * @returns {Array} The new array of code points.\n             */\n\n\n            function ucs2decode(string) {\n              var output = [],\n                  counter = 0,\n                  length = string.length,\n                  value,\n                  extra;\n\n              while (counter < length) {\n                value = string.charCodeAt(counter++);\n\n                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                  // high surrogate, and there is a next character\n                  extra = string.charCodeAt(counter++);\n\n                  if ((extra & 0xFC00) == 0xDC00) {\n                    // low surrogate\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                  } else {\n                    // unmatched surrogate; only append this code unit, in case the next\n                    // code unit is the high surrogate of a surrogate pair\n                    output.push(value);\n                    counter--;\n                  }\n                } else {\n                  output.push(value);\n                }\n              }\n\n              return output;\n            }\n            /**\n             * Creates a string based on an array of numeric code points.\n             * @see `punycode.ucs2.decode`\n             * @memberOf punycode.ucs2\n             * @name encode\n             * @param {Array} codePoints The array of numeric code points.\n             * @returns {String} The new Unicode string (UCS-2).\n             */\n\n\n            function ucs2encode(array) {\n              return map(array, function (value) {\n                var output = '';\n\n                if (value > 0xFFFF) {\n                  value -= 0x10000;\n                  output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                  value = 0xDC00 | value & 0x3FF;\n                }\n\n                output += stringFromCharCode(value);\n                return output;\n              }).join('');\n            }\n            /**\n             * Converts a basic code point into a digit/integer.\n             * @see `digitToBasic()`\n             * @private\n             * @param {Number} codePoint The basic numeric code point value.\n             * @returns {Number} The numeric value of a basic code point (for use in\n             * representing integers) in the range `0` to `base - 1`, or `base` if\n             * the code point does not represent a value.\n             */\n\n\n            function basicToDigit(codePoint) {\n              if (codePoint - 48 < 10) {\n                return codePoint - 22;\n              }\n\n              if (codePoint - 65 < 26) {\n                return codePoint - 65;\n              }\n\n              if (codePoint - 97 < 26) {\n                return codePoint - 97;\n              }\n\n              return base;\n            }\n            /**\n             * Converts a digit/integer into a basic code point.\n             * @see `basicToDigit()`\n             * @private\n             * @param {Number} digit The numeric value of a basic code point.\n             * @returns {Number} The basic code point whose value (when used for\n             * representing integers) is `digit`, which needs to be in the range\n             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n             * used; else, the lowercase form is used. The behavior is undefined\n             * if `flag` is non-zero and `digit` has no uppercase form.\n             */\n\n\n            function digitToBasic(digit, flag) {\n              //  0..25 map to ASCII a..z or A..Z\n              // 26..35 map to ASCII 0..9\n              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n            }\n            /**\n             * Bias adaptation function as per section 3.4 of RFC 3492.\n             * https://tools.ietf.org/html/rfc3492#section-3.4\n             * @private\n             */\n\n\n            function adapt(delta, numPoints, firstTime) {\n              var k = 0;\n              delta = firstTime ? floor(delta / damp) : delta >> 1;\n              delta += floor(delta / numPoints);\n\n              for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n                delta = floor(delta / baseMinusTMin);\n              }\n\n              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n            }\n            /**\n             * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n             * symbols.\n             * @memberOf punycode\n             * @param {String} input The Punycode string of ASCII-only symbols.\n             * @returns {String} The resulting string of Unicode symbols.\n             */\n\n\n            function decode(input) {\n              // Don't use UCS-2\n              var output = [],\n                  inputLength = input.length,\n                  out,\n                  i = 0,\n                  n = initialN,\n                  bias = initialBias,\n                  basic,\n                  j,\n                  index,\n                  oldi,\n                  w,\n                  k,\n                  digit,\n                  t,\n\n              /** Cached calculation results */\n              baseMinusT; // Handle the basic code points: let `basic` be the number of input code\n              // points before the last delimiter, or `0` if there is none, then copy\n              // the first basic code points to the output.\n\n              basic = input.lastIndexOf(delimiter);\n\n              if (basic < 0) {\n                basic = 0;\n              }\n\n              for (j = 0; j < basic; ++j) {\n                // if it's not a basic code point\n                if (input.charCodeAt(j) >= 0x80) {\n                  error('not-basic');\n                }\n\n                output.push(input.charCodeAt(j));\n              } // Main decoding loop: start just after the last delimiter if any basic code\n              // points were copied; start at the beginning otherwise.\n\n\n              for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n                // `index` is the index of the next character to be consumed.\n                // Decode a generalized variable-length integer into `delta`,\n                // which gets added to `i`. The overflow checking is easier\n                // if we increase `i` as we go, then subtract off its starting\n                // value at the end to obtain `delta`.\n                for (oldi = i, w = 1, k = base;; k += base) {\n                  if (index >= inputLength) {\n                    error('invalid-input');\n                  }\n\n                  digit = basicToDigit(input.charCodeAt(index++));\n\n                  if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error('overflow');\n                  }\n\n                  i += digit * w;\n                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                  if (digit < t) {\n                    break;\n                  }\n\n                  baseMinusT = base - t;\n\n                  if (w > floor(maxInt / baseMinusT)) {\n                    error('overflow');\n                  }\n\n                  w *= baseMinusT;\n                }\n\n                out = output.length + 1;\n                bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n                // incrementing `n` each time, so we'll fix that now:\n\n                if (floor(i / out) > maxInt - n) {\n                  error('overflow');\n                }\n\n                n += floor(i / out);\n                i %= out; // Insert `n` at position `i` of the output\n\n                output.splice(i++, 0, n);\n              }\n\n              return ucs2encode(output);\n            }\n            /**\n             * Converts a string of Unicode symbols (e.g. a domain name label) to a\n             * Punycode string of ASCII-only symbols.\n             * @memberOf punycode\n             * @param {String} input The string of Unicode symbols.\n             * @returns {String} The resulting Punycode string of ASCII-only symbols.\n             */\n\n\n            function encode(input) {\n              var n,\n                  delta,\n                  handledCPCount,\n                  basicLength,\n                  bias,\n                  j,\n                  m,\n                  q,\n                  k,\n                  t,\n                  currentValue,\n                  output = [],\n\n              /** `inputLength` will hold the number of code points in `input`. */\n              inputLength,\n\n              /** Cached calculation results */\n              handledCPCountPlusOne,\n                  baseMinusT,\n                  qMinusT; // Convert the input in UCS-2 to Unicode\n\n              input = ucs2decode(input); // Cache the length\n\n              inputLength = input.length; // Initialize the state\n\n              n = initialN;\n              delta = 0;\n              bias = initialBias; // Handle the basic code points\n\n              for (j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n\n                if (currentValue < 0x80) {\n                  output.push(stringFromCharCode(currentValue));\n                }\n              }\n\n              handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;\n              // `basicLength` is the number of basic code points.\n              // Finish the basic string - if it is not empty - with a delimiter\n\n              if (basicLength) {\n                output.push(delimiter);\n              } // Main encoding loop:\n\n\n              while (handledCPCount < inputLength) {\n                // All non-basic code points < n have been handled already. Find the next\n                // larger one:\n                for (m = maxInt, j = 0; j < inputLength; ++j) {\n                  currentValue = input[j];\n\n                  if (currentValue >= n && currentValue < m) {\n                    m = currentValue;\n                  }\n                } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n                // but guard against overflow\n\n\n                handledCPCountPlusOne = handledCPCount + 1;\n\n                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                  error('overflow');\n                }\n\n                delta += (m - n) * handledCPCountPlusOne;\n                n = m;\n\n                for (j = 0; j < inputLength; ++j) {\n                  currentValue = input[j];\n\n                  if (currentValue < n && ++delta > maxInt) {\n                    error('overflow');\n                  }\n\n                  if (currentValue == n) {\n                    // Represent delta as a generalized variable-length integer\n                    for (q = delta, k = base;; k += base) {\n                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                      if (q < t) {\n                        break;\n                      }\n\n                      qMinusT = q - t;\n                      baseMinusT = base - t;\n                      output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                      q = floor(qMinusT / baseMinusT);\n                    }\n\n                    output.push(stringFromCharCode(digitToBasic(q, 0)));\n                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                    delta = 0;\n                    ++handledCPCount;\n                  }\n                }\n\n                ++delta;\n                ++n;\n              }\n\n              return output.join('');\n            }\n            /**\n             * Converts a Punycode string representing a domain name or an email address\n             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n             * it doesn't matter if you call it on a string that has already been\n             * converted to Unicode.\n             * @memberOf punycode\n             * @param {String} input The Punycoded domain name or email address to\n             * convert to Unicode.\n             * @returns {String} The Unicode representation of the given Punycode\n             * string.\n             */\n\n\n            function toUnicode(input) {\n              return mapDomain(input, function (string) {\n                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n              });\n            }\n            /**\n             * Converts a Unicode string representing a domain name or an email address to\n             * Punycode. Only the non-ASCII parts of the domain name will be converted,\n             * i.e. it doesn't matter if you call it with a domain that's already in\n             * ASCII.\n             * @memberOf punycode\n             * @param {String} input The domain name or email address to convert, as a\n             * Unicode string.\n             * @returns {String} The Punycode representation of the given domain name or\n             * email address.\n             */\n\n\n            function toASCII(input) {\n              return mapDomain(input, function (string) {\n                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n              });\n            }\n            /*--------------------------------------------------------------------------*/\n\n            /** Define the public API */\n\n\n            punycode = {\n              /**\n               * A string representing the current Punycode.js version number.\n               * @memberOf punycode\n               * @type String\n               */\n              'version': '1.4.1',\n\n              /**\n               * An object of methods to convert from JavaScript's internal character\n               * representation (UCS-2) to Unicode code points, and back.\n               * @see <https://mathiasbynens.be/notes/javascript-encoding>\n               * @memberOf punycode\n               * @type Object\n               */\n              'ucs2': {\n                'decode': ucs2decode,\n                'encode': ucs2encode\n              },\n              'decode': decode,\n              'encode': encode,\n              'toASCII': toASCII,\n              'toUnicode': toUnicode\n            };\n            /** Expose `punycode` */\n            // Some AMD build optimizers, like r.js, check for specific condition patterns\n            // like the following:\n\n            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n              define('punycode', function () {\n                return punycode;\n              });\n            } else if (freeExports && freeModule) {\n              if (module.exports == freeExports) {\n                // in Node.js, io.js, or RingoJS v0.8.0+\n                freeModule.exports = punycode;\n              } else {\n                // in Narwhal or RingoJS v0.7.0-\n                for (key in punycode) {\n                  punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n                }\n              }\n            } else {\n              // in Rhino or a web browser\n              root.punycode = punycode;\n            }\n          })(this);\n        }).call(this);\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    71: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict'; // If obj.hasOwnProperty has been overridden, then calling\n      // obj.hasOwnProperty(prop) will break.\n      // See: https://github.com/joyent/node/issues/1707\n\n      function hasOwnProperty(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n      }\n\n      module.exports = function (qs, sep, eq, options) {\n        sep = sep || '&';\n        eq = eq || '=';\n        var obj = {};\n\n        if (typeof qs !== 'string' || qs.length === 0) {\n          return obj;\n        }\n\n        var regexp = /\\+/g;\n        qs = qs.split(sep);\n        var maxKeys = 1000;\n\n        if (options && typeof options.maxKeys === 'number') {\n          maxKeys = options.maxKeys;\n        }\n\n        var len = qs.length; // maxKeys <= 0 means that we should not limit keys count\n\n        if (maxKeys > 0 && len > maxKeys) {\n          len = maxKeys;\n        }\n\n        for (var i = 0; i < len; ++i) {\n          var x = qs[i].replace(regexp, '%20'),\n              idx = x.indexOf(eq),\n              kstr,\n              vstr,\n              k,\n              v;\n\n          if (idx >= 0) {\n            kstr = x.substr(0, idx);\n            vstr = x.substr(idx + 1);\n          } else {\n            kstr = x;\n            vstr = '';\n          }\n\n          k = decodeURIComponent(kstr);\n          v = decodeURIComponent(vstr);\n\n          if (!hasOwnProperty(obj, k)) {\n            obj[k] = v;\n          } else if (isArray(obj[k])) {\n            obj[k].push(v);\n          } else {\n            obj[k] = [obj[k], v];\n          }\n        }\n\n        return obj;\n      };\n\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n    }, {}],\n    72: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict';\n\n      var stringifyPrimitive = function (v) {\n        switch (typeof v) {\n          case 'string':\n            return v;\n\n          case 'boolean':\n            return v ? 'true' : 'false';\n\n          case 'number':\n            return isFinite(v) ? v : '';\n\n          default:\n            return '';\n        }\n      };\n\n      module.exports = function (obj, sep, eq, name) {\n        sep = sep || '&';\n        eq = eq || '=';\n\n        if (obj === null) {\n          obj = undefined;\n        }\n\n        if (typeof obj === 'object') {\n          return map(objectKeys(obj), function (k) {\n            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\n            if (isArray(obj[k])) {\n              return map(obj[k], function (v) {\n                return ks + encodeURIComponent(stringifyPrimitive(v));\n              }).join(sep);\n            } else {\n              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n            }\n          }).join(sep);\n        }\n\n        if (!name) return '';\n        return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n      };\n\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n\n      function map(xs, f) {\n        if (xs.map) return xs.map(f);\n        var res = [];\n\n        for (var i = 0; i < xs.length; i++) {\n          res.push(f(xs[i], i));\n        }\n\n        return res;\n      }\n\n      var objectKeys = Object.keys || function (obj) {\n        var res = [];\n\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n        }\n\n        return res;\n      };\n    }, {}],\n    73: [function (require, module, exports) {\n      'use strict';\n\n      exports.decode = exports.parse = require('./decode');\n      exports.encode = exports.stringify = require('./encode');\n    }, {\n      \"./decode\": 71,\n      \"./encode\": 72\n    }],\n    74: [function (require, module, exports) {\n      (function (setImmediate, clearImmediate) {\n        (function () {\n          var nextTick = require('process/browser.js').nextTick;\n\n          var apply = Function.prototype.apply;\n          var slice = Array.prototype.slice;\n          var immediateIds = {};\n          var nextImmediateId = 0; // DOM APIs, for completeness\n\n          exports.setTimeout = function () {\n            return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n          };\n\n          exports.setInterval = function () {\n            return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n          };\n\n          exports.clearTimeout = exports.clearInterval = function (timeout) {\n            timeout.close();\n          };\n\n          function Timeout(id, clearFn) {\n            this._id = id;\n            this._clearFn = clearFn;\n          }\n\n          Timeout.prototype.unref = Timeout.prototype.ref = function () {};\n\n          Timeout.prototype.close = function () {\n            this._clearFn.call(window, this._id);\n          }; // Does not start the time, just sets up the members needed.\n\n\n          exports.enroll = function (item, msecs) {\n            clearTimeout(item._idleTimeoutId);\n            item._idleTimeout = msecs;\n          };\n\n          exports.unenroll = function (item) {\n            clearTimeout(item._idleTimeoutId);\n            item._idleTimeout = -1;\n          };\n\n          exports._unrefActive = exports.active = function (item) {\n            clearTimeout(item._idleTimeoutId);\n            var msecs = item._idleTimeout;\n\n            if (msecs >= 0) {\n              item._idleTimeoutId = setTimeout(function onTimeout() {\n                if (item._onTimeout) item._onTimeout();\n              }, msecs);\n            }\n          }; // That's not how node.js implements it but the exposed api is the same.\n\n\n          exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function (fn) {\n            var id = nextImmediateId++;\n            var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n            immediateIds[id] = true;\n            nextTick(function onNextTick() {\n              if (immediateIds[id]) {\n                // fn.call() is faster so we optimize for the common use-case\n                // @see http://jsperf.com/call-apply-segu\n                if (args) {\n                  fn.apply(null, args);\n                } else {\n                  fn.call(null);\n                } // Prevent ids from leaking\n\n\n                exports.clearImmediate(id);\n              }\n            });\n            return id;\n          };\n          exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function (id) {\n            delete immediateIds[id];\n          };\n        }).call(this);\n      }).call(this, require(\"timers\").setImmediate, require(\"timers\").clearImmediate);\n    }, {\n      \"process/browser.js\": 69,\n      \"timers\": 74\n    }],\n    75: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n      'use strict';\n\n      var punycode = require('punycode');\n\n      var util = require('./util');\n\n      exports.parse = urlParse;\n      exports.resolve = urlResolve;\n      exports.resolveObject = urlResolveObject;\n      exports.format = urlFormat;\n      exports.Url = Url;\n\n      function Url() {\n        this.protocol = null;\n        this.slashes = null;\n        this.auth = null;\n        this.host = null;\n        this.port = null;\n        this.hostname = null;\n        this.hash = null;\n        this.search = null;\n        this.query = null;\n        this.pathname = null;\n        this.path = null;\n        this.href = null;\n      } // Reference: RFC 3986, RFC 1808, RFC 2396\n      // define these here so at least they only have to be\n      // compiled once on the first module load.\n\n\n      var protocolPattern = /^([a-z0-9.+-]+:)/i,\n          portPattern = /:[0-9]*$/,\n          // Special case for a simple path URL\n      simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n          // RFC 2396: characters reserved for delimiting URLs.\n      // We actually just auto-escape these.\n      delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n          // RFC 2396: characters not allowed for various reasons.\n      unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n          // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n      autoEscape = ['\\''].concat(unwise),\n          // Characters that are never ever allowed in a hostname.\n      // Note that any invalid chars are also handled, but these\n      // are the ones that are *expected* to be seen, so we fast-path\n      // them.\n      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n          hostEndingChars = ['/', '?', '#'],\n          hostnameMaxLen = 255,\n          hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n          hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n          // protocols that can allow \"unsafe\" and \"unwise\" chars.\n      unsafeProtocol = {\n        'javascript': true,\n        'javascript:': true\n      },\n          // protocols that never have a hostname.\n      hostlessProtocol = {\n        'javascript': true,\n        'javascript:': true\n      },\n          // protocols that always contain a // bit.\n      slashedProtocol = {\n        'http': true,\n        'https': true,\n        'ftp': true,\n        'gopher': true,\n        'file': true,\n        'http:': true,\n        'https:': true,\n        'ftp:': true,\n        'gopher:': true,\n        'file:': true\n      },\n          querystring = require('querystring');\n\n      function urlParse(url, parseQueryString, slashesDenoteHost) {\n        if (url && util.isObject(url) && url instanceof Url) return url;\n        var u = new Url();\n        u.parse(url, parseQueryString, slashesDenoteHost);\n        return u;\n      }\n\n      Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n        if (!util.isString(url)) {\n          throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n        } // Copy chrome, IE, opera backslash-handling behavior.\n        // Back slashes before the query string get converted to forward slashes\n        // See: https://code.google.com/p/chromium/issues/detail?id=25916\n\n\n        var queryIndex = url.indexOf('?'),\n            splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n            uSplit = url.split(splitter),\n            slashRegex = /\\\\/g;\n        uSplit[0] = uSplit[0].replace(slashRegex, '/');\n        url = uSplit.join(splitter);\n        var rest = url; // trim before proceeding.\n        // This is to support parse stuff like \"  http://foo.com  \\n\"\n\n        rest = rest.trim();\n\n        if (!slashesDenoteHost && url.split('#').length === 1) {\n          // Try fast path regexp\n          var simplePath = simplePathPattern.exec(rest);\n\n          if (simplePath) {\n            this.path = rest;\n            this.href = rest;\n            this.pathname = simplePath[1];\n\n            if (simplePath[2]) {\n              this.search = simplePath[2];\n\n              if (parseQueryString) {\n                this.query = querystring.parse(this.search.substr(1));\n              } else {\n                this.query = this.search.substr(1);\n              }\n            } else if (parseQueryString) {\n              this.search = '';\n              this.query = {};\n            }\n\n            return this;\n          }\n        }\n\n        var proto = protocolPattern.exec(rest);\n\n        if (proto) {\n          proto = proto[0];\n          var lowerProto = proto.toLowerCase();\n          this.protocol = lowerProto;\n          rest = rest.substr(proto.length);\n        } // figure out if it's got a host\n        // user@server is *always* interpreted as a hostname, and url\n        // resolution will treat //foo/bar as host=foo,path=bar because that's\n        // how the browser resolves relative URLs.\n\n\n        if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n          var slashes = rest.substr(0, 2) === '//';\n\n          if (slashes && !(proto && hostlessProtocol[proto])) {\n            rest = rest.substr(2);\n            this.slashes = true;\n          }\n        }\n\n        if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n          // there's a hostname.\n          // the first instance of /, ?, ;, or # ends the host.\n          //\n          // If there is an @ in the hostname, then non-host chars *are* allowed\n          // to the left of the last @ sign, unless some host-ending character\n          // comes *before* the @-sign.\n          // URLs are obnoxious.\n          //\n          // ex:\n          // http://a@b@c/ => user:a@b host:c\n          // http://a@b?@c => user:a host:c path:/?@c\n          // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n          // Review our test case against browsers more comprehensively.\n          // find the first instance of any hostEndingChars\n          var hostEnd = -1;\n\n          for (var i = 0; i < hostEndingChars.length; i++) {\n            var hec = rest.indexOf(hostEndingChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n          } // at this point, either we have an explicit point where the\n          // auth portion cannot go past, or the last @ char is the decider.\n\n\n          var auth, atSign;\n\n          if (hostEnd === -1) {\n            // atSign can be anywhere.\n            atSign = rest.lastIndexOf('@');\n          } else {\n            // atSign must be in auth portion.\n            // http://a@b/c@d => host:b auth:a path:/c@d\n            atSign = rest.lastIndexOf('@', hostEnd);\n          } // Now we have a portion which is definitely the auth.\n          // Pull that off.\n\n\n          if (atSign !== -1) {\n            auth = rest.slice(0, atSign);\n            rest = rest.slice(atSign + 1);\n            this.auth = decodeURIComponent(auth);\n          } // the host is the remaining to the left of the first non-host char\n\n\n          hostEnd = -1;\n\n          for (var i = 0; i < nonHostChars.length; i++) {\n            var hec = rest.indexOf(nonHostChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n          } // if we still have not hit it, then the entire thing is a host.\n\n\n          if (hostEnd === -1) hostEnd = rest.length;\n          this.host = rest.slice(0, hostEnd);\n          rest = rest.slice(hostEnd); // pull out port.\n\n          this.parseHost(); // we've indicated that there is a hostname,\n          // so even if it's empty, it has to be present.\n\n          this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]\n          // assume that it's an IPv6 address.\n\n          var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.\n\n          if (!ipv6Hostname) {\n            var hostparts = this.hostname.split(/\\./);\n\n            for (var i = 0, l = hostparts.length; i < l; i++) {\n              var part = hostparts[i];\n              if (!part) continue;\n\n              if (!part.match(hostnamePartPattern)) {\n                var newpart = '';\n\n                for (var j = 0, k = part.length; j < k; j++) {\n                  if (part.charCodeAt(j) > 127) {\n                    // we replace non-ASCII char with a temporary placeholder\n                    // we need this to make sure size of hostname is not\n                    // broken by replacing non-ASCII by nothing\n                    newpart += 'x';\n                  } else {\n                    newpart += part[j];\n                  }\n                } // we test again with ASCII char only\n\n\n                if (!newpart.match(hostnamePartPattern)) {\n                  var validParts = hostparts.slice(0, i);\n                  var notHost = hostparts.slice(i + 1);\n                  var bit = part.match(hostnamePartStart);\n\n                  if (bit) {\n                    validParts.push(bit[1]);\n                    notHost.unshift(bit[2]);\n                  }\n\n                  if (notHost.length) {\n                    rest = '/' + notHost.join('.') + rest;\n                  }\n\n                  this.hostname = validParts.join('.');\n                  break;\n                }\n              }\n            }\n          }\n\n          if (this.hostname.length > hostnameMaxLen) {\n            this.hostname = '';\n          } else {\n            // hostnames are always lower case.\n            this.hostname = this.hostname.toLowerCase();\n          }\n\n          if (!ipv6Hostname) {\n            // IDNA Support: Returns a punycoded representation of \"domain\".\n            // It only converts parts of the domain name that\n            // have non-ASCII characters, i.e. it doesn't matter if\n            // you call it with a domain that already is ASCII-only.\n            this.hostname = punycode.toASCII(this.hostname);\n          }\n\n          var p = this.port ? ':' + this.port : '';\n          var h = this.hostname || '';\n          this.host = h + p;\n          this.href += this.host; // strip [ and ] from the hostname\n          // the host field still retains them, though\n\n          if (ipv6Hostname) {\n            this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\n            if (rest[0] !== '/') {\n              rest = '/' + rest;\n            }\n          }\n        } // now rest is set to the post-host stuff.\n        // chop off any delim chars.\n\n\n        if (!unsafeProtocol[lowerProto]) {\n          // First, make 100% sure that any \"autoEscape\" chars get\n          // escaped, even if encodeURIComponent doesn't think they\n          // need to be.\n          for (var i = 0, l = autoEscape.length; i < l; i++) {\n            var ae = autoEscape[i];\n            if (rest.indexOf(ae) === -1) continue;\n            var esc = encodeURIComponent(ae);\n\n            if (esc === ae) {\n              esc = escape(ae);\n            }\n\n            rest = rest.split(ae).join(esc);\n          }\n        } // chop off from the tail first.\n\n\n        var hash = rest.indexOf('#');\n\n        if (hash !== -1) {\n          // got a fragment string.\n          this.hash = rest.substr(hash);\n          rest = rest.slice(0, hash);\n        }\n\n        var qm = rest.indexOf('?');\n\n        if (qm !== -1) {\n          this.search = rest.substr(qm);\n          this.query = rest.substr(qm + 1);\n\n          if (parseQueryString) {\n            this.query = querystring.parse(this.query);\n          }\n\n          rest = rest.slice(0, qm);\n        } else if (parseQueryString) {\n          // no query string, but parseQueryString still requested\n          this.search = '';\n          this.query = {};\n        }\n\n        if (rest) this.pathname = rest;\n\n        if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n          this.pathname = '/';\n        } //to support http.request\n\n\n        if (this.pathname || this.search) {\n          var p = this.pathname || '';\n          var s = this.search || '';\n          this.path = p + s;\n        } // finally, reconstruct the href based on what has been validated.\n\n\n        this.href = this.format();\n        return this;\n      }; // format a parsed object into a url string\n\n\n      function urlFormat(obj) {\n        // ensure it's an object, and not a string url.\n        // If it's an obj, this is a no-op.\n        // this way, you can call url_format() on strings\n        // to clean up potentially wonky urls.\n        if (util.isString(obj)) obj = urlParse(obj);\n        if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n        return obj.format();\n      }\n\n      Url.prototype.format = function () {\n        var auth = this.auth || '';\n\n        if (auth) {\n          auth = encodeURIComponent(auth);\n          auth = auth.replace(/%3A/i, ':');\n          auth += '@';\n        }\n\n        var protocol = this.protocol || '',\n            pathname = this.pathname || '',\n            hash = this.hash || '',\n            host = false,\n            query = '';\n\n        if (this.host) {\n          host = auth + this.host;\n        } else if (this.hostname) {\n          host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n\n          if (this.port) {\n            host += ':' + this.port;\n          }\n        }\n\n        if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n          query = querystring.stringify(this.query);\n        }\n\n        var search = this.search || query && '?' + query || '';\n        if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n        // unless they had them to begin with.\n\n        if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n          host = '//' + (host || '');\n          if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n        } else if (!host) {\n          host = '';\n        }\n\n        if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n        if (search && search.charAt(0) !== '?') search = '?' + search;\n        pathname = pathname.replace(/[?#]/g, function (match) {\n          return encodeURIComponent(match);\n        });\n        search = search.replace('#', '%23');\n        return protocol + host + pathname + search + hash;\n      };\n\n      function urlResolve(source, relative) {\n        return urlParse(source, false, true).resolve(relative);\n      }\n\n      Url.prototype.resolve = function (relative) {\n        return this.resolveObject(urlParse(relative, false, true)).format();\n      };\n\n      function urlResolveObject(source, relative) {\n        if (!source) return relative;\n        return urlParse(source, false, true).resolveObject(relative);\n      }\n\n      Url.prototype.resolveObject = function (relative) {\n        if (util.isString(relative)) {\n          var rel = new Url();\n          rel.parse(relative, false, true);\n          relative = rel;\n        }\n\n        var result = new Url();\n        var tkeys = Object.keys(this);\n\n        for (var tk = 0; tk < tkeys.length; tk++) {\n          var tkey = tkeys[tk];\n          result[tkey] = this[tkey];\n        } // hash is always overridden, no matter what.\n        // even href=\"\" will remove it.\n\n\n        result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.\n\n        if (relative.href === '') {\n          result.href = result.format();\n          return result;\n        } // hrefs like //foo/bar always cut to the protocol.\n\n\n        if (relative.slashes && !relative.protocol) {\n          // take everything except the protocol from relative\n          var rkeys = Object.keys(relative);\n\n          for (var rk = 0; rk < rkeys.length; rk++) {\n            var rkey = rkeys[rk];\n            if (rkey !== 'protocol') result[rkey] = relative[rkey];\n          } //urlParse appends trailing / to urls like http://www.example.com\n\n\n          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n            result.path = result.pathname = '/';\n          }\n\n          result.href = result.format();\n          return result;\n        }\n\n        if (relative.protocol && relative.protocol !== result.protocol) {\n          // if it's a known url protocol, then changing\n          // the protocol does weird things\n          // first, if it's not file:, then we MUST have a host,\n          // and if there was a path\n          // to begin with, then we MUST have a path.\n          // if it is file:, then the host is dropped,\n          // because that's known to be hostless.\n          // anything else is assumed to be absolute.\n          if (!slashedProtocol[relative.protocol]) {\n            var keys = Object.keys(relative);\n\n            for (var v = 0; v < keys.length; v++) {\n              var k = keys[v];\n              result[k] = relative[k];\n            }\n\n            result.href = result.format();\n            return result;\n          }\n\n          result.protocol = relative.protocol;\n\n          if (!relative.host && !hostlessProtocol[relative.protocol]) {\n            var relPath = (relative.pathname || '').split('/');\n\n            while (relPath.length && !(relative.host = relPath.shift()));\n\n            if (!relative.host) relative.host = '';\n            if (!relative.hostname) relative.hostname = '';\n            if (relPath[0] !== '') relPath.unshift('');\n            if (relPath.length < 2) relPath.unshift('');\n            result.pathname = relPath.join('/');\n          } else {\n            result.pathname = relative.pathname;\n          }\n\n          result.search = relative.search;\n          result.query = relative.query;\n          result.host = relative.host || '';\n          result.auth = relative.auth;\n          result.hostname = relative.hostname || relative.host;\n          result.port = relative.port; // to support http.request\n\n          if (result.pathname || result.search) {\n            var p = result.pathname || '';\n            var s = result.search || '';\n            result.path = p + s;\n          }\n\n          result.slashes = result.slashes || relative.slashes;\n          result.href = result.format();\n          return result;\n        }\n\n        var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n            isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n            mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n            removeAllDots = mustEndAbs,\n            srcPath = result.pathname && result.pathname.split('/') || [],\n            relPath = relative.pathname && relative.pathname.split('/') || [],\n            psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative\n        // links like ../.. should be able\n        // to crawl up to the hostname, as well.  This is strange.\n        // result.protocol has already been set by now.\n        // Later on, put the first path part into the host field.\n\n        if (psychotic) {\n          result.hostname = '';\n          result.port = null;\n\n          if (result.host) {\n            if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n          }\n\n          result.host = '';\n\n          if (relative.protocol) {\n            relative.hostname = null;\n            relative.port = null;\n\n            if (relative.host) {\n              if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n            }\n\n            relative.host = null;\n          }\n\n          mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n        }\n\n        if (isRelAbs) {\n          // it's absolute.\n          result.host = relative.host || relative.host === '' ? relative.host : result.host;\n          result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n          result.search = relative.search;\n          result.query = relative.query;\n          srcPath = relPath; // fall through to the dot-handling below.\n        } else if (relPath.length) {\n          // it's relative\n          // throw away the existing file, and take the new path instead.\n          if (!srcPath) srcPath = [];\n          srcPath.pop();\n          srcPath = srcPath.concat(relPath);\n          result.search = relative.search;\n          result.query = relative.query;\n        } else if (!util.isNullOrUndefined(relative.search)) {\n          // just pull out the search.\n          // like href='?foo'.\n          // Put this after the other two cases because it simplifies the booleans\n          if (psychotic) {\n            result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host\n            //this especially happens in cases like\n            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n            if (authInHost) {\n              result.auth = authInHost.shift();\n              result.host = result.hostname = authInHost.shift();\n            }\n          }\n\n          result.search = relative.search;\n          result.query = relative.query; //to support http.request\n\n          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n          }\n\n          result.href = result.format();\n          return result;\n        }\n\n        if (!srcPath.length) {\n          // no path at all.  easy.\n          // we've already handled the other stuff above.\n          result.pathname = null; //to support http.request\n\n          if (result.search) {\n            result.path = '/' + result.search;\n          } else {\n            result.path = null;\n          }\n\n          result.href = result.format();\n          return result;\n        } // if a url ENDs in . or .., then it must get a trailing slash.\n        // however, if it ends in anything else non-slashy,\n        // then it must NOT get a trailing slash.\n\n\n        var last = srcPath.slice(-1)[0];\n        var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir\n        // if the path tries to go above the root, `up` ends up > 0\n\n        var up = 0;\n\n        for (var i = srcPath.length; i >= 0; i--) {\n          last = srcPath[i];\n\n          if (last === '.') {\n            srcPath.splice(i, 1);\n          } else if (last === '..') {\n            srcPath.splice(i, 1);\n            up++;\n          } else if (up) {\n            srcPath.splice(i, 1);\n            up--;\n          }\n        } // if the path is allowed to go above the root, restore leading ..s\n\n\n        if (!mustEndAbs && !removeAllDots) {\n          for (; up--; up) {\n            srcPath.unshift('..');\n          }\n        }\n\n        if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n          srcPath.unshift('');\n        }\n\n        if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n          srcPath.push('');\n        }\n\n        var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back\n\n        if (psychotic) {\n          result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host\n          //this especially happens in cases like\n          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n          var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n          if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n          }\n        }\n\n        mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n        if (mustEndAbs && !isAbsolute) {\n          srcPath.unshift('');\n        }\n\n        if (!srcPath.length) {\n          result.pathname = null;\n          result.path = null;\n        } else {\n          result.pathname = srcPath.join('/');\n        } //to support request.http\n\n\n        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n          result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n        }\n\n        result.auth = relative.auth || result.auth;\n        result.slashes = result.slashes || relative.slashes;\n        result.href = result.format();\n        return result;\n      };\n\n      Url.prototype.parseHost = function () {\n        var host = this.host;\n        var port = portPattern.exec(host);\n\n        if (port) {\n          port = port[0];\n\n          if (port !== ':') {\n            this.port = port.substr(1);\n          }\n\n          host = host.substr(0, host.length - port.length);\n        }\n\n        if (host) this.hostname = host;\n      };\n    }, {\n      \"./util\": 76,\n      \"punycode\": 70,\n      \"querystring\": 73\n    }],\n    76: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = {\n        isString: function (arg) {\n          return typeof arg === 'string';\n        },\n        isObject: function (arg) {\n          return typeof arg === 'object' && arg !== null;\n        },\n        isNull: function (arg) {\n          return arg === null;\n        },\n        isNullOrUndefined: function (arg) {\n          return arg == null;\n        }\n      };\n    }, {}]\n  }, {}, [15])(15);\n});","map":null,"metadata":{},"sourceType":"script"}