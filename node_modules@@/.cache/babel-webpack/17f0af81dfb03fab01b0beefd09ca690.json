{"ast":null,"code":"import _asyncToGenerator from \"C:/FH/fh-cloud-app/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { __decorate } from \"tslib\";\nimport __NG_CLI_RESOURCE__0 from \"!C:\\\\FH\\\\fh-cloud-app\\\\node_modules\\\\@ngtools\\\\webpack\\\\src\\\\loaders\\\\direct-resource.js!./hos-chart.component.html\";\nimport __NG_CLI_RESOURCE__1 from \"./hos-chart.component.css\";\nimport { Component, Input, ViewChild } from '@angular/core';\nimport * as _ from 'lodash';\nimport * as moment from 'moment';\nimport { BaseChartDirective } from 'ng2-charts';\nimport { Subject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { ApiService } from 'src/app/services/api.service';\nlet HosChartComponent = class HosChartComponent {\n  constructor(apiService) {\n    this.apiService = apiService;\n    this.chartDataset = [];\n    this.totalAccumulated = 0;\n    this.coordinates = 759 / 24 / 60;\n    this.timeTillInMinutes = 0;\n    this.timeTillInSeconds = 0;\n    this.currentEvent = {};\n    this.eventList = [];\n    this.dutyCycleChanges = [];\n    this.accumulatedOFF = 0;\n    this.accumulatedSB = 0;\n    this.accumulatedD = 0;\n    this.accumulatedON = 0;\n    this.lastEventOfYesterday = {};\n    this.lastEventYesterdayTimeInSeconds = 0;\n    this.destroy$ = new Subject();\n    this.currentDate = moment().format('DD-MM-YYYY'); //* Charts JS Section\n\n    this.lineChartData = [{\n      data: this.chartDataset,\n      label: 'Duty Status',\n      steppedLine: true,\n      fill: false,\n      borderColor: 'black'\n    }];\n    /** Y Axis labels */\n\n    this.yLabels = {\n      0.5: DutyStatus.ON,\n      1.5: DutyStatus.D,\n      2.5: DutyStatus.SB,\n      3.5: DutyStatus.OFF\n    };\n    this.lineChartLabels = [];\n    this.lineChartOptions = {\n      animation: {\n        duration: 1000 * 1.5,\n        easing: 'easeOutSine'\n      },\n      annotation: {},\n      legend: {\n        display: false\n      },\n      tooltips: {\n        callbacks: {\n          labelColor: function (context) {\n            return {\n              borderColor: \"rgb(0, 0, 255)\",\n              backgroundColor: \"white\",\n              borderWidth: 2,\n              borderDash: [2, 2],\n              borderRadius: 2\n            };\n          },\n          label: tooltipItem => {\n            switch (tooltipItem.yLabel) {\n              case 1.5:\n                return \"Driving\";\n\n              case 0.5:\n                return \"ON Duty\";\n\n              case 2.5:\n                return \"Sleeper Birth\";\n\n              case 3.5:\n                return \"OFF Duty\";\n\n              default:\n                return tooltipItem.yLabel;\n            }\n          }\n        }\n      },\n      responsive: false,\n      scales: {\n        yAxes: [{\n          gridLines: {\n            color: 'gray',\n            lineWidth: 1,\n            zeroLineColor: \"gray\",\n            zeroLineWidth: 1,\n            offsetGridLines: false,\n            drawBorder: true,\n            drawTicks: false\n          },\n          ticks: {\n            padding: 10,\n            beginAtZero: true,\n            stepSize: 0.5,\n            min: 0,\n            max: 4,\n            callback: function (value, index, values) {\n              switch (value) {\n                case 0:\n                  return \"\";\n\n                case 1:\n                  return DutyStatus.ON;\n\n                case 2:\n                  return DutyStatus.D;\n\n                case 3:\n                  return DutyStatus.SB;\n\n                case 4:\n                  return DutyStatus.OFF;\n              }\n            }\n          }\n        }],\n        xAxes: [{\n          position: \"top\",\n          type: \"time\",\n          gridLines: {\n            color: 'gray',\n            lineWidth: 1,\n            zeroLineColor: \"gray\",\n            zeroLineWidth: 1,\n            offsetGridLines: false,\n            drawBorder: true,\n            drawTicks: false\n          },\n          time: {\n            parser: \"HH:mm:ss\",\n            unit: \"hour\",\n            displayFormats: {\n              hour: \"HH\"\n            }\n          },\n          ticks: {\n            padding: 10,\n            min: \"00:00:00\",\n            max: \"24:00:00\",\n            callback: function (value) {\n              switch (value) {\n                case \"00\":\n                  return \"M\";\n\n                case \"12\":\n                  return \"N\";\n\n                case \"24\":\n                  return \"M\";\n              }\n\n              return value;\n            }\n          }\n        }]\n      }\n    };\n    this.lineChartColors = [{\n      backgroundColor: 'black'\n    }];\n    this.lineChartLegend = false;\n    this.lineChartType = 'line';\n    this.lineChartPlugins = [];\n  }\n\n  ngOnChanges() {\n    this.plotHosGraph();\n  }\n\n  plotHosGraph() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.chartDataset = [];\n      _this.lineChartData[0].data = _this.chartDataset;\n\n      _this.chart.update();\n\n      _this.emptyData();\n\n      _this.minutesElapsed(); // Fetch yesterday event\n\n\n      _this.fetchLastEventYesterday(); // Fetch current date events\n\n\n      _this.fetchEvents();\n    })();\n  }\n\n  emptyData() {\n    this.totalAccumulated = 0;\n    this.timeTillInMinutes = 0;\n    this.timeTillInSeconds = 0;\n    this.currentEvent = {};\n    this.eventList = [];\n    this.dutyCycleChanges = [];\n    this.accumulatedOFF = 0;\n    this.accumulatedSB = 0;\n    this.accumulatedD = 0;\n    this.accumulatedON = 0;\n    this.lastEventOfYesterday = {};\n    this.lastEventYesterdayTimeInSeconds = 0;\n  }\n  /**\r\n   * get last event of yesterday\r\n   */\n\n\n  fetchLastEventYesterday() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let lastDayDate = moment(_this2.date).subtract(1, 'days').format(\"YYYY-MM-DD\");\n\n      _this2.apiService.getData(`compliance/hosLastDayEvent?userName=${_this2.userName}&eventDate=${lastDayDate}`).pipe(takeUntil(_this2.destroy$)).subscribe(result => {\n        if (result.length > 0) {\n          _this2.lastEventOfYesterday = result[0];\n          const lastDayEvents = result[0];\n          let dutyStatus;\n\n          switch (lastDayEvents.hosEvntDesc) {\n            case 'ON':\n              dutyStatus = GraphDutyStatus.ON;\n              break;\n\n            case 'OFF':\n              dutyStatus = GraphDutyStatus.OFF;\n              break;\n\n            case 'D':\n              dutyStatus = GraphDutyStatus.D;\n              break;\n\n            case 'ON':\n              dutyStatus = GraphDutyStatus.ON;\n              break;\n\n            default:\n              break;\n          } // construct last days events from start of the day\n          // this.chartDataset.push({\n          //   x: '00:00:00',\n          //   y: dutyStatus\n          // });\n          // update last day event till current days time          \n\n\n          _this2.lineChartData[0].data = _this2.chartDataset;\n\n          _this2.chart.update();\n        }\n      });\n    })();\n  }\n  /**\r\n  * get all todays events\r\n  */\n\n\n  fetchEvents() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3.apiService.getData(`compliance/hosDetail?userName=${_this3.userName}&eventDate=${_this3.date}`).pipe(takeUntil(_this3.destroy$)).subscribe(result => {\n        for (let i = 0; i < result.length; i++) {\n          for (let key in result[i]) {\n            if (result[i].hasOwnProperty(key)) {\n              // Add event list localy\n              _this3.eventList = result[i][key].eventList;\n              /** refine events based to duty status */\n\n              _this3.eventList.forEach(evnt => {\n                if (evnt.type === DutyStatus.OFF) {\n                  // Push Start time\n                  _this3.chartDataset.push({\n                    x: evnt.time,\n                    y: 3.5\n                  });\n                }\n\n                ;\n\n                if (evnt.type == DutyStatus.D) {\n                  // Push Start time\n                  _this3.chartDataset.push({\n                    x: evnt.time,\n                    y: 1.5\n                  });\n                }\n\n                if (evnt.type == DutyStatus.SB) {\n                  // Push Start time\n                  _this3.chartDataset.push({\n                    x: evnt.time,\n                    y: 2.5\n                  });\n                }\n\n                if (evnt.type == DutyStatus.ON || evnt.type == DutyStatus.YM) {\n                  // Push Start time\n                  _this3.chartDataset.push({\n                    x: evnt.time,\n                    y: 0.5\n                  });\n                }\n              });\n\n              if (_this3.date === _this3.currentDate) {\n                _this3.chartDataset.push({\n                  x: _this3.getCurrentTime(),\n                  y: _this3.chartDataset[_this3.chartDataset.length - 1].y\n                });\n              } else {\n                _this3.chartDataset.push({\n                  x: '23:59:59',\n                  y: _this3.chartDataset[_this3.chartDataset.length - 1].y\n                });\n              }\n\n              _this3.lineChartData[0].data = _this3.chartDataset;\n\n              _this3.chart.update();\n\n              let length = result[i][key].eventList.length; // Add current event locally\n\n              _this3.currentEvent = {\n                id: result[i][key].eventList[length - 1].id,\n                type: _this3.setType(result[i][key].eventList[length - 1].type)\n              }; // Add accumulated data\n\n              _this3.refineAccumulatedData(result[i][key].accumlatedHOS); // Add yesterday last event accumulated\n\n\n              _this3.addYesterdayLastEventAccumulated(); // Decide last/current event accumulated data\n              //  this.lastEventAccumulatedData();   //already decided from backend\n\n            }\n          }\n        }\n\n        if (result.length === 0) {\n          _this3.takeYesterdayLastEventToCurrentTime();\n        }\n\n        if (result.length === 0) {\n          if (_this3.chartDataset.length === 1) {\n            _this3.chartDataset.push({\n              x: _this3.getCurrentTime(),\n              y: _this3.chartDataset[0].y\n            });\n\n            _this3.lineChartData[0].data = _this3.chartDataset;\n\n            _this3.chart.update();\n          }\n        }\n      });\n    })();\n  }\n\n  refineAccumulatedData(data) {\n    // get the time difference from the beginning of the day to the first event of the today in seconds to calculate accumulated data\n    this.lastEventYesterdayTimeInSeconds = this.calculateTimeDiffInSeconds(moment().format('DD-MM-YYYY 00:00:00'), this.eventList[0].dateTime); // set types\n\n    let refine = data.map(m => {\n      return {\n        type: this.setType(m.type),\n        time: m.time\n      };\n    }); //sum the same types\n\n    let sum = _(refine).groupBy('type').map((objs, key) => ({\n      type: key,\n      time: _.sumBy(objs, 'time')\n    })).value();\n\n    for (let i = 0; i < sum.length; i++) {\n      this.updateAccumulated(sum[i]);\n    }\n  }\n\n  minutesElapsed() {\n    const startDate = moment().format('DD-MM-YYYY 00:00:00');\n    const endDate = moment().format(' DD-MM-YYYY HH:mm:ss');\n    const startDate2 = moment(startDate, 'DD-MM-YYYY HH:mm:ss');\n    const endDate2 = moment(endDate, 'DD-MM-YYYY HH:mm:ss');\n    const duration = moment.duration(endDate2.diff(startDate2));\n    this.timeTillInMinutes = duration.asMinutes();\n    this.timeTillInSeconds = duration.asSeconds();\n  }\n\n  calculateTimeDiffInMinutes(start, end) {\n    let start_date = moment(start, 'DD-MM-YYYY HH:mm:ss');\n    let end_date = moment(end, 'DD-MM-YYYY HH:mm:ss');\n    let duration = moment.duration(end_date.diff(start_date));\n    let diff = duration.asMinutes();\n    return diff;\n  }\n\n  calculateTimeDiffInSeconds(start, end) {\n    let start_date = moment(start, 'DD-MM-YYYY HH:mm:ss');\n    let end_date = moment(end, 'DD-MM-YYYY HH:mm:ss');\n    let duration = moment.duration(end_date.diff(start_date));\n    let diff = duration.asSeconds();\n    return diff;\n  }\n\n  updateAccumulated(data) {\n    if (data.type === 'OFF') this.accumulatedOFF += data.time;\n    if (data.type === 'SB') this.accumulatedSB += data.time;\n    if (data.type === 'D') this.accumulatedD += data.time;\n    if (data.type === 'ON') this.accumulatedON += data.time; //save their total also\n\n    this.totalAccumulated += data.time;\n  }\n\n  lastEventAccumulatedData() {\n    if (this.date === this.currentDate) {\n      if (this.currentEvent.type === 'OFF') {\n        this.accumulatedOFF += this.timeTillInSeconds - this.totalAccumulated - this.lastEventYesterdayTimeInSeconds;\n      }\n\n      if (this.currentEvent.type === 'SB') {\n        this.accumulatedSB += this.timeTillInSeconds - this.totalAccumulated - this.lastEventYesterdayTimeInSeconds;\n      }\n\n      if (this.currentEvent.type === 'D') {\n        this.accumulatedD += this.timeTillInSeconds - this.totalAccumulated - this.lastEventYesterdayTimeInSeconds;\n      }\n\n      if (this.currentEvent.type === 'ON') {\n        this.accumulatedON += this.timeTillInSeconds - this.totalAccumulated - this.lastEventYesterdayTimeInSeconds;\n      }\n    } else {\n      let length = this.eventList.length;\n      let from = this.eventList[length - 1].dateTime;\n      let to = this.date + ' ' + '23:59:59';\n      let restTime = this.calculateTimeDiffInSeconds(from, to);\n\n      if (this.currentEvent.type === 'OFF') {\n        this.accumulatedOFF += restTime;\n      }\n\n      if (this.currentEvent.type === 'SB') {\n        this.accumulatedSB += restTime;\n      }\n\n      if (this.currentEvent.type === 'D') {\n        this.accumulatedD += restTime;\n      }\n\n      if (this.currentEvent.type === 'ON') {\n        this.accumulatedON += restTime;\n      }\n    }\n  }\n\n  takeYesterdayLastEventToCurrentTime() {\n    let diff = '';\n\n    if (this.date === this.currentDate) {\n      //get the time difference from the beginning of the day to the current time of the today\n      diff = this.calculateTimeDiffInMinutes(moment().format('DD-MM-YYYY 00:00:00'), moment().format('DD-MM-YYYY HH:mm:ss'));\n    } else {\n      // get the time difference from the beginning of the day to the end time of the date\n      diff = this.calculateTimeDiffInMinutes(moment().format('DD-MM-YYYY 00:00:00'), moment().format('DD-MM-YYYY 23:59:59'));\n    } // use this as start point of x for next event from the current\n\n\n    let nextStart = diff; // first add the last event of yesterday\n\n    this.dutyCycleChanges.push({\n      type: this.setType(this.lastEventOfYesterday.hosEvntDesc),\n      time: diff,\n      nextStart\n    });\n\n    if (this.date === this.currentDate) {\n      this.updateAccumulated({\n        type: this.setType(this.lastEventOfYesterday.hosEvntDesc),\n        time: this.calculateTimeDiffInSeconds(moment().format('DD-MM-YYYY 00:00:00'), moment().format('DD-MM-YYYY HH:mm:ss'))\n      });\n    } else {\n      this.updateAccumulated({\n        type: this.setType(this.lastEventOfYesterday.hosEvntDesc),\n        time: this.calculateTimeDiffInSeconds(moment().format('DD-MM-YYYY 00:00:00'), moment().format('DD-MM-YYYY 23:59:59'))\n      });\n    }\n  }\n\n  addYesterdayLastEventAccumulated() {\n    if (this.setType(this.lastEventOfYesterday.hosEvntDesc) === 'OFF') this.accumulatedOFF += this.lastEventYesterdayTimeInSeconds;\n    if (this.setType(this.lastEventOfYesterday.hosEvntDesc) === 'SB') this.accumulatedSB += this.lastEventYesterdayTimeInSeconds;\n    if (this.setType(this.lastEventOfYesterday.hosEvntDesc) === 'D') this.accumulatedD += this.lastEventYesterdayTimeInSeconds;\n    if (this.setType(this.lastEventOfYesterday.hosEvntDesc) === 'ON') this.accumulatedON += this.lastEventYesterdayTimeInSeconds;\n  }\n\n  getCurrentTime() {\n    const currentDate = new Date();\n    return `${currentDate.getHours()}:${currentDate.getMinutes()}:${currentDate.getSeconds()}`;\n  }\n  /**\r\n   * Conside 'YM' as 'ON' and 'PC' as 'OFF'\r\n   * @param type : string\r\n   */\n\n\n  setType(type) {\n    if (type === 'YM') {\n      return 'ON';\n    } else if (type === 'PC') {\n      return 'OFF';\n    } else {\n      return type;\n    }\n  }\n\n};\n\nHosChartComponent.ctorParameters = () => [{\n  type: ApiService\n}];\n\nHosChartComponent.propDecorators = {\n  date: [{\n    type: Input\n  }],\n  userName: [{\n    type: Input\n  }],\n  chart: [{\n    type: ViewChild,\n    args: [BaseChartDirective, {\n      static: true\n    }]\n  }]\n};\nHosChartComponent = __decorate([Component({\n  selector: 'app-hos-chart',\n  template: __NG_CLI_RESOURCE__0,\n  styles: [__NG_CLI_RESOURCE__1]\n})], HosChartComponent);\nexport { HosChartComponent };\nvar GraphDutyStatus;\n\n(function (GraphDutyStatus) {\n  GraphDutyStatus[GraphDutyStatus[\"ON\"] = 0.5] = \"ON\";\n  GraphDutyStatus[GraphDutyStatus[\"D\"] = 1.5] = \"D\";\n  GraphDutyStatus[GraphDutyStatus[\"SB\"] = 2.5] = \"SB\";\n  GraphDutyStatus[GraphDutyStatus[\"OFF\"] = 3.5] = \"OFF\";\n})(GraphDutyStatus || (GraphDutyStatus = {}));\n\nvar DutyStatus;\n\n(function (DutyStatus) {\n  DutyStatus[\"ON\"] = \"ON\";\n  DutyStatus[\"D\"] = \"D\";\n  DutyStatus[\"SB\"] = \"SB\";\n  DutyStatus[\"OFF\"] = \"OFF\";\n  DutyStatus[\"YM\"] = \"YM\";\n})(DutyStatus || (DutyStatus = {}));","map":null,"metadata":{},"sourceType":"module"}