{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Component, ChangeDetectionStrategy, ViewEncapsulation, Input, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Subject, of, timer, combineLatest, Observable } from 'rxjs';\nimport { take, map, tap, startWith, switchMap, shareReplay } from 'rxjs/operators';\n\nfunction LoadingBarComponent_ng_container_0_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵelement(1, \"div\", 4);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"width\", ctx_r2.diameter)(\"height\", ctx_r2.diameter);\n  }\n}\n\nfunction LoadingBarComponent_ng_container_0_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 5);\n  }\n\n  if (rf & 2) {\n    const progress_r1 = i0.ɵɵnextContext().ngIf;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"background\", ctx_r3.color)(\"height\", ctx_r3.height)(\"width\", progress_r1 + \"%\");\n  }\n}\n\nfunction LoadingBarComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, LoadingBarComponent_ng_container_0_div_1_Template, 2, 4, \"div\", 1);\n    i0.ɵɵtemplate(2, LoadingBarComponent_ng_container_0_div_2_Template, 1, 6, \"div\", 2);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.includeSpinner);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.includeBar);\n  }\n}\n\nclass LoadingBarState {\n  constructor(config = {}) {\n    this.config = config;\n    this.state = {\n      action: null,\n      value: 0,\n      initialValue: 0\n    };\n    this.requests = null;\n    this.disabled = false;\n    this.stream$ = new Subject();\n    this._value$ = null;\n\n    this.timer$ = s => {\n      let state$ = of(s);\n\n      switch (s.action) {\n        case 'start':\n        case 'increment':\n        case 'set':\n          {\n            if (s.action === 'start' && this.config.latencyThreshold === 0 && s.value === 0) {\n              s.value = s.initialValue;\n            }\n\n            if (this.requests > 0) {\n              state$ = timer(this.config.latencyThreshold, 250).pipe(map(t => ({ ...s,\n                value: t === 0 ? this.state.value || s.initialValue : this._increment()\n              })));\n            }\n\n            break;\n          }\n\n        case 'complete':\n        case 'stop':\n          {\n            // Attempt to aggregate any start/complete calls within 500ms:\n            state$ = s.value === 0 ? of({ ...s\n            }) : timer(0, 500).pipe(take(2), map(t => ({\n              value: t === 0 ? 100 : 0\n            })));\n            break;\n          }\n      }\n\n      return state$.pipe(map(next => ({ ...next,\n        action: 'set'\n      })), tap(next => this.next(next, false)));\n    };\n\n    this.config = {\n      latencyThreshold: 0,\n      ...config\n    };\n  }\n\n  get value$() {\n    if (this._value$) {\n      return this._value$;\n    }\n\n    return this._value$ = this.stream$.pipe(startWith(this.state), switchMap(s => this.timer$(s)), shareReplay(), map(s => s.value));\n  }\n\n  start(initialValue = 2) {\n    if (this.disabled) {\n      return;\n    }\n\n    this.next({\n      action: 'start',\n      initialValue\n    });\n  }\n\n  stop() {\n    this.next({\n      action: 'stop'\n    });\n  }\n\n  complete() {\n    this.next({\n      action: 'complete'\n    });\n  }\n\n  disable() {\n    this.disabled = true;\n  }\n\n  set(value) {\n    this.next({\n      action: 'set',\n      value\n    });\n  }\n\n  increment(value = 0) {\n    this.next({\n      action: 'increment',\n      value\n    });\n  }\n\n  next(state, emitEvent = true) {\n    switch (state.action) {\n      case 'start':\n        this.requests = (this.requests || 0) + 1;\n        break;\n\n      case 'complete':\n        this.requests = (this.requests || 1) - 1;\n\n        if (this.requests > 0) {\n          return;\n        }\n\n        break;\n\n      case 'stop':\n        this.requests = 0;\n        break;\n\n      case 'increment':\n        state.value = this._increment(state.value);\n        break;\n    }\n\n    this.state = { ...this.state,\n      action: null,\n      ...state\n    };\n\n    if (emitEvent) {\n      this.stream$.next(this.state);\n    }\n  }\n\n  _increment(rnd = 0) {\n    const stat = this.state.value;\n\n    if (stat >= 99) {\n      rnd = 0;\n    }\n\n    if (rnd === 0) {\n      if (stat >= 0 && stat < 25) {\n        // Start out between 3 - 6% increments\n        rnd = Math.random() * (5 - 3 + 1) + 3;\n      } else if (stat >= 25 && stat < 65) {\n        // increment between 0 - 3%\n        rnd = Math.random() * 3;\n      } else if (stat >= 65 && stat < 90) {\n        // increment between 0 - 2%\n        rnd = Math.random() * 2;\n      } else if (stat >= 90 && stat < 99) {\n        // finally, increment it .5 %\n        rnd = 0.5;\n      } else {\n        // after 99%, don't increment:\n        rnd = 0;\n      }\n    }\n\n    return rnd + stat;\n  }\n\n}\n\nconst LOADING_BAR_CONFIG = new InjectionToken('LOADING_BAR_CONFIG');\n\nclass LoadingBarService {\n  constructor(platformId, config = {}, zone) {\n    this.platformId = platformId;\n    this.config = config;\n    this.zone = zone;\n    this.refs = {};\n    this.streams$ = new Subject();\n    this.value$ = this.streams$.pipe(startWith(null), switchMap(() => combineLatest(Object.keys(this.refs).map(s => this.refs[s].value$))), runInZone(this.zone), map(v => Math.max(0, ...v)));\n  }\n  /** @deprecated use `value$` instead. */\n\n\n  get progress$() {\n    return this.value$;\n  }\n  /** @deprecated use `useRef` instead. */\n\n\n  start(initialValue = 2) {\n    this.useRef().start(initialValue);\n  }\n  /** @deprecated use `useRef` instead. */\n\n\n  set(value) {\n    this.useRef().set(value);\n  }\n  /** @deprecated use `useRef` instead. */\n\n\n  increment(value) {\n    this.useRef().increment(value);\n  }\n  /** @deprecated use `useRef` instead. */\n\n\n  complete() {\n    this.useRef().complete();\n  }\n  /** @deprecated use `useRef` instead. */\n\n\n  stop() {\n    this.useRef().stop();\n  }\n\n  useRef(id = 'default') {\n    if (!this.refs[id]) {\n      this.refs[id] = new LoadingBarState(this.config);\n      this.streams$.next();\n\n      if (!isPlatformBrowser(this.platformId)) {\n        this.refs[id].disable();\n      }\n    }\n\n    return this.refs[id];\n  }\n\n}\n\nLoadingBarService.ɵfac = function LoadingBarService_Factory(t) {\n  return new (t || LoadingBarService)(i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(LOADING_BAR_CONFIG, 8), i0.ɵɵinject(i0.NgZone, 8));\n};\n\nLoadingBarService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LoadingBarService,\n  factory: LoadingBarService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoadingBarService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [LOADING_BAR_CONFIG]\n      }]\n    }, {\n      type: i0.NgZone,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})(); // https://stackoverflow.com/a/57452361/1406096\n\n\nfunction runInZone(zone) {\n  if (!zone) {\n    return source => source;\n  }\n\n  return source => new Observable(observer => source.subscribe(value => zone.run(() => observer.next(value)), e => zone.run(() => observer.error(e)), () => zone.run(() => observer.complete())));\n}\n\nclass LoadingBarComponent {\n  constructor(loader) {\n    this.loader = loader;\n    this.includeSpinner = true;\n    this.includeBar = true;\n    this.fixed = true;\n    this.color = '#29d';\n  }\n\n  get value$() {\n    return this.ref ? this.loader.useRef(this.ref).value$ : this.loader.value$;\n  }\n\n}\n\nLoadingBarComponent.ɵfac = function LoadingBarComponent_Factory(t) {\n  return new (t || LoadingBarComponent)(i0.ɵɵdirectiveInject(LoadingBarService));\n};\n\nLoadingBarComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: LoadingBarComponent,\n  selectors: [[\"ngx-loading-bar\"]],\n  hostVars: 3,\n  hostBindings: function LoadingBarComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"fixed\", ctx.fixed);\n      i0.ɵɵstyleProp(\"color\", ctx.color);\n    }\n  },\n  inputs: {\n    includeSpinner: \"includeSpinner\",\n    includeBar: \"includeBar\",\n    fixed: \"fixed\",\n    color: \"color\",\n    value: \"value\",\n    ref: \"ref\",\n    height: \"height\",\n    diameter: \"diameter\"\n  },\n  decls: 2,\n  vars: 3,\n  consts: [[4, \"ngIf\"], [\"class\", \"ngx-spinner\", 4, \"ngIf\"], [\"class\", \"ngx-bar\", 3, \"background\", \"height\", \"width\", 4, \"ngIf\"], [1, \"ngx-spinner\"], [1, \"ngx-spinner-icon\"], [1, \"ngx-bar\"]],\n  template: function LoadingBarComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵtemplate(0, LoadingBarComponent_ng_container_0_Template, 3, 2, \"ng-container\", 0);\n      i0.ɵɵpipe(1, \"async\");\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"ngIf\", ctx.value != null ? ctx.value : i0.ɵɵpipeBind1(1, 1, ctx.value$));\n    }\n  },\n  directives: [i2.NgIf],\n  pipes: [i2.AsyncPipe],\n  styles: [\"[_nghost-%COMP%]{position:relative;display:block;pointer-events:none}[_nghost-%COMP%]   .ngx-spinner[_ngcontent-%COMP%]{transition:.35s linear all;display:block;position:absolute;top:5px;left:0px}[_nghost-%COMP%]   .ngx-spinner[_ngcontent-%COMP%]   .ngx-spinner-icon[_ngcontent-%COMP%]{width:14px;height:14px;border:solid 2px transparent;border-top-color:inherit;border-left-color:inherit;border-radius:50%;-webkit-animation:loading-bar-spinner .4s linear infinite;animation:loading-bar-spinner .4s linear infinite}[_nghost-%COMP%]   .ngx-bar[_ngcontent-%COMP%]{transition:width .35s;position:absolute;top:0;left:0;width:100%;height:2px;border-bottom-right-radius:1px;border-top-right-radius:1px}[dir=rtl]   [_nghost-%COMP%]   .ngx-bar[_ngcontent-%COMP%]{right:0;left:unset}[fixed=true][_nghost-%COMP%]{z-index:10002}[fixed=true][_nghost-%COMP%]   .ngx-bar[_ngcontent-%COMP%]{position:fixed}[fixed=true][_nghost-%COMP%]   .ngx-spinner[_ngcontent-%COMP%]{position:fixed;top:10px;left:10px}[dir=rtl]   [fixed=true][_nghost-%COMP%]   .ngx-spinner[_ngcontent-%COMP%]{right:10px;left:unset}@-webkit-keyframes loading-bar-spinner{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes loading-bar-spinner{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\"],\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoadingBarComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-loading-bar',\n      template: `\n    <ng-container *ngIf=\"value != null ? value : (value$ | async) as progress\">\n      <div *ngIf=\"includeSpinner\" class=\"ngx-spinner\">\n        <div [style.width]=\"diameter\" [style.height]=\"diameter\" class=\"ngx-spinner-icon\"></div>\n      </div>\n      <div\n        *ngIf=\"includeBar\"\n        class=\"ngx-bar\"\n        [style.background]=\"color\"\n        [style.height]=\"height\"\n        [style.width]=\"progress + '%'\"\n      ></div>\n    </ng-container>\n  `,\n      preserveWhitespaces: false,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      encapsulation: ViewEncapsulation.Emulated,\n      host: {\n        '[attr.fixed]': 'fixed',\n        '[style.color]': 'color'\n      },\n      styles: [\":host{position:relative;display:block;pointer-events:none}:host .ngx-spinner{transition:.35s linear all;display:block;position:absolute;top:5px;left:0px}:host .ngx-spinner .ngx-spinner-icon{width:14px;height:14px;border:solid 2px transparent;border-top-color:inherit;border-left-color:inherit;border-radius:50%;-webkit-animation:loading-bar-spinner .4s linear infinite;animation:loading-bar-spinner .4s linear infinite}:host .ngx-bar{transition:width .35s;position:absolute;top:0;left:0;width:100%;height:2px;border-bottom-right-radius:1px;border-top-right-radius:1px}[dir=rtl] :host .ngx-bar{right:0;left:unset}:host[fixed=true]{z-index:10002}:host[fixed=true] .ngx-bar{position:fixed}:host[fixed=true] .ngx-spinner{position:fixed;top:10px;left:10px}[dir=rtl] :host[fixed=true] .ngx-spinner{right:10px;left:unset}@-webkit-keyframes loading-bar-spinner{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes loading-bar-spinner{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\\n\"]\n    }]\n  }], function () {\n    return [{\n      type: LoadingBarService\n    }];\n  }, {\n    includeSpinner: [{\n      type: Input\n    }],\n    includeBar: [{\n      type: Input\n    }],\n    fixed: [{\n      type: Input\n    }],\n    color: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    ref: [{\n      type: Input\n    }],\n    height: [{\n      type: Input\n    }],\n    diameter: [{\n      type: Input\n    }]\n  });\n})();\n\nclass LoadingBarModule {}\n\nLoadingBarModule.ɵfac = function LoadingBarModule_Factory(t) {\n  return new (t || LoadingBarModule)();\n};\n\nLoadingBarModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LoadingBarModule\n});\nLoadingBarModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoadingBarModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [LoadingBarComponent],\n      exports: [LoadingBarComponent]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LOADING_BAR_CONFIG, LoadingBarComponent, LoadingBarModule, LoadingBarService }; //# sourceMappingURL=ngx-loading-bar-core.mjs.map","map":null,"metadata":{},"sourceType":"module"}